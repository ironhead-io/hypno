bridge.c:117:				lua_pushnumber( L, r->vint );				
bridge.c:119:				lua_pushnumber( L, r->vfloat );				
bridge.c:121:				lua_pushstring( L, r->vchar );
bridge.c:129:				LiteBlob *bb = &r->vblob;
example/khan.org/data.lua:53:		banner = "banner-prod"
example/data.lua:53:		banner = "banner-prod"
example/errors.com/data.lua:55:		banner = "banner-prod"
example/ferpa/data.lua:53:		banner = "banner-prod"
httptest.c:67: //"User-Agent"       ": Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0\r\n"
httptest.c:92:User-Agent: curl/7.49.1
httptest.c:305:	GETITEM( r->URL, "1" );
httptest.c:306:	GETITEM( r->GET, "index" );
httptest.c:307:	GETITEM( r->headers, "Content-Type" );
httptest.c:318:	GETITEM( r->URL, "2" );
httptest.c:319:	GETITEM( r->headers, "Content-Type" );
httptest.c:320:	GETITEM( r->body, "FirstName" );
lua.c:300:	HTTP *h      = (HTTP *)r->userdata;
lua.c:343:				lua_pushnumber( L, r->vint );				
lua.c:345:				lua_pushnumber( L, r->vfloat );				
lua.c:347:				lua_pushstring( L, r->vchar );
lua.c:355:				LiteBlob *bb = &r->vblob;
main.c:177:	HTTP *h = (HTTP *)r->userdata;
main.c:192:#include "tests/char-char.c"
main.c:196:	HTTP *h = (HTTP *)r->userdata;
main.c:212:	r->status = 2;
main.c:213:	r->stage = NW_AT_WRITE;
main.c:216:	if ( r->stage == NW_COMPLETED ) {
main.c:217:		//r->stage = NW_AT_WRITE;
main.c:257:	HTTP *h = (HTTP *)r->userdata;
main.c:262:	req->mlen = r->recvd;
main.c:268:	if ( !http_get_remaining( h, r->request, r->recvd ) )
main.c:366:			r->stage = NW_AT_WRITE;
main.c:560:	r->stage = NW_AT_WRITE;
vendor/http.c:90:	r->stage = NW_AT_WRITE;
vendor/http.c:104:		{ r->method,   HTTP_METHOD_MAX },
vendor/http.c:105:		{ r->path,     HTTP_URL_MAX },
vendor/http.c:106:		{ r->protocol, HTTP_PROTO_MAX }
vendor/http.c:153:		r->clen = atoi(length_char);
vendor/http.c:165:	return ((r->hlen = memstrat(msg, "\r\n\r\n", len)) == -1) ? 0 : 1;
vendor/http.c:175:	if (r->hlen + 4 == len)
vendor/http.c:177:	r->mlen = len - (r->hlen + 4);	
vendor/http.c:191:	if ( (bs = memstrat(msg, "boundary=", r->hlen)) > -1) {
vendor/http.c:193:		be = memchrat(&msg[bs], '\r', r->hlen - bs); 
vendor/http.c:194:		be = (be > -1) ? be : r->hlen - bs; 
vendor/http.c:195:		memcpy(r->boundary, &msg[bs], be);
vendor/http.c:196:		r->boundary[be] = '\0';
vendor/http.c:252:			/*r->URL,*/ (uint8_t *)r->path, strlen(r->path), 1, 0 },
vendor/http.c:255:			/*r->headers, */  msg, r->hlen    , 1, 1 },
vendor/http.c:258:			/*r->GET,*/ (uint8_t *)r->path, strlen(r->path), 1, 1 },
vendor/http.c:260:		{ "POST",'m', 0  ,{ .words = {{r->boundary},{"\r\n\r\n"},{"\r\n"},{":"},{"="},{";"},{NULL}} },
vendor/http.c:261:			/*r->body,*/ &msg[r->hlen + 4], r->clen        , 1, 0 },
vendor/http.c:264:			/*r->body,*/ &msg[r->hlen + 4], r->clen        , 1 }
vendor/http.c:268:	lt_init( &r->table, NULL, 1027 );
vendor/http.c:271:	if ( memcmp( "HEAD", r->method, 4 ) == 0 )
vendor/http.c:273:	else if ( memcmp( "GET", r->method, 3 ) == 0 )
vendor/http.c:274:		runner = memchr( r->path, '?', strlen(r->path) ) ? 3 : 2;
vendor/http.c:275:	else if ( memcmp( "POST", r->method, 4 ) == 0 || memcmp( "PUT", r->method, 3 ) == 0 ) 
vendor/http.c:277:		runner = memchr( r->path, '?', strlen(r->path) ) ? 3 : 2;
vendor/http.c:278:		hs[ runner++ ] = hs [ (*r->boundary) ? 3 : 4 ];
vendor/http.c:298:		lt_addblobkey( &r->table, (unsigned char *)h->name, strlen(h->name));
vendor/http.c:299:		lt_descend( &r->table );
vendor/http.c:320:					lt_addintkey( &r->table, ++bw );
vendor/http.c:327:				lt_addblobvalue( &r->table, blob, adjust );
vendor/http.c:328:				lt_finalize( &r->table );
vendor/http.c:350:				lt_addblobkey( &r->table, ret, adjust );
vendor/http.c:351:				lt_descend( &r->table );
vendor/http.c:358:					lt_addintkey( &r->table, bw );
vendor/http.c:359:					lt_addblobvalue( &r->table, (uint8_t *)"/", 1 );
vendor/http.c:360:					lt_finalize( &r->table );
vendor/http.c:369:				lt_addintkey( &r->table, ++bw );
vendor/http.c:370:				lt_addblobvalue( &r->table, &h->msg[ ps->prev - 1 ], ps->size + 1 );
vendor/http.c:371:				lt_finalize( &r->table );
vendor/http.c:375:				lt_addintkey( &r->table, ++bw );
vendor/http.c:376:				lt_addblobvalue( &r->table, &h->msg[ ps->prev - 1 ], ps->size + 1 );
vendor/http.c:377:				lt_finalize( &r->table ); 
vendor/http.c:388:					lt_addblobkey( &r->table, blob, adjust );
vendor/http.c:393:					lt_addblobkey( &r->table, blob, adjust );
vendor/http.c:419:				lt_addblobvalue( &r->table, blob, adjust ); 
vendor/http.c:420:				lt_finalize( &r->table );
vendor/http.c:425:					SHOWDATA( "%d, %s\n", ps->next, r->boundary );
vendor/http.c:426:					int aa = memstrat( &h->msg[ ps->next ], r->boundary, h->ml - ps->next ); 
vendor/http.c:430:					lt_addblobkey (&r->table, (uint8_t *)content_string, strlen(content_string)); 
vendor/http.c:431:					lt_addblobvalue( &r->table, &h->msg[ ps->next ], aa - 2);
vendor/http.c:432:					lt_finalize(&r->table);
vendor/http.c:433:					lt_ascend(&r->table);
vendor/http.c:439:		lt_ascend( &r->table );
vendor/http.c:442:	lt_lock( &r->table );
vendor/http.c:445:	if ( !(host = &lt_blob( &r->table, "headers.Host" ))->size )
vendor/http.c:629:	stprintf("method",         r->method);
vendor/http.c:630:	stprintf("path",           r->path);
vendor/http.c:631:	stprintf("protocol",       r->protocol);
vendor/http.c:632:	nmprintf("content length", (int)r->clen);
vendor/http.c:633:	nmprintf("header length",  (int)r->hlen);
vendor/http.c:634:	nmprintf("message length", (int)r->mlen);
vendor/http.c:635:	stprintf("boundary",       r->boundary);
vendor/http.c:645:	nmprintf("status",         r->status);
vendor/http.c:646:	stprintf("status_text",    r->sttext);
vendor/http.c:647:	nmprintf("bypass",         r->bypass);
vendor/http.c:648:	fdprintf("version",        r->version);
vendor/http.c:649:	stprintf("Content-Type",   r->ctype);
vendor/http.c:651:	nmprintf("Content-Length", r->clen);
vendor/http.c:652:	nmprintf("header length",  (int)r->hlen);
vendor/http.c:653:	nmprintf("message length", (int)r->mlen);
vendor/http.c:655:	bdprintf("message",        r->msg, r->mlen);
vendor/http.c:666:	HTTP *h                 = (HTTP *)r->userdata;
vendor/http.c:669:	request->msg            = r->request;
vendor/http.c:670:	response->msg           = r->response;
vendor/http.c:671:	h->reqb                 = &r->_request;
vendor/http.c:672:	h->resb                 = &r->_response;
vendor/http.c:675:	if ( memstrat(r->request, "GET", r->recvd) > -1 ) 
vendor/http.c:678:		if ( !http_parse_first_line(h, r->request, r->recvd) )
vendor/http.c:680:		if ( !http_get_header_length(h, r->request, r->recvd) )
vendor/http.c:686:	else if ( memstrat(r->request, "POST", r->recvd) > -1 ) 
vendor/http.c:690:		fprintf(stderr, "POST received %d bytes.\n", r->recvd);
vendor/http.c:694:		if ( !strlen( request->path ) && !http_parse_first_line(h, r->request, r->recvd) )
vendor/http.c:698:		if ( !request->clen && !http_get_content_length(h, r->request, r->recvd) )
vendor/http.c:702:		if ( !request->hlen && !http_get_header_length(h, r->request, r->recvd) )
vendor/http.c:706:		if ( !http_get_message_length(h, r->request, r->recvd) )
vendor/http.c:710:		if ( !http_get_boundary(h, r->request, r->recvd) )
vendor/http.c:725:			if (write(r->client->fd, http_100, strlen(http_100)) == -1)
vendor/http.c:749:		//memcpy(r->response, http_405, strlen(http_405));
vendor/http.c:755:		r->stage = NW_AT_PROC;
vendor/http.c:764:	r->stage = NW_AT_WRITE;
vendor/http.c:765:	//r->len = 0;
vendor/http.c:773:	HTTP *h = (HTTP *)r->userdata;
vendor/http.c:774:	r->stage = NW_COMPLETED;
vendor/nw.c:57:	if (NW_CALL( ( r->status = (&s->runners[CODE])->exe(r, s->global_ud, (&s->runners[CODE])->err) ) )) { \
vendor/nw.c:96:	r->client->events = POLLRDNORM
vendor/nw.c:100:	r->client->events = POLLWRNORM
vendor/nw.c:104:	r->client->fd
vendor/nw.c:124:	fprintf(stderr, "child:       %p\n", (void *)&r->child);
vendor/nw.c:125:	fprintf(stderr, "recvd:       %d\n", r->recvd);
vendor/nw.c:126:	fprintf(stderr, "sent:        %d\n", r->sent);
vendor/nw.c:127:	fprintf(stderr, "stage:       %d\n", r->stage);
vendor/nw.c:129:	fprintf(stderr, "request_fd:  %d\n", r->request_fd);
vendor/nw.c:130:	fprintf(stderr, "response_fd: %d\n", r->response_fd);
vendor/nw.c:133:	fprintf(stderr, "request:     %p\n", (void *)r->request);
vendor/nw.c:134:	fprintf(stderr, "response:    %p\n", (void *)r->response);
vendor/nw.c:137:	fprintf(stderr, "request:     %p\n", (void *)r->_request1->buffer);
vendor/nw.c:138:	fprintf(stderr, "response:    %p\n", (void *)r->_response1->buffer);
vendor/nw.c:141:	fprintf(stderr, "userdata:    %p\n", r->userdata);
vendor/nw.c:143:	fprintf(stderr, "pollfd:      %p\n", (void *)&r->client);
vendor/nw.c:144:	fprintf(stderr, "pollfd.fd:   %d\n", r->client->fd);
vendor/nw.c:145:	/*fprintf(stderr, "pollfd.events:   %d\n", r->client.fd);
vendor/nw.c:146:	fprintf(stderr, "pollfd.revents:   %d\n", r->client.fd);*/
vendor/nw.c:147:	fprintf(stderr, "recv_retry:  %d\n", r->recv_retry);
vendor/nw.c:148:	fprintf(stderr, "send_retry:  %d\n", r->send_retry);
vendor/nw.c:279:	memset(&r->child, 0, sizeof(Socket));
vendor/nw.c:281:	memset(&r->request_, 0, NW_MAX_BUFFER_SIZE); 
vendor/nw.c:282:	memset(&r->response_, 0, NW_MAX_BUFFER_SIZE);	
vendor/nw.c:284:	bf_free( &r->_request );
vendor/nw.c:285:	bf_free( &r->_response );
vendor/nw.c:287:	memset(&r->start, 0, sizeof(struct timespec));
vendor/nw.c:288:	memset(&r->end, 0, sizeof(struct timespec));
vendor/nw.c:289:	r->rb = 0, 
vendor/nw.c:290:	r->sb = 0, 
vendor/nw.c:291:	r->recvd = 0, 
vendor/nw.c:292:	r->sent = 0, 
vendor/nw.c:293:	r->stage = 0;
vendor/nw.c:294:	r->recv_retry = 0,
vendor/nw.c:295:	r->send_retry = 0;
vendor/nw.c:303:	r->rb = read(r->client->fd, etc, NW_MAX_BUFFER_SIZE - 1);
vendor/nw.c:305:	if ( !r->rb )
vendor/nw.c:307:	else if ( r->rb == -1 ) 
vendor/nw.c:313:				r->client->events = POLLRDNORM;
vendor/nw.c:336:	if ( !bf_append( &r->_request, etc, r->rb ) ) 
vendor/nw.c:338:		if ( r->_request.error == ERR_BUFF_REALLOC_FAILURE ) {
vendor/nw.c:341:		else if ( r->_request.error == ERR_BUFF_OUT_OF_SPACE ) {
vendor/nw.c:346:	r->recvd += r->rb;
vendor/nw.c:347:	r->request = (&r->_request)->buffer;
vendor/nw.c:357:	SHOWDATA( "file             %d\n", r->client->fd );	
vendor/nw.c:358:	SHOWDATA( "actual length    %d\n", bf_written( &r->_response ));
vendor/nw.c:361:	int len = bf_written( &r->_response );
vendor/nw.c:367:	uint8_t *wB = bf_data( &r->_response );
vendor/nw.c:375:	if ( (r->sb = write( fd, wB, len - r->sent)) == -1 )
vendor/nw.c:379:	SHOWDATA( "%-5d bytes written to file %s\n", r->sb, fbuf);
vendor/nw.c:382:	uint8_t *wB = &r->_response.buffer[r->sent];
vendor/nw.c:383:	r->sb = write(r->client->fd, wB, len - r->sent);
vendor/nw.c:385:	SHOWDATA( "write() syscall returned %d\n", r->sb );
vendor/nw.c:387:	if ( !r->sb ) {
vendor/nw.c:391:	else if ( r->sb == -1 ) {
vendor/nw.c:434:	r->sent += r->sb;
vendor/nw.c:444:	r->client->events = POLLRDNORM;
vendor/nw.c:452:	r->client->events = POLLWRNORM;
vendor/nw.c:460:	return (memset(r->response, 0, NW_MAX_BUFFER_SIZE) != NULL);
vendor/nw.c:475:	return ((close(r->client->fd) != -1) && (r->client->fd = -1));
vendor/nw.c:483:	fprintf(stderr, "r->client is:   %p\n",  (void *)r->client);
vendor/nw.c:484:	fprintf(stderr, "r->client->fd:  %d\n",  r->client->fd);
vendor/nw.c:486:	if (close(r->client->fd) == -1) {
vendor/nw.c:489:	r->client->fd = -1;
vendor/nw.c:640:			Socket *child = &r->child;
vendor/nw.c:652:			if (NW_CALL( !bf_init( &r->_request, r->request_, maxbuf ) || !bf_init( &r->_response, r->response_, maxbuf )))
vendor/nw.c:658:			if ( !bf_init( &r->_request, NULL, maxbuf ) || !bf_init( &r->_response, NULL, maxbuf ) ) 
vendor/nw.c:667:			if ( s->run_limit && r->start.tv_sec ) {
vendor/nw.c:669:				if ( clock_gettime( CLOCK_REALTIME, &r->end ) == -1	)
vendor/nw.c:672:					if ((r->end.tv_sec - r->start.tv_sec) > s->run_limit )
vendor/nw.c:710:			r->client    = &s->clients[i];
vendor/nw.c:711:			r->request   = (&r->_request)->buffer;
vendor/nw.c:712:			r->response  = (&r->_response)->buffer;
vendor/nw.c:730:			if ( NW_CALL( r->client->fd < 0 ) ) {
vendor/nw.c:736:			if ( s->run_limit && !r->start.tv_sec ) {
vendor/nw.c:737:				if ( clock_gettime( CLOCK_REALTIME, &r->start ) == -1	)
vendor/nw.c:743:			if (NW_CALL( r->client->revents & POLLRDNORM /*| POLLERR)*/ )) {
vendor/nw.c:744:				r->stage = NW_AT_READ; 
vendor/nw.c:752:					if ( NW_CALL( r->rb < min_read ) ) {
vendor/nw.c:760:					if ( NW_CALL( r->stage != NW_AT_READ ) ) {
vendor/nw.c:761:						r->client->events = POLLWRNORM;
vendor/nw.c:764:						if ( NW_CALL( ++r->recv_retry >= s->recv_retry) ) {
vendor/nw.c:769:							r->client->events = POLLRDNORM;
vendor/nw.c:773:				} /*(NW_CALL( (rb = read(r->client->fd, &r->request[0], 6400)) == -1 ))*/
vendor/nw.c:777:			} /*(NW_CALL( r->client->revents & (POLLRDNORM | POLLERR) ))*/ 
vendor/nw.c:784:			if ( NW_CALL( r->stage == NW_AT_PROC ) ) {
vendor/nw.c:787:				SHOWDATA( "r->status %d\n", r->status );
vendor/nw.c:790:				if ( r->status > 0 ) {
vendor/nw.c:791:					r->stage = NW_AT_WRITE;
vendor/nw.c:792:					r->client->events = POLLWRNORM;
vendor/nw.c:806:			if ( NW_CALL( r->client->revents & POLLWRNORM && r->stage == NW_AT_WRITE ) ) {
vendor/nw.c:817:niprintf( r->status );
vendor/nw.c:819:					//Check r->status
vendor/nw.c:820:					if ( r->status == 2 ) {
vendor/nw.c:826:					if ( NW_CALL( r->sb < min_write ) ) {
vendor/nw.c:833:					SHOWDATA( "current stage: %s\n", GETSTAGE( r->stage ) );
vendor/nw.c:836:					if ( NW_CALL( r->stage == NW_COMPLETED ) ) {
vendor/nw.c:838:						close(r->client->fd);
vendor/nw.c:839:						r->client->fd = -1;
vendor/nw.c:844:						if ( NW_CALL( (r->send_retry += 1) < s->send_retry ) ) {
vendor/nw.c:845:							r->client->events = POLLWRNORM;
vendor/nw.c:857:				r->stage = NW_COMPLETED;
vendor/nw.c:858:				close(r->client->fd);
vendor/nw.c:859:				r->client->fd = -1;
vendor/nw.c:866:			if (NW_CALL( r->client->revents & POLLERR ))
vendor/nw.h:125:	r->client->events = POLLRDNORM
vendor/nw.h:129:	r->client->events = POLLWRNORM
vendor/nw.h:133:	memset(r, 0, sizeof(Recvr)); close((&r->client)->fd); (&r->client)->fd = -1
vendor/nw.h:137:	r->client->fd
vendor/single.h:426:		(snprintf( r->errbuf, 4095, __VA_ARGS__ ) && print_uerr ( r->errbuf )) ? 1 : 1
vendor/single.h:440:	raw = realloc( r->markers, ++follow * sizeof(Mark)); \
vendor/single.h:445:		r->markers = raw; \
vendor/single.h:446:		memset( &r->markers[ (follow - 1)], 0, sizeof(Mark) ); \
vendor/single.h:447:		ct = &r->markers[ (follow - 1) ]; \
vendor/single.h:623: 	r->client->events = POLLRDNORM
vendor/single.h:627: 	r->client->events = POLLWRNORM
vendor/single.h:631: 	memset(r, 0, sizeof(Recvr)); close((&r->client)->fd); (&r->client)->fd = -1
vendor/single.h:635: 	r->client->fd
vendor/single.h:671: 	if (NW_CALL( ( r->status = (&s->runners[CODE])->exe(r, s->global_ud, (&s->runners[CODE])->err) ) )) { \
vendor/single.c:956:  {        "rar", "application/x-rar-compressed"                                                   },
vendor/single.c:1099:	Mark *ct = &r->markers[0];
vendor/single.c:1119:	r->depth = 0;
vendor/single.c:1120:	r->maxbuf = 2048;
vendor/single.c:1121:	r->srctable = t;
vendor/single.c:1122:	memset( r->buf, 0, RENDER_MAX_BUF_SIZE );
vendor/single.c:1123:	return ( !bf_init( &r->dest, NULL, 1 ) ) ? 0 : 1;
vendor/single.c:1131:	free( r->markers );
vendor/single.c:1132:	bf_free( &r->dest );
vendor/single.c:1140:	r->src = src;
vendor/single.c:1148:	r->srctable = t;
vendor/single.c:1163:	if ( !(r->markers = malloc( sizeof( Mark ) )) )
vendor/single.c:1167:		memset( r->markers, 0, sizeof(Mark) );
vendor/single.c:1168:		ct = r->markers;
vendor/single.c:1180:			REALLOC( raw, r->markers );
vendor/single.c:1191:			REALLOC( raw, r->markers );
vendor/single.c:1200:			REALLOC( raw, r->markers );
vendor/single.c:1209:			REALLOC( raw, r->markers );
vendor/single.c:1218:			REALLOC( raw, r->markers );
vendor/single.c:1231:			fprintf( stderr, "%d\n", lt_get_long_i( r->srctable, ct->blob, ct->size ) );	
vendor/single.c:1236:				ct->index = lt_get_long_i( r->srctable, ct->blob, ct->size );
vendor/single.c:1237:				ct->type  = lt_vta( r->srctable, ct->index );
vendor/single.c:1244:			REALLOC( raw, r->markers );
vendor/single.c:1283:	Mark *lt=NULL, *ct = &r->markers[0];
vendor/single.c:1331:			bf_append( &r->dest, ct->blob, ct->size );
vendor/single.c:1339:				write( 2, lt_blobdata_at( r->srctable, ct->index ), lt_blobsize_at( r->srctable, ct->index ));
vendor/single.c:1341:				fprintf( stderr, "%d", lt_int_at( r->srctable, ct->index )); 
vendor/single.c:1343:				fprintf( stderr, "%f", lt_float_at( r->srctable, ct->index )); 
vendor/single.c:1345:				fprintf( stderr, "%p", lt_userdata_at( r->srctable, ct->index )); 
vendor/single.c:1347:				fprintf( stderr, "%p", (void *)&lt_table_at( r->srctable, ct->index )); 
vendor/single.c:1349:				fprintf( stderr, "%s\n", lt_text_at( r->srctable, ct->index ) );
vendor/single.c:1355:				uint8_t *b = lt_blobdata_at( r->srctable, ct->index );
vendor/single.c:1356:				bf_append( &r->dest, b, lt_blobsize_at( r->srctable, ct->index ));
vendor/single.c:1361:					snprintf( a = b, 63, "%d", lt_int_at( r->srctable, ct->index )); 
vendor/single.c:1363:					snprintf( a = b, 127, "%f", lt_float_at( r->srctable, ct->index )); 
vendor/single.c:1365:					snprintf( a = b, 127, "%p", lt_userdata_at( r->srctable, ct->index )); 
vendor/single.c:1367:					snprintf( a = b, 127, "%p", (void *)&lt_table_at( r->srctable, ct->index )); 
vendor/single.c:1369:					a = lt_text_at( r->srctable, ct->index );
vendor/single.c:1373:				bf_append( &r->dest, (uint8_t *)a, strlen( a ) );
vendor/single.c:1399:			if ( (i = lt_get_long_i( r->srctable, search, p )) == -1 )
vendor/single.c:1407:				LiteType t = lt_vta( r->srctable, i );
vendor/single.c:1411:					p = snprintf( (char *)( src = search ), sizeof(search), "%p", lt_userdata_at( r->srctable, i ));
vendor/single.c:1413:					p = snprintf( (char *)( src = search ), sizeof(search), "%0.2f", lt_float_at( r->srctable, i ));
vendor/single.c:1415:					p = snprintf( (char *)( src = search ), sizeof(search), "%d", lt_int_at( r->srctable, i ));
vendor/single.c:1417:					p = snprintf( (char *)( src = search ), sizeof(search), "%p", &lt_table_at( r->srctable, i ));
vendor/single.c:1419:					p = strlen( lt_text_at(r->srctable, i) ), src = (uint8_t *)lt_text_at( r->srctable, i );
vendor/single.c:1421:					p = lt_blobsize_at( r->srctable, i), src = lt_blobdata_at( r->srctable, i ); 
vendor/single.c:1426:				bf_append( &r->dest, src, p ); 
vendor/single.c:1449:						if ( (dt->times = lt_counti( r->srctable, ct->index )) > 0 )
vendor/single.c:1458:						lt_dump( r->srctable );
vendor/single.c:1477:	return &r->dest;
vendor/single.c:1731:		r->vint = vi;
vendor/single.c:1732:		SHOWDATA( "Adding int %s %d to table at %p", ( !side ) ? "key" : "value", r->vint, ( void * )t );
vendor/single.c:1736:		r->vfloat = vf;
vendor/single.c:1737:		SHOWDATA( "Adding float %s %f to table at %p", ( !side ) ? "key" : "value", r->vfloat, ( void * )t );
vendor/single.c:1742:		r->vnull = NULL;
vendor/single.c:1748:		r->vusrdata = vn;
vendor/single.c:1749:		SHOWDATA( "Adding userdata %p to table at %p", ( void * )r->vusrdata, ( void * )t );
vendor/single.c:1758:		r->vblob.blob = vb, r->vblob.size = vblen;
vendor/single.c:1759:		SHOWDATA( "Adding blob %s of length %d to table at %p", (!side) ? "key" : "value", r->vblob.size, ( void * )t );
vendor/single.c:1765:		r->vchar = malloc( vblen + 1 );
vendor/single.c:1766:		if ( !r->vchar )
vendor/single.c:1770:			memset( r->vchar, 0, vblen + 1 );
vendor/single.c:1771:			memcpy( r->vchar, vb, vblen );
vendor/single.c:1772:			r->vchar[ vblen ] = '\0';
vendor/single.c:1773:			SHOWDATA( "Adding text %s '%s' to table at %p", ( !side ) ? "key" : "value", r->vchar, ( void * )t );
vendor/single.c:1828:	LiteValue *value = &curr->value;
vendor/single.c:1852:		LiteValue *key = &curr->key; 
vendor/single.c:1861:			r->vptr = (long)t->current->ptr;
vendor/single.c:1866:			r->vptr = (long)t->current->ptr;
vendor/single.c:2129:	if ( curr->key.type == LITE_TRM && curr->key.v.vptr == t->cptr ) 
vendor/single.c:2171:	if ( curr->key.type == LITE_TRM && curr->key.v.vptr == t->cptr ) 
vendor/single.c:2420:				w += snprintf( &b[w], lt_buflen - w, "userdata [address: %p]", r->vusrdata );
vendor/single.c:2423:				LiteTable *rt = &r->vtable;
vendor/single.c:2429:			w += snprintf( &b[w], lt_buflen - w, "%d", r->vint );
vendor/single.c:2431:			w += snprintf( &b[w], lt_buflen - w, "%f", r->vfloat );
vendor/single.c:2433:			w += snprintf( &b[w], lt_buflen - w, "%s", r->vchar );
vendor/single.c:2435:			w += snprintf( &b[w], lt_buflen - w, "%ld", r->vptr );
vendor/single.c:2438:			LiteBlob *bb = &r->vblob;
vendor/single.c:4288:		VPRINT( "r->ai_addrlen = %d\n", r->ai_addrlen );
vendor/single.c:4289:		VPRINT( "ai_canonname  = %s\n", r->ai_canonname);
vendor/single.c:4292:		if ((self->fd = socket( r->ai_family, r->ai_socktype, r->ai_protocol )) == -1)
vendor/single.c:4299:		if (connect( self->fd, r->ai_addr, r->ai_addrlen) != -1) {
vendor/sqlite3.h:423:/* beginning-of-error-codes */
vendor/sqlite3.h:454:/* end-of-error-codes */
vendor/sqlite3.h:850:** string containing the transactions master-journal file name. VFSes that 
vendor/sqlite3.h:930:** upper-most shim only.
vendor/sqlite3.h:2788:** user-entered SQL is being [sqlite3_prepare | prepared] that
vendor/sqlite3.h:2853:** is the name of the inner-most trigger or view that is responsible for
vendor/sqlite3.h:2936:** to [sqlite3_trace_v2()] is an OR-ed combination of one or more of
vendor/sqlite3.h:2995:** M argument should be the bitwise OR-ed combination of
vendor/sqlite3.h:4450:** <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXT
vendor/sqlite3.h:4719:#define SQLITE_UTF8           1    /* IMP: R-37514-35566 */
vendor/sqlite3.h:4720:#define SQLITE_UTF16LE        2    /* IMP: R-03371-37637 */
vendor/sqlite3.h:4721:#define SQLITE_UTF16BE        3    /* IMP: R-51971-34154 */
vendor/sqlite3.h:4962:** of where this might be useful is in a regular-expression matching
vendor/sqlite3.h:5460:** &nbsp;     TemporaryFolder->Path->Data();
vendor/sqlite3.h:5719:** shared cache mode should be enabled per-database connection via 
vendor/sqlite3.h:5923:** X is consists of the lower-case equivalent of all ASCII alphabetic
vendor/sqlite3.h:5962:** [extension loading] while evaluating user-entered SQL, the following API
vendor/sqlite3.h:6567:** caller-supplied buffer. N bytes of data are copied into buffer Z
vendor/sqlite3.h:6596:** caller-supplied buffer. N bytes of data are copied from the buffer Z
vendor/sqlite3.h:6885:** the routine should return 1.   This seems counter-intuitive since
vendor/sqlite3.h:8405:** pages in the pager-cache that are not currently in use are written out 
vendor/sqlite3.h:8774:** R-Tree geometry query as follows:
vendor/sqlite3.h:8800:** used as part of an R-Tree geometry query as follows:
vendor/sqlite3.h:9125:** This may appear to have some counter-intuitive effects if a single row
tests/2016-general-election-summary.csv:75:9702,84,REP,LEG,35,Representative in the General Assembly 35TH DISTRICT,2,V. Fawn Walker-Montgomery,1,
vendor/sqlite3.c:957:** SQLITE_DISABLE_INTRINSIC macro means do not use any compiler-specific
vendor/sqlite3.c:1447:/* beginning-of-error-codes */
vendor/sqlite3.c:1478:/* end-of-error-codes */
vendor/sqlite3.c:1874:** string containing the transactions master-journal file name. VFSes that 
vendor/sqlite3.c:1954:** upper-most shim only.
vendor/sqlite3.c:3812:** user-entered SQL is being [sqlite3_prepare | prepared] that
vendor/sqlite3.c:3877:** is the name of the inner-most trigger or view that is responsible for
vendor/sqlite3.c:3960:** to [sqlite3_trace_v2()] is an OR-ed combination of one or more of
vendor/sqlite3.c:4019:** M argument should be the bitwise OR-ed combination of
vendor/sqlite3.c:5474:** <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXT
vendor/sqlite3.c:5743:#define SQLITE_UTF8           1    /* IMP: R-37514-35566 */
vendor/sqlite3.c:5744:#define SQLITE_UTF16LE        2    /* IMP: R-03371-37637 */
vendor/sqlite3.c:5745:#define SQLITE_UTF16BE        3    /* IMP: R-51971-34154 */
vendor/sqlite3.c:5986:** of where this might be useful is in a regular-expression matching
vendor/sqlite3.c:6484:** &nbsp;     TemporaryFolder->Path->Data();
vendor/sqlite3.c:6743:** shared cache mode should be enabled per-database connection via 
vendor/sqlite3.c:6947:** X is consists of the lower-case equivalent of all ASCII alphabetic
vendor/sqlite3.c:6986:** [extension loading] while evaluating user-entered SQL, the following API
vendor/sqlite3.c:7591:** caller-supplied buffer. N bytes of data are copied into buffer Z
vendor/sqlite3.c:7620:** caller-supplied buffer. N bytes of data are copied from the buffer Z
vendor/sqlite3.c:7909:** the routine should return 1.   This seems counter-intuitive since
vendor/sqlite3.c:9429:** pages in the pager-cache that are not currently in use are written out 
vendor/sqlite3.c:9798:** R-Tree geometry query as follows:
vendor/sqlite3.c:9824:** used as part of an R-Tree geometry query as follows:
vendor/sqlite3.c:10149:** This may appear to have some counter-intuitive effects if a single row
vendor/sqlite3.c:11870:** IMPLEMENTATION-OF: R-30185-15359 The default suggested cache size is -2000,
vendor/sqlite3.c:11872:** IMPLEMENTATION-OF: R-48205-43578 The default suggested cache size can be
vendor/sqlite3.c:11936:** device characteristics (sector-size and atomic write() support),
vendor/sqlite3.c:12082:#   define SQLITE_THREADSAFE 1 /* IMP: R-07272-22309 */
vendor/sqlite3.c:12095:** EVIDENCE-OF: R-25715-37072 Memory allocation statistics are enabled by
vendor/sqlite3.c:13326:** the database file header. The incr-vacuum-flag field is located at
vendor/sqlite3.c:14462:/* Change a page number.  Used by incr-vacuum. */
vendor/sqlite3.c:14504:/* Set and get the suggested cache-size for the specified pager-cache.
vendor/sqlite3.c:14507:** the total number of pages cached by purgeable pager-caches to the sum
vendor/sqlite3.c:14515:/* Set or get the suggested spill-size for the specified pager-cache.
vendor/sqlite3.c:15340:** For per-connection application-defined functions, a pointer to this
vendor/sqlite3.c:15344:** field is used by per-connection app-def functions.
vendor/sqlite3.c:15361:** This structure encapsulates a user-function destructor callback (as
vendor/sqlite3.c:15417:**     as the user-data (sqlite3_user_data()) for the function. If
vendor/sqlite3.c:15427:**     a single query.  The iArg is ignored.  The user-data is always set
vendor/sqlite3.c:15433:**     ignored and the user-data for these functions is set to an 
vendor/sqlite3.c:15446:**     available as the function user-data (sqlite3_user_data()). The
vendor/sqlite3.c:15704:#define TF_NoVisibleRowid  0x0040    /* No user-visible "rowid" column */
vendor/sqlite3.c:15778:  /* EV: R-30323-21917 */
vendor/sqlite3.c:16074:** to represent the greater-than-or-equal-to operator in the expression
vendor/sqlite3.c:16449:** NameContexts can be nested.  When resolving names, the inner-most
vendor/sqlite3.c:16660:** the code generator needs.  We have to keep per-table autoincrement
vendor/sqlite3.c:16945: * that is a part of a trigger-program.
vendor/sqlite3.c:16950: * the first step of the trigger-program.
vendor/sqlite3.c:18214:/* An array to map all upper-case characters into their corresponding
vendor/sqlite3.c:18215:** lower-case character. 
vendor/sqlite3.c:18273:** case. i.e. if the character is a lower-case ASCII character.
vendor/sqlite3.c:18274:** If x is a lower-case ASCII character, then its upper-case equivalent
vendor/sqlite3.c:18327:/* EVIDENCE-OF: R-02982-34736 In order to maintain full backwards
vendor/sqlite3.c:18331:** EVIDENCE-OF: R-38799-08373 URI filenames can be enabled or disabled
vendor/sqlite3.c:18334:** EVIDENCE-OF: R-43642-56306 By default, URI handling is globally
vendor/sqlite3.c:18349:/* EVIDENCE-OF: R-38720-18127 The default setting is determined by the
vendor/sqlite3.c:19386:      *pHighwater = 0;  /* IMP: R-64479-57858 */
vendor/sqlite3.c:19411:      *pHighwater = 0; /* IMP: R-42420-56072 */
vendor/sqlite3.c:19412:                       /* IMP: R-54100-20147 */
vendor/sqlite3.c:19413:                       /* IMP: R-29431-39229 */
vendor/sqlite3.c:19423:      *pHighwater = 0;  /* IMP: R-11967-56545 */
vendor/sqlite3.c:19526:** of a four-character format specifiers ABCD is:
vendor/sqlite3.c:19946:** EVIDENCE-OF: R-62172-00036 In this implementation, the standard C
vendor/sqlite3.c:20004:    /* EVIDENCE-OF: R-55269-29598 The localtime_r() C function normally only
vendor/sqlite3.c:20628:** as the user-data for the function.
vendor/sqlite3.c:20957:  /* IMPLEMENTATION-OF: R-49045-42493 SQLite will use the xCurrentTimeInt64()
vendor/sqlite3.c:21421:** by higher-level routines.
vendor/sqlite3.c:21456:** pPrior==0 while have been intercepted by higher-level routine and
vendor/sqlite3.c:21458:** cases where nByte<=0 will have been intercepted by higher-level
vendor/sqlite3.c:21474:  assert( nByte==ROUND8(nByte) ); /* EV: R-46199-30249 */
vendor/sqlite3.c:21737:  return (int)pHdr->iSize;
vendor/sqlite3.c:21815:    pHdr->pNext = 0;
vendor/sqlite3.c:21816:    pHdr->pPrev = mem.pLast;
vendor/sqlite3.c:21823:    pHdr->iForeGuard = FOREGUARD;
vendor/sqlite3.c:21824:    pHdr->eType = MEMTYPE_HEAP;
vendor/sqlite3.c:21825:    pHdr->nBacktraceSlots = mem.nBacktrace;
vendor/sqlite3.c:21826:    pHdr->nTitle = mem.nTitle;
vendor/sqlite3.c:21829:      pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace+1)-1;
vendor/sqlite3.c:21830:      memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*));
vendor/sqlite3.c:21833:        mem.xBacktrace(nByte, pHdr->nBacktrace-1, &aAddr[1]);
vendor/sqlite3.c:21836:      pHdr->nBacktrace = 0;
vendor/sqlite3.c:21841:    pHdr->iSize = nByte;
vendor/sqlite3.c:21864:  pBt -= pHdr->nBacktraceSlots;
vendor/sqlite3.c:21866:  if( pHdr->pPrev ){
vendor/sqlite3.c:21867:    assert( pHdr->pPrev->pNext==pHdr );
vendor/sqlite3.c:21868:    pHdr->pPrev->pNext = pHdr->pNext;
vendor/sqlite3.c:21871:    mem.pFirst = pHdr->pNext;
vendor/sqlite3.c:21873:  if( pHdr->pNext ){
vendor/sqlite3.c:21874:    assert( pHdr->pNext->pPrev==pHdr );
vendor/sqlite3.c:21875:    pHdr->pNext->pPrev = pHdr->pPrev;
vendor/sqlite3.c:21878:    mem.pLast = pHdr->pPrev;
vendor/sqlite3.c:21881:  z -= pHdr->nTitle;
vendor/sqlite3.c:21882:  adjustStats((int)pHdr->iSize, -1);
vendor/sqlite3.c:21883:  randomFill(z, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) +
vendor/sqlite3.c:21884:                (int)pHdr->iSize + sizeof(int) + pHdr->nTitle);
vendor/sqlite3.c:21902:  assert( (nByte & 7)==0 );     /* EV: R-46199-30249 */
vendor/sqlite3.c:21906:    memcpy(pNew, pPrior, (int)(nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize));
vendor/sqlite3.c:21907:    if( nByte>pOldHdr->iSize ){
vendor/sqlite3.c:21908:      randomFill(&((char*)pNew)[pOldHdr->iSize], nByte - (int)pOldHdr->iSize);
vendor/sqlite3.c:21940:    assert( pHdr->iForeGuard==FOREGUARD );
vendor/sqlite3.c:21941:    pHdr->eType = eType;
vendor/sqlite3.c:21959:    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */
vendor/sqlite3.c:21960:    if( (pHdr->eType&eType)==0 ){
vendor/sqlite3.c:21981:    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */
vendor/sqlite3.c:21982:    if( (pHdr->eType&eType)!=0 ){
vendor/sqlite3.c:22020:  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){
vendor/sqlite3.c:22022:    pBt -= pHdr->nBacktraceSlots;
vendor/sqlite3.c:22023:    mem.xBacktrace((int)pHdr->iSize, pHdr->nBacktrace-1, &pBt[1]);
vendor/sqlite3.c:22042:  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){
vendor/sqlite3.c:22044:    z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle;
vendor/sqlite3.c:22046:            pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : "???");
vendor/sqlite3.c:22047:    if( pHdr->nBacktrace ){
vendor/sqlite3.c:22050:      pBt -= pHdr->nBacktraceSlots;
vendor/sqlite3.c:22051:      backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));
vendor/sqlite3.c:22359:  if( nBlock>=mem3.szMaster-1 ){
vendor/sqlite3.c:22371:    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = nBlock;
vendor/sqlite3.c:22372:    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x |= 2;
vendor/sqlite3.c:22376:    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;
vendor/sqlite3.c:22377:    mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;
vendor/sqlite3.c:22539:    while( (mem3.aPool[mem3.iMaster-1].u.hdr.size4x&2)==0 ){
vendor/sqlite3.c:22540:      size = mem3.aPool[mem3.iMaster-1].u.hdr.prevSize;
vendor/sqlite3.c:22544:      x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;
vendor/sqlite3.c:22545:      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;
vendor/sqlite3.c:22546:      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;
vendor/sqlite3.c:22548:    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;
vendor/sqlite3.c:22549:    while( (mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x&1)==0 ){
vendor/sqlite3.c:22551:      mem3.szMaster += mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x/4;
vendor/sqlite3.c:22552:      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;
vendor/sqlite3.c:22553:      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;
vendor/sqlite3.c:23171:  assert( (nBytes&(nBytes-1))==0 );  /* EV: R-46199-30249 */
vendor/sqlite3.c:24726:    OSTRACE(("ENTER-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\n",
vendor/sqlite3.c:24854:  /* IMPLEMENTATION-OF: R-34391-24921 The sqlite3_release_memory() routine
vendor/sqlite3.c:25072:  assert( EIGHT_BYTE_ALIGNMENT(p) );  /* IMP: R-11148-40995 */
vendor/sqlite3.c:25141:  if( p==0 ) return;  /* IMP: R-49053-54554 */
vendor/sqlite3.c:25207:    return sqlite3Malloc(nBytes); /* IMP: R-04300-56712 */
vendor/sqlite3.c:25210:    sqlite3_free(pOld); /* IMP: R-26507-47431 */
vendor/sqlite3.c:25218:  /* IMPLEMENTATION-OF: R-46199-30249 SQLite guarantees that the second
vendor/sqlite3.c:25245:  assert( EIGHT_BYTE_ALIGNMENT(pNew) ); /* IMP: R-11148-40995 */
vendor/sqlite3.c:25257:  if( n<0 ) n = 0;  /* IMP: R-26507-47431 */
vendor/sqlite3.c:25515:** If an OOM as occurred, then the connection error-code (the value
vendor/sqlite3.c:26391:    memcpy(&p->zText[p->nChar-N], z, N);
vendor/sqlite3.c:26714:  if( zBuf[acc.nChar-1]!='\n' ) sqlite3StrAccumAppend(&acc, "\n", 1);
vendor/sqlite3.c:26893:  if( pExpr->flags ){
vendor/sqlite3.c:26896:                       pExpr->flags, pExpr->iRightJoinTable);
vendor/sqlite3.c:26898:      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x",pExpr->flags);
vendor/sqlite3.c:26903:  switch( pExpr->op ){
vendor/sqlite3.c:26906:            pExpr->iTable, pExpr->iColumn, zFlgs);
vendor/sqlite3.c:26910:      if( pExpr->iTable<0 ){
vendor/sqlite3.c:26912:        sqlite3TreeViewLine(pView, "COLUMN(%d)%s", pExpr->iColumn, zFlgs);
vendor/sqlite3.c:26915:                             pExpr->iTable, pExpr->iColumn, zFlgs);
vendor/sqlite3.c:26920:      if( pExpr->flags & EP_IntValue ){
vendor/sqlite3.c:26921:        sqlite3TreeViewLine(pView, "%d", pExpr->u.iValue);
vendor/sqlite3.c:26923:        sqlite3TreeViewLine(pView, "%s", pExpr->u.zToken);
vendor/sqlite3.c:26929:      sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);
vendor/sqlite3.c:26934:      sqlite3TreeViewLine(pView,"%Q", pExpr->u.zToken);
vendor/sqlite3.c:26943:      sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);
vendor/sqlite3.c:26949:                          pExpr->u.zToken, pExpr->iColumn);
vendor/sqlite3.c:26953:      sqlite3TreeViewLine(pView,"REGISTER(%d)", pExpr->iTable);
vendor/sqlite3.c:26957:      sqlite3TreeViewLine(pView,"ID \"%w\"", pExpr->u.zToken);
vendor/sqlite3.c:26963:      sqlite3TreeViewLine(pView,"CAST %Q", pExpr->u.zToken);
vendor/sqlite3.c:26964:      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
vendor/sqlite3.c:26998:      sqlite3TreeViewLine(pView, "SPAN %Q", pExpr->u.zToken);
vendor/sqlite3.c:26999:      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
vendor/sqlite3.c:27004:      sqlite3TreeViewLine(pView, "COLLATE %Q", pExpr->u.zToken);
vendor/sqlite3.c:27005:      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
vendor/sqlite3.c:27015:        pFarg = pExpr->x.pList;
vendor/sqlite3.c:27017:      if( pExpr->op==TK_AGG_FUNCTION ){
vendor/sqlite3.c:27019:                             pExpr->op2, pExpr->u.zToken);
vendor/sqlite3.c:27021:        sqlite3TreeViewLine(pView, "FUNCTION %Q", pExpr->u.zToken);
vendor/sqlite3.c:27030:      sqlite3TreeViewLine(pView, "EXISTS-expr flags=0x%x", pExpr->flags);
vendor/sqlite3.c:27031:      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
vendor/sqlite3.c:27035:      sqlite3TreeViewLine(pView, "SELECT-expr flags=0x%x", pExpr->flags);
vendor/sqlite3.c:27036:      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
vendor/sqlite3.c:27040:      sqlite3TreeViewLine(pView, "IN flags=0x%x", pExpr->flags);
vendor/sqlite3.c:27041:      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
vendor/sqlite3.c:27043:        sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);
vendor/sqlite3.c:27045:        sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);
vendor/sqlite3.c:27058:    ** X is stored in pExpr->pLeft.
vendor/sqlite3.c:27059:    ** Y is stored in pExpr->pList->a[0].pExpr.
vendor/sqlite3.c:27060:    ** Z is stored in pExpr->pList->a[1].pExpr.
vendor/sqlite3.c:27063:      Expr *pX = pExpr->pLeft;
vendor/sqlite3.c:27064:      Expr *pY = pExpr->x.pList->a[0].pExpr;
vendor/sqlite3.c:27065:      Expr *pZ = pExpr->x.pList->a[1].pExpr;
vendor/sqlite3.c:27081:          pExpr->iTable ? "NEW" : "OLD", pExpr->iColumn);
vendor/sqlite3.c:27086:      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
vendor/sqlite3.c:27087:      sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);
vendor/sqlite3.c:27093:      switch( pExpr->affinity ){
vendor/sqlite3.c:27099:      sqlite3TreeViewLine(pView, "RAISE %s(%Q)", zType, pExpr->u.zToken);
vendor/sqlite3.c:27105:                          pExpr->iTable, pExpr->iColumn, zFlgs);
vendor/sqlite3.c:27106:      sqlite3TreeViewExpr(pView, pExpr->pRight, 0);
vendor/sqlite3.c:27110:      sqlite3TreeViewBareExprList(pView, pExpr->x.pList, "VECTOR");
vendor/sqlite3.c:27114:      sqlite3TreeViewLine(pView, "SELECT-COLUMN %d", pExpr->iColumn);
vendor/sqlite3.c:27115:      sqlite3TreeViewSelect(pView, pExpr->pLeft->x.pSelect, 0);
vendor/sqlite3.c:27119:      sqlite3TreeViewLine(pView, "IF-NULL-ROW %d", pExpr->iTable);
vendor/sqlite3.c:27120:      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
vendor/sqlite3.c:27124:      sqlite3TreeViewLine(pView, "op=%d", pExpr->op);
vendor/sqlite3.c:27130:    sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
vendor/sqlite3.c:27131:    sqlite3TreeViewExpr(pView, pExpr->pRight, 0);
vendor/sqlite3.c:27134:    sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
vendor/sqlite3.c:27160:      sqlite3TreeViewExpr(pView, pList->a[i].pExpr, i<pList->nExpr-1);
vendor/sqlite3.c:27744:**  *  This routine accepts over-length UTF8 encodings
vendor/sqlite3.c:27745:**     for unicode values 0x80 and greater.  It does not change over-length
vendor/sqlite3.c:28411:** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
vendor/sqlite3.c:29271:** Read or write a four-byte big-endian integer value.
vendor/sqlite3.c:30211:**   *  Locking primitives for the proxy uber-locking-method. (MacOSX only)
vendor/sqlite3.c:30728:** Many system calls are accessed through pointer-to-functions so that
vendor/sqlite3.c:31006:** In that way, if a database file is -rw-rw-rw or -rw-rw-r-, and a
vendor/sqlite3.c:31820:  OSTRACE(("TEST WR-LOCK %d %d %d (unix)\n", pFile->h, rc, reserved));
vendor/sqlite3.c:32478:  OSTRACE(("TEST WR-LOCK %d %d %d (dotlock)\n", pFile->h, rc, reserved));
vendor/sqlite3.c:32688:  OSTRACE(("TEST WR-LOCK %d %d %d (flock)\n", pFile->h, rc, reserved));
vendor/sqlite3.c:32868:  OSTRACE(("TEST WR-LOCK %d %d %d (sem)\n", pFile->h, rc, reserved));
vendor/sqlite3.c:33118:  OSTRACE(("TEST WR-LOCK %d %d %d (afp)\n", pFile->h, rc, reserved));
vendor/sqlite3.c:33572:  /* If this is a database file (not a journal, master-journal or temp
vendor/sqlite3.c:33685:  /* If this is a database file (not a journal, master-journal or temp
vendor/sqlite3.c:34402:** words, after a power-loss event, parts of the file that were never
vendor/sqlite3.c:35074:  sqlite3MemoryBarrier();         /* compiler-defined memory barrier */
vendor/sqlite3.c:35364:** of "finder" functions.  A finder-function is used to locate the appropriate
vendor/sqlite3.c:35367:** the correct finder-function for that VFS.
vendor/sqlite3.c:35370:** object.  The only interesting finder-function is autolockIoFinder, which
vendor/sqlite3.c:35374:** For finder-function F, two objects are created:
vendor/sqlite3.c:35376:**    (1) The real finder-function named "FImpt()".
vendor/sqlite3.c:35383:** directly at the finder-function since C90 rules prevent a void*
vendor/sqlite3.c:35500:** The proxy locking method is a "super-method" in the sense that it
vendor/sqlite3.c:35903:** file (not a journal or master-journal file) identified by pathname
vendor/sqlite3.c:36747:** Proxy locking is a "uber-locking-method" in this sense:  It uses the
vendor/sqlite3.c:37947:  ** finder-function.  The finder-function returns a pointer to the
vendor/sqlite3.c:37950:  ** macro for addition information on finder-functions.
vendor/sqlite3.c:38382:** 4-bytes-per-character for UTF8.
vendor/sqlite3.c:38758:** Many system calls are accessed through pointer-to-functions so that
vendor/sqlite3.c:41577:  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p\n", pFile->h, pResOut));
vendor/sqlite3.c:41582:    OSTRACE(("TEST-WR-LOCK file=%p, result=%d (local)\n", pFile->h, res));
vendor/sqlite3.c:41589:    OSTRACE(("TEST-WR-LOCK file=%p, result=%d (remote)\n", pFile->h, res));
vendor/sqlite3.c:41592:  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",
vendor/sqlite3.c:42338:  sqlite3MemoryBarrier();   /* compiler-defined memory barrier */
vendor/sqlite3.c:43641:** use the provided path name verbatim -OR- resolve it into a full path name
vendor/sqlite3.c:44770:       pPg = (PgHdr*)pLower->pExtra;
vendor/sqlite3.c:44772:       a = (unsigned char *)pLower->pBuf;
vendor/sqlite3.c:44929:    /* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then the
vendor/sqlite3.c:44933:    /* IMPLEMENTATION-OF: R-61436-13639 If the argument N is negative, then
vendor/sqlite3.c:44947:    /* IMPLEMENTATION-OF: R-26801-64137 If the xInit() method is NULL, then the
vendor/sqlite3.c:44956:    /* IMPLEMENTATION-OF: R-26000-56589 The xShutdown() method may be NULL. */
vendor/sqlite3.c:45153:  assert( pPgHdr->pPage==0 );
vendor/sqlite3.c:45154:  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));
vendor/sqlite3.c:45155:  pPgHdr->pPage = pPage;
vendor/sqlite3.c:45156:  pPgHdr->pData = pPage->pBuf;
vendor/sqlite3.c:45157:  pPgHdr->pExtra = (void *)&pPgHdr[1];
vendor/sqlite3.c:45158:  memset(pPgHdr->pExtra, 0, 8);
vendor/sqlite3.c:45159:  pPgHdr->pCache = pCache;
vendor/sqlite3.c:45160:  pPgHdr->pgno = pgno;
vendor/sqlite3.c:45161:  pPgHdr->flags = PGHDR_CLEAN;
vendor/sqlite3.c:45181:  if( !pPgHdr->pPage ){
vendor/sqlite3.c:45185:  pPgHdr->nRef++;
vendor/sqlite3.c:45285:  pcacheTrace(("%p.CLEAR-WRITEABLE\n",pCache));
vendor/sqlite3.c:46451:    if( pOther->szAlloc != pCache->szAlloc ){
vendor/sqlite3.c:46455:      pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);
vendor/sqlite3.c:47618:**               +---------> READER-------+      |
vendor/sqlite3.c:47662:**    was) in exclusive-locking mode, a user-level read transaction is 
vendor/sqlite3.c:47675:**    * The dbSize variable may be trusted (even if a user-level read 
vendor/sqlite3.c:47984:**   (or may not) specify a master-journal name to be written into the 
vendor/sqlite3.c:47987:**   Whether or not a journal file contains a master-journal pointer affects 
vendor/sqlite3.c:47990:**   If a journal file does not contain a master-journal pointer, it is
vendor/sqlite3.c:47992:**   it does contain a master-journal pointer the journal file is finalized 
vendor/sqlite3.c:48022:**   This flag is set by sqlite3PagerWrite() when the file-system sector-size
vendor/sqlite3.c:48237:** the page number and the pPager->pageSize bytes of data for the page.
vendor/sqlite3.c:48254:#define JOURNAL_PG_SZ(pPager)  ((pPager->pageSize) + 8)
vendor/sqlite3.c:48260:#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)
vendor/sqlite3.c:48271:# define MEMDB pPager->memDb
vendor/sqlite3.c:48295:**   if( isOpen(pPager->jfd) ){ ...
vendor/sqlite3.c:48299:**   if( pPager->jfd->pMethods ){ ...
vendor/sqlite3.c:48311:  if( pPager->pWal==0 ) return 0;
vendor/sqlite3.c:48312:  rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);
vendor/sqlite3.c:48353:  assert( p->tempFile==0 || pPager->changeCountDone );
vendor/sqlite3.c:48382:  assert( pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK );
vendor/sqlite3.c:48388:      assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:48389:      assert( sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile );
vendor/sqlite3.c:48393:      assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:48400:      assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:48404:      assert( pPager->dbSize==pPager->dbOrigSize );
vendor/sqlite3.c:48405:      assert( pPager->dbOrigSize==pPager->dbFileSize );
vendor/sqlite3.c:48406:      assert( pPager->dbOrigSize==pPager->dbHintSize );
vendor/sqlite3.c:48407:      assert( pPager->setMaster==0 );
vendor/sqlite3.c:48412:      assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:48425:      assert( pPager->dbOrigSize==pPager->dbFileSize );
vendor/sqlite3.c:48426:      assert( pPager->dbOrigSize==pPager->dbHintSize );
vendor/sqlite3.c:48431:      assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:48439:      assert( pPager->dbOrigSize<=pPager->dbHintSize );
vendor/sqlite3.c:48444:      assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:48458:      assert( pPager->errCode!=SQLITE_OK );
vendor/sqlite3.c:48459:      assert( sqlite3PcacheRefCount(pPager->pPCache)>0 || pPager->tempFile );
vendor/sqlite3.c:48530:  if( pPager->errCode ){
vendor/sqlite3.c:48531:    pPager->xGet = getPageError;
vendor/sqlite3.c:48535:   && pPager->xCodec==0
vendor/sqlite3.c:48538:    pPager->xGet = getPageMMap;
vendor/sqlite3.c:48541:    pPager->xGet = getPageNormal;
vendor/sqlite3.c:48559:  for(i=0; i<pPager->nSavepoint; i++){
vendor/sqlite3.c:48560:    p = &pPager->aSavepoint[i];
vendor/sqlite3.c:48573:  return sqlite3BitvecTest(pPager->pInJournal, pPg->pgno);
vendor/sqlite3.c:48621:  assert( !pPager->exclusiveMode || pPager->eLock==eLock );
vendor/sqlite3.c:48624:  if( isOpen(pPager->fd) ){
vendor/sqlite3.c:48625:    assert( pPager->eLock>=eLock );
vendor/sqlite3.c:48626:    rc = pPager->noLock ? SQLITE_OK : sqlite3OsUnlock(pPager->fd, eLock);
vendor/sqlite3.c:48627:    if( pPager->eLock!=UNKNOWN_LOCK ){
vendor/sqlite3.c:48628:      pPager->eLock = (u8)eLock;
vendor/sqlite3.c:48649:  if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){
vendor/sqlite3.c:48650:    rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);
vendor/sqlite3.c:48651:    if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){
vendor/sqlite3.c:48652:      pPager->eLock = (u8)eLock;
vendor/sqlite3.c:48685:  assert( isOpen(pPager->fd) );
vendor/sqlite3.c:48686:  dc = sqlite3OsDeviceCharacteristics(pPager->fd);
vendor/sqlite3.c:48697:    int nSector = pPager->sectorSize;
vendor/sqlite3.c:48698:    int szPage = pPager->pageSize;
vendor/sqlite3.c:48731:  return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData);
vendor/sqlite3.c:48745:  assert( pPager->eState!=PAGER_ERROR );
vendor/sqlite3.c:48812:    ** master-journal filename.
vendor/sqlite3.c:48823:** following the value in pPager->journalOff, assuming a sector 
vendor/sqlite3.c:48824:** size of pPager->sectorSize bytes.
vendor/sqlite3.c:48838:  i64 c = pPager->journalOff;
vendor/sqlite3.c:48871:  assert( isOpen(pPager->jfd) );
vendor/sqlite3.c:48872:  assert( !sqlite3JournalIsInMemory(pPager->jfd) );
vendor/sqlite3.c:48873:  if( pPager->journalOff ){
vendor/sqlite3.c:48874:    const i64 iLimit = pPager->journalSizeLimit;    /* Local cache of jsl */
vendor/sqlite3.c:48878:      rc = sqlite3OsTruncate(pPager->jfd, 0);
vendor/sqlite3.c:48881:      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);
vendor/sqlite3.c:48883:    if( rc==SQLITE_OK && !pPager->noSync ){
vendor/sqlite3.c:48884:      rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->syncFlags);
vendor/sqlite3.c:48895:      rc = sqlite3OsFileSize(pPager->jfd, &sz);
vendor/sqlite3.c:48897:        rc = sqlite3OsTruncate(pPager->jfd, iLimit);
vendor/sqlite3.c:48921:  char *zHeader = pPager->pTmpSpace;  /* Temporary space used to build header */
vendor/sqlite3.c:48922:  u32 nHeader = (u32)pPager->pageSize;/* Size of buffer pointed to by zHeader */
vendor/sqlite3.c:48926:  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */
vendor/sqlite3.c:48936:  for(ii=0; ii<pPager->nSavepoint; ii++){
vendor/sqlite3.c:48937:    if( pPager->aSavepoint[ii].iHdrOffset==0 ){
vendor/sqlite3.c:48938:      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;
vendor/sqlite3.c:48942:  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);
vendor/sqlite3.c:48964:  assert( isOpen(pPager->fd) || pPager->noSync );
vendor/sqlite3.c:48965:  if( pPager->noSync || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY)
vendor/sqlite3.c:48966:   || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND) 
vendor/sqlite3.c:48975:  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);
vendor/sqlite3.c:48976:  put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);
vendor/sqlite3.c:48978:  put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbOrigSize);
vendor/sqlite3.c:48980:  put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize);
vendor/sqlite3.c:48983:  put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize);
vendor/sqlite3.c:48991:         nHeader-(sizeof(aJournalMagic)+20));
vendor/sqlite3.c:49005:  ** The loop is required here in case the sector-size is larger than the 
vendor/sqlite3.c:49011:    IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader))
vendor/sqlite3.c:49012:    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);
vendor/sqlite3.c:49013:    assert( pPager->journalHdr <= pPager->journalOff );
vendor/sqlite3.c:49014:    pPager->journalOff += nHeader;
vendor/sqlite3.c:49024:** pPager->journalOff. See comments above function writeJournalHdr() for
vendor/sqlite3.c:49029:** database before the transaction began, in pages. Also, pPager->cksumInit
vendor/sqlite3.c:49048:  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */
vendor/sqlite3.c:49054:  pPager->journalOff = journalHdrOffset(pPager);
vendor/sqlite3.c:49055:  if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){
vendor/sqlite3.c:49058:  iHdrOff = pPager->journalOff;
vendor/sqlite3.c:49065:  if( isHot || iHdrOff!=pPager->journalHdr ){
vendor/sqlite3.c:49066:    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);
vendor/sqlite3.c:49079:  if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))
vendor/sqlite3.c:49080:   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))
vendor/sqlite3.c:49081:   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))
vendor/sqlite3.c:49086:  if( pPager->journalOff==0 ){
vendor/sqlite3.c:49088:    u32 iSectorSize;             /* Sector-size field of journal header */
vendor/sqlite3.c:49090:    /* Read the page-size and sector-size journal header fields. */
vendor/sqlite3.c:49091:    if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))
vendor/sqlite3.c:49092:     || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))
vendor/sqlite3.c:49102:      iPageSize = pPager->pageSize;
vendor/sqlite3.c:49105:    /* Check that the values read from the page-size and sector-size fields
vendor/sqlite3.c:49114:      /* If the either the page-size or sector-size in the journal-header is 
vendor/sqlite3.c:49129:    /* Update the assumed sector-size to match the value used by 
vendor/sqlite3.c:49135:    pPager->sectorSize = iSectorSize;
vendor/sqlite3.c:49138:  pPager->journalOff += JOURNAL_HDR_SZ(pPager);
vendor/sqlite3.c:49169:  assert( pPager->setMaster==0 );
vendor/sqlite3.c:49173:   || pPager->journalMode==PAGER_JOURNALMODE_MEMORY 
vendor/sqlite3.c:49174:   || !isOpen(pPager->jfd)
vendor/sqlite3.c:49178:  pPager->setMaster = 1;
vendor/sqlite3.c:49179:  assert( pPager->journalHdr <= pPager->journalOff );
vendor/sqlite3.c:49190:  if( pPager->fullSync ){
vendor/sqlite3.c:49191:    pPager->journalOff = journalHdrOffset(pPager);
vendor/sqlite3.c:49193:  iHdrOff = pPager->journalOff;
vendor/sqlite3.c:49198:  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_MJ_PGNO(pPager))))
vendor/sqlite3.c:49199:   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff+4)))
vendor/sqlite3.c:49200:   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster, nMaster)))
vendor/sqlite3.c:49201:   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster+4, cksum)))
vendor/sqlite3.c:49202:   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,
vendor/sqlite3.c:49207:  pPager->journalOff += (nMaster+20);
vendor/sqlite3.c:49210:  ** journal-file may extend past the end of the master-journal name
vendor/sqlite3.c:49213:  ** will not be able to find the master-journal name to determine 
vendor/sqlite3.c:49219:  if( SQLITE_OK==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))
vendor/sqlite3.c:49220:   && jrnlSize>pPager->journalOff
vendor/sqlite3.c:49222:    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);
vendor/sqlite3.c:49231:  pPager->iDataVersion++;
vendor/sqlite3.c:49232:  sqlite3BackupRestart(pPager->pBackup);
vendor/sqlite3.c:49233:  sqlite3PcacheClear(pPager->pPCache);
vendor/sqlite3.c:49237:** Return the pPager->iDataVersion value
vendor/sqlite3.c:49240:  assert( pPager->eState>PAGER_OPEN );
vendor/sqlite3.c:49241:  return pPager->iDataVersion;
vendor/sqlite3.c:49251:  for(ii=0; ii<pPager->nSavepoint; ii++){
vendor/sqlite3.c:49252:    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
vendor/sqlite3.c:49254:  if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){
vendor/sqlite3.c:49255:    sqlite3OsClose(pPager->sjfd);
vendor/sqlite3.c:49257:  sqlite3_free(pPager->aSavepoint);
vendor/sqlite3.c:49258:  pPager->aSavepoint = 0;
vendor/sqlite3.c:49259:  pPager->nSavepoint = 0;
vendor/sqlite3.c:49260:  pPager->nSubRec = 0;
vendor/sqlite3.c:49272:  for(ii=0; ii<pPager->nSavepoint; ii++){
vendor/sqlite3.c:49273:    PagerSavepoint *p = &pPager->aSavepoint[ii];
vendor/sqlite3.c:49302:  assert( pPager->eState==PAGER_READER 
vendor/sqlite3.c:49303:       || pPager->eState==PAGER_OPEN 
vendor/sqlite3.c:49304:       || pPager->eState==PAGER_ERROR 
vendor/sqlite3.c:49307:  sqlite3BitvecDestroy(pPager->pInJournal);
vendor/sqlite3.c:49308:  pPager->pInJournal = 0;
vendor/sqlite3.c:49312:    assert( !isOpen(pPager->jfd) );
vendor/sqlite3.c:49313:    sqlite3WalEndReadTransaction(pPager->pWal);
vendor/sqlite3.c:49314:    pPager->eState = PAGER_OPEN;
vendor/sqlite3.c:49315:  }else if( !pPager->exclusiveMode ){
vendor/sqlite3.c:49317:    int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0;
vendor/sqlite3.c:49331:     || 1!=(pPager->journalMode & 5)
vendor/sqlite3.c:49333:      sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:49342:    if( rc!=SQLITE_OK && pPager->eState==PAGER_ERROR ){
vendor/sqlite3.c:49343:      pPager->eLock = UNKNOWN_LOCK;
vendor/sqlite3.c:49350:    assert( pPager->errCode || pPager->eState!=PAGER_ERROR );
vendor/sqlite3.c:49351:    pPager->changeCountDone = 0;
vendor/sqlite3.c:49352:    pPager->eState = PAGER_OPEN;
vendor/sqlite3.c:49360:  assert( pPager->errCode==SQLITE_OK || !MEMDB );
vendor/sqlite3.c:49361:  if( pPager->errCode ){
vendor/sqlite3.c:49362:    if( pPager->tempFile==0 ){
vendor/sqlite3.c:49364:      pPager->changeCountDone = 0;
vendor/sqlite3.c:49365:      pPager->eState = PAGER_OPEN;
vendor/sqlite3.c:49367:      pPager->eState = (isOpen(pPager->jfd) ? PAGER_OPEN : PAGER_READER);
vendor/sqlite3.c:49369:    if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);
vendor/sqlite3.c:49370:    pPager->errCode = SQLITE_OK;
vendor/sqlite3.c:49374:  pPager->journalOff = 0;
vendor/sqlite3.c:49375:  pPager->journalHdr = 0;
vendor/sqlite3.c:49376:  pPager->setMaster = 0;
vendor/sqlite3.c:49383:** the error-code about to be returned by a pager API function. The 
vendor/sqlite3.c:49391:** The ERROR state indicates that the contents of the pager-cache 
vendor/sqlite3.c:49393:** the contents of the pager-cache. If a transaction was active when
vendor/sqlite3.c:49402:       pPager->errCode==SQLITE_FULL ||
vendor/sqlite3.c:49403:       pPager->errCode==SQLITE_OK ||
vendor/sqlite3.c:49404:       (pPager->errCode & 0xff)==SQLITE_IOERR
vendor/sqlite3.c:49407:    pPager->errCode = rc;
vendor/sqlite3.c:49408:    pPager->eState = PAGER_ERROR;
vendor/sqlite3.c:49433:  if( pPager->tempFile==0 ) return 1;
vendor/sqlite3.c:49435:  if( !isOpen(pPager->fd) ) return 0;
vendor/sqlite3.c:49436:  return (sqlite3PCachePercentDirty(pPager->pPCache)>=25);
vendor/sqlite3.c:49510:  assert( pPager->eState!=PAGER_ERROR );
vendor/sqlite3.c:49511:  if( pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK ){
vendor/sqlite3.c:49516:  assert( isOpen(pPager->jfd) || pPager->pInJournal==0 
vendor/sqlite3.c:49517:      || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_BATCH_ATOMIC)
vendor/sqlite3.c:49519:  if( isOpen(pPager->jfd) ){
vendor/sqlite3.c:49523:    if( sqlite3JournalIsInMemory(pPager->jfd) ){
vendor/sqlite3.c:49524:      /* assert( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ); */
vendor/sqlite3.c:49525:      sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:49526:    }else if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE ){
vendor/sqlite3.c:49527:      if( pPager->journalOff==0 ){
vendor/sqlite3.c:49530:        rc = sqlite3OsTruncate(pPager->jfd, 0);
vendor/sqlite3.c:49531:        if( rc==SQLITE_OK && pPager->fullSync ){
vendor/sqlite3.c:49537:          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
vendor/sqlite3.c:49540:      pPager->journalOff = 0;
vendor/sqlite3.c:49541:    }else if( pPager->journalMode==PAGER_JOURNALMODE_PERSIST
vendor/sqlite3.c:49542:      || (pPager->exclusiveMode && pPager->journalMode!=PAGER_JOURNALMODE_WAL)
vendor/sqlite3.c:49544:      rc = zeroJournalHdr(pPager, hasMaster||pPager->tempFile);
vendor/sqlite3.c:49545:      pPager->journalOff = 0;
vendor/sqlite3.c:49552:      int bDelete = !pPager->tempFile;
vendor/sqlite3.c:49553:      assert( sqlite3JournalIsInMemory(pPager->jfd)==0 );
vendor/sqlite3.c:49554:      assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE 
vendor/sqlite3.c:49555:           || pPager->journalMode==PAGER_JOURNALMODE_MEMORY 
vendor/sqlite3.c:49556:           || pPager->journalMode==PAGER_JOURNALMODE_WAL 
vendor/sqlite3.c:49558:      sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:49560:        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);
vendor/sqlite3.c:49566:  sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);
vendor/sqlite3.c:49567:  if( pPager->dbSize==0 && sqlite3PcacheRefCount(pPager->pPCache)>0 ){
vendor/sqlite3.c:49576:  sqlite3BitvecDestroy(pPager->pInJournal);
vendor/sqlite3.c:49577:  pPager->pInJournal = 0;
vendor/sqlite3.c:49578:  pPager->nRec = 0;
vendor/sqlite3.c:49581:      sqlite3PcacheCleanAll(pPager->pPCache);
vendor/sqlite3.c:49583:      sqlite3PcacheClearWritable(pPager->pPCache);
vendor/sqlite3.c:49585:    sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
vendor/sqlite3.c:49593:    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
vendor/sqlite3.c:49595:  }else if( rc==SQLITE_OK && bCommit && pPager->dbFileSize>pPager->dbSize ){
vendor/sqlite3.c:49602:    assert( pPager->eLock==EXCLUSIVE_LOCK );
vendor/sqlite3.c:49603:    rc = pager_truncate(pPager, pPager->dbSize);
vendor/sqlite3.c:49606:  if( rc==SQLITE_OK && bCommit && isOpen(pPager->fd) ){
vendor/sqlite3.c:49607:    rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);
vendor/sqlite3.c:49611:  if( !pPager->exclusiveMode 
vendor/sqlite3.c:49612:   && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))
vendor/sqlite3.c:49615:    pPager->changeCountDone = 0;
vendor/sqlite3.c:49617:  pPager->eState = PAGER_READER;
vendor/sqlite3.c:49618:  pPager->setMaster = 0;
vendor/sqlite3.c:49641:  if( pPager->eState!=PAGER_ERROR && pPager->eState!=PAGER_OPEN ){
vendor/sqlite3.c:49643:    if( pPager->eState>=PAGER_WRITER_LOCKED ){
vendor/sqlite3.c:49647:    }else if( !pPager->exclusiveMode ){
vendor/sqlite3.c:49648:      assert( pPager->eState==PAGER_READER );
vendor/sqlite3.c:49656:** Parameter aData must point to a buffer of pPager->pageSize bytes
vendor/sqlite3.c:49658:** page of data and the current value of pPager->cksumInit.
vendor/sqlite3.c:49661:** random initial value (pPager->cksumInit) and every 200th byte
vendor/sqlite3.c:49662:** of the page data, starting with byte offset (pPager->pageSize%200).
vendor/sqlite3.c:49675:  u32 cksum = pPager->cksumInit;         /* Checksum value to return */
vendor/sqlite3.c:49676:  int i = pPager->pageSize-200;          /* Loop counter */
vendor/sqlite3.c:49690:  if( pPager->xCodecSizeChng ){
vendor/sqlite3.c:49691:    pPager->xCodecSizeChng(pPager->pCodec, pPager->pageSize,
vendor/sqlite3.c:49692:                           (int)pPager->nReserve);
vendor/sqlite3.c:49767:  const int jrnlEnc = (isMainJrnl || pPager->subjInMemory==0);
vendor/sqlite3.c:49775:  aData = pPager->pTmpSpace;
vendor/sqlite3.c:49785:  assert( pPager->eState>=PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:49786:       || (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK)
vendor/sqlite3.c:49788:  assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl );
vendor/sqlite3.c:49793:  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;
vendor/sqlite3.c:49796:  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);
vendor/sqlite3.c:49798:  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;
vendor/sqlite3.c:49809:  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){
vendor/sqlite3.c:49829:  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){
vendor/sqlite3.c:49830:    pPager->nReserve = ((u8*)aData)[20];
vendor/sqlite3.c:49875:  assert( pPager->eState!=PAGER_OPEN || pPg==0 || pPager->tempFile );
vendor/sqlite3.c:49877:           PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),
vendor/sqlite3.c:49881:    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);
vendor/sqlite3.c:49885:  if( isOpen(pPager->fd)
vendor/sqlite3.c:49886:   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)
vendor/sqlite3.c:49889:    i64 ofst = (pgno-1)*(i64)pPager->pageSize;
vendor/sqlite3.c:49902:      rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);
vendor/sqlite3.c:49906:    rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);
vendor/sqlite3.c:49908:    if( pgno>pPager->dbFileSize ){
vendor/sqlite3.c:49909:      pPager->dbFileSize = pgno;
vendor/sqlite3.c:49911:    if( pPager->pBackup ){
vendor/sqlite3.c:49915:        sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
vendor/sqlite3.c:49919:      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
vendor/sqlite3.c:49939:    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)==0 );
vendor/sqlite3.c:49940:    pPager->doNotSpill |= SPILLFLAG_ROLLBACK;
vendor/sqlite3.c:49942:    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)!=0 );
vendor/sqlite3.c:49943:    pPager->doNotSpill &= ~SPILLFLAG_ROLLBACK;
vendor/sqlite3.c:49956:    memcpy(pData, (u8*)aData, pPager->pageSize);
vendor/sqlite3.c:49957:    pPager->xReiniter(pPg);
vendor/sqlite3.c:49967:      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
vendor/sqlite3.c:49999:** This function reads the contents of the master-journal file into 
vendor/sqlite3.c:50023:  sqlite3_vfs *pVfs = pPager->pVfs;
vendor/sqlite3.c:50025:  sqlite3_file *pMaster;    /* Malloc'd master-journal file descriptor */
vendor/sqlite3.c:50119:** of the file is changed to nPage pages (nPage*pPager->pageSize bytes). 
vendor/sqlite3.c:50134:  assert( pPager->eState!=PAGER_ERROR );
vendor/sqlite3.c:50135:  assert( pPager->eState!=PAGER_READER );
vendor/sqlite3.c:50137:  if( isOpen(pPager->fd) 
vendor/sqlite3.c:50138:   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN) 
vendor/sqlite3.c:50141:    int szPage = pPager->pageSize;
vendor/sqlite3.c:50142:    assert( pPager->eLock==EXCLUSIVE_LOCK );
vendor/sqlite3.c:50144:    rc = sqlite3OsFileSize(pPager->fd, &currentSize);
vendor/sqlite3.c:50148:        rc = sqlite3OsTruncate(pPager->fd, newSize);
vendor/sqlite3.c:50150:        char *pTmp = pPager->pTmpSpace;
vendor/sqlite3.c:50154:        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);
vendor/sqlite3.c:50157:        pPager->dbFileSize = nPage;
vendor/sqlite3.c:50165:** Return a sanitized version of the sector-size of OS file pFile. The
vendor/sqlite3.c:50195:** pPager->sectorSize is to define the "blast radius" of bytes that
vendor/sqlite3.c:50203:  assert( isOpen(pPager->fd) || pPager->tempFile );
vendor/sqlite3.c:50205:  if( pPager->tempFile
vendor/sqlite3.c:50206:   || (sqlite3OsDeviceCharacteristics(pPager->fd) & 
vendor/sqlite3.c:50212:    pPager->sectorSize = 512;
vendor/sqlite3.c:50214:    pPager->sectorSize = sqlite3SectorSize(pPager->fd);
vendor/sqlite3.c:50238:**        +  pPager->pageSize bytes of data.
vendor/sqlite3.c:50276:  sqlite3_vfs *pVfs = pPager->pVfs;
vendor/sqlite3.c:50286:  u32 savedPageSize = pPager->pageSize;
vendor/sqlite3.c:50291:  assert( isOpen(pPager->jfd) );
vendor/sqlite3.c:50292:  rc = sqlite3OsFileSize(pPager->jfd, &szJ);
vendor/sqlite3.c:50304:  ** (pPager->pageSize >= pPager->pVfs->mxPathname+1). Using os_unix.c,
vendor/sqlite3.c:50308:  zMaster = pPager->pTmpSpace;
vendor/sqlite3.c:50309:  rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);
vendor/sqlite3.c:50317:  pPager->journalOff = 0;
vendor/sqlite3.c:50344:      assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );
vendor/sqlite3.c:50363:        pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){
vendor/sqlite3.c:50364:      nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));
vendor/sqlite3.c:50370:    if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){
vendor/sqlite3.c:50375:      pPager->dbSize = mxPg;
vendor/sqlite3.c:50386:      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);
vendor/sqlite3.c:50391:          pPager->journalOff = szJ;
vendor/sqlite3.c:50425:  if( pPager->fd->pMethods ){
vendor/sqlite3.c:50426:    sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);
vendor/sqlite3.c:50439:  pPager->changeCountDone = pPager->tempFile;
vendor/sqlite3.c:50442:    zMaster = pPager->pTmpSpace;
vendor/sqlite3.c:50443:    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);
vendor/sqlite3.c:50447:   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)
vendor/sqlite3.c:50464:                nPlayback, pPager->zJournal);
vendor/sqlite3.c:50495:  assert( pPager->eState>=PAGER_READER && !MEMDB );
vendor/sqlite3.c:50496:  assert( isOpen(pPager->fd) );
vendor/sqlite3.c:50499:    rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);
vendor/sqlite3.c:50503:    rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);
vendor/sqlite3.c:50507:    i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;
vendor/sqlite3.c:50508:    rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);
vendor/sqlite3.c:50521:      ** pPager->dbFileVers[] with all 0xff bytes should suffice.
vendor/sqlite3.c:50528:      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
vendor/sqlite3.c:50531:      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
vendor/sqlite3.c:50537:  PAGER_INCR(pPager->nRead);
vendor/sqlite3.c:50551:** needed, as determined by the pPager->changeCountDone state variable.
vendor/sqlite3.c:50557:  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;
vendor/sqlite3.c:50593:        pPager->xReiniter(pPg);
vendor/sqlite3.c:50607:  sqlite3BackupRestart(pPager->pBackup);
vendor/sqlite3.c:50626:  pPager->dbSize = pPager->dbOrigSize;
vendor/sqlite3.c:50627:  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);
vendor/sqlite3.c:50628:  pList = sqlite3PcacheDirtyList(pPager->pPCache);
vendor/sqlite3.c:50657:  assert( pPager->pWal );
vendor/sqlite3.c:50684:  pPager->aStat[PAGER_STAT_WRITE] += nList;
vendor/sqlite3.c:50687:  rc = sqlite3WalFrames(pPager->pWal, 
vendor/sqlite3.c:50688:      pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags
vendor/sqlite3.c:50690:  if( rc==SQLITE_OK && pPager->pBackup ){
vendor/sqlite3.c:50692:      sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);
vendor/sqlite3.c:50697:  pList = sqlite3PcacheDirtyList(pPager->pPCache);
vendor/sqlite3.c:50719:  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );
vendor/sqlite3.c:50726:  sqlite3WalEndReadTransaction(pPager->pWal);
vendor/sqlite3.c:50728:  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);
vendor/sqlite3.c:50731:    if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);
vendor/sqlite3.c:50756:  assert( pPager->eState==PAGER_OPEN );
vendor/sqlite3.c:50757:  assert( pPager->eLock>=SHARED_LOCK );
vendor/sqlite3.c:50758:  assert( isOpen(pPager->fd) );
vendor/sqlite3.c:50759:  assert( pPager->tempFile==0 );
vendor/sqlite3.c:50760:  nPage = sqlite3WalDbsize(pPager->pWal);
vendor/sqlite3.c:50767:  if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){
vendor/sqlite3.c:50769:    int rc = sqlite3OsFileSize(pPager->fd, &n);
vendor/sqlite3.c:50773:    nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);
vendor/sqlite3.c:50780:  if( nPage>pPager->mxPgno ){
vendor/sqlite3.c:50781:    pPager->mxPgno = (Pgno)nPage;
vendor/sqlite3.c:50809:  assert( pPager->eState==PAGER_OPEN );
vendor/sqlite3.c:50810:  assert( pPager->eLock>=SHARED_LOCK );
vendor/sqlite3.c:50812:  if( !pPager->tempFile ){
vendor/sqlite3.c:50815:        pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal
vendor/sqlite3.c:50824:          rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
vendor/sqlite3.c:50826:          testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );
vendor/sqlite3.c:50829:      }else if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){
vendor/sqlite3.c:50830:        pPager->journalMode = PAGER_JOURNALMODE_DELETE;
vendor/sqlite3.c:50880:  assert( pPager->eState!=PAGER_ERROR );
vendor/sqlite3.c:50881:  assert( pPager->eState>=PAGER_WRITER_LOCKED );
vendor/sqlite3.c:50894:  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;
vendor/sqlite3.c:50895:  pPager->changeCountDone = pPager->tempFile;
vendor/sqlite3.c:50901:  /* Use pPager->journalOff as the effective size of the main rollback
vendor/sqlite3.c:50904:  ** past pPager->journalOff is off-limits to us.
vendor/sqlite3.c:50906:  szJ = pPager->journalOff;
vendor/sqlite3.c:50912:  ** greater than the current database size (pPager->dbSize) but those
vendor/sqlite3.c:50918:    pPager->journalOff = pSavepoint->iOffset;
vendor/sqlite3.c:50919:    while( rc==SQLITE_OK && pPager->journalOff<iHdrOff ){
vendor/sqlite3.c:50920:      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
vendor/sqlite3.c:50924:    pPager->journalOff = 0;
vendor/sqlite3.c:50932:  while( rc==SQLITE_OK && pPager->journalOff<szJ ){
vendor/sqlite3.c:50940:    ** The "pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff"
vendor/sqlite3.c:50945:     && pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff
vendor/sqlite3.c:50947:      nJRec = (u32)((szJ - pPager->journalOff)/JOURNAL_PG_SZ(pPager));
vendor/sqlite3.c:50949:    for(ii=0; rc==SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++){
vendor/sqlite3.c:50950:      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
vendor/sqlite3.c:50954:  assert( rc!=SQLITE_OK || pPager->journalOff>=szJ );
vendor/sqlite3.c:50962:    i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);
vendor/sqlite3.c:50965:      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);
vendor/sqlite3.c:50967:    for(ii=pSavepoint->iSubRec; rc==SQLITE_OK && ii<pPager->nSubRec; ii++){
vendor/sqlite3.c:50968:      assert( offset==(i64)ii*(4+pPager->pageSize) );
vendor/sqlite3.c:50976:    pPager->journalOff = szJ;
vendor/sqlite3.c:50987:  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
vendor/sqlite3.c:50995:  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
vendor/sqlite3.c:51003:  sqlite3_file *fd = pPager->fd;
vendor/sqlite3.c:51006:    sz = pPager->szMmap;
vendor/sqlite3.c:51007:    pPager->bUseFetch = (sz>0);
vendor/sqlite3.c:51009:    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);
vendor/sqlite3.c:51018:  pPager->szMmap = szMmap;
vendor/sqlite3.c:51026:  sqlite3PcacheShrink(pPager->pPCache);
vendor/sqlite3.c:51086:  if( pPager->tempFile ){
vendor/sqlite3.c:51087:    pPager->noSync = 1;
vendor/sqlite3.c:51088:    pPager->fullSync = 0;
vendor/sqlite3.c:51089:    pPager->extraSync = 0;
vendor/sqlite3.c:51091:    pPager->noSync =  level==PAGER_SYNCHRONOUS_OFF ?1:0;
vendor/sqlite3.c:51092:    pPager->fullSync = level>=PAGER_SYNCHRONOUS_FULL ?1:0;
vendor/sqlite3.c:51093:    pPager->extraSync = level==PAGER_SYNCHRONOUS_EXTRA ?1:0;
vendor/sqlite3.c:51095:  if( pPager->noSync ){
vendor/sqlite3.c:51096:    pPager->syncFlags = 0;
vendor/sqlite3.c:51098:    pPager->syncFlags = SQLITE_SYNC_FULL;
vendor/sqlite3.c:51100:    pPager->syncFlags = SQLITE_SYNC_NORMAL;
vendor/sqlite3.c:51102:  pPager->walSyncFlags = (pPager->syncFlags<<2);
vendor/sqlite3.c:51103:  if( pPager->fullSync ){
vendor/sqlite3.c:51104:    pPager->walSyncFlags |= pPager->syncFlags;
vendor/sqlite3.c:51106:  if( (pgFlags & PAGER_CKPT_FULLFSYNC) && !pPager->noSync ){
vendor/sqlite3.c:51107:    pPager->walSyncFlags |= (SQLITE_SYNC_FULL<<2);
vendor/sqlite3.c:51110:    pPager->doNotSpill &= ~SPILLFLAG_OFF;
vendor/sqlite3.c:51112:    pPager->doNotSpill |= SPILLFLAG_OFF;
vendor/sqlite3.c:51154:  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);
vendor/sqlite3.c:51185:  pPager->xBusyHandler = xBusyHandler;
vendor/sqlite3.c:51186:  pPager->pBusyHandlerArg = pBusyHandlerArg;
vendor/sqlite3.c:51188:  if( isOpen(pPager->fd) ){
vendor/sqlite3.c:51189:    void **ap = (void **)&pPager->xBusyHandler;
vendor/sqlite3.c:51192:    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap);
vendor/sqlite3.c:51241:  if( (pPager->memDb==0 || pPager->dbSize==0)
vendor/sqlite3.c:51242:   && sqlite3PcacheRefCount(pPager->pPCache)==0 
vendor/sqlite3.c:51243:   && pageSize && pageSize!=(u32)pPager->pageSize 
vendor/sqlite3.c:51248:    if( pPager->eState>PAGER_OPEN && isOpen(pPager->fd) ){
vendor/sqlite3.c:51249:      rc = sqlite3OsFileSize(pPager->fd, &nByte);
vendor/sqlite3.c:51258:      rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
vendor/sqlite3.c:51261:      sqlite3PageFree(pPager->pTmpSpace);
vendor/sqlite3.c:51262:      pPager->pTmpSpace = pNew;
vendor/sqlite3.c:51263:      pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);
vendor/sqlite3.c:51264:      pPager->pageSize = pageSize;
vendor/sqlite3.c:51270:  *pPageSize = pPager->pageSize;
vendor/sqlite3.c:51272:    if( nReserve<0 ) nReserve = pPager->nReserve;
vendor/sqlite3.c:51274:    pPager->nReserve = (i16)nReserve;
vendor/sqlite3.c:51290:  return pPager->pTmpSpace;
vendor/sqlite3.c:51302:    pPager->mxPgno = mxPage;
vendor/sqlite3.c:51304:  assert( pPager->eState!=PAGER_OPEN );      /* Called only by OP_MaxPgcnt */
vendor/sqlite3.c:51305:  assert( pPager->mxPgno>=pPager->dbSize );  /* OP_MaxPgcnt enforces this */
vendor/sqlite3.c:51306:  return pPager->mxPgno;
vendor/sqlite3.c:51350:  assert( isOpen(pPager->fd) || pPager->tempFile );
vendor/sqlite3.c:51358:  if( isOpen(pPager->fd) ){
vendor/sqlite3.c:51360:    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);
vendor/sqlite3.c:51376:  assert( pPager->eState>=PAGER_READER );
vendor/sqlite3.c:51377:  assert( pPager->eState!=PAGER_WRITER_FINISHED );
vendor/sqlite3.c:51378:  *pnPage = (int)pPager->dbSize;
vendor/sqlite3.c:51404:  assert( (pPager->eLock>=locktype)
vendor/sqlite3.c:51405:       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)
vendor/sqlite3.c:51406:       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)
vendor/sqlite3.c:51411:  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
vendor/sqlite3.c:51440:  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );
vendor/sqlite3.c:51443:  sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb);
vendor/sqlite3.c:51461:  assert( pPager->dbSize>=nPage );
vendor/sqlite3.c:51462:  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );
vendor/sqlite3.c:51463:  pPager->dbSize = nPage;
vendor/sqlite3.c:51479:** syncs the journal file to disk, then sets pPager->journalHdr to the
vendor/sqlite3.c:51484:** that if a power-failure occurs during the rollback, the process that
vendor/sqlite3.c:51493:  if( !pPager->noSync ){
vendor/sqlite3.c:51494:    rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);
vendor/sqlite3.c:51497:    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);
vendor/sqlite3.c:51521:  if( pPager->pMmapFreelist ){
vendor/sqlite3.c:51522:    *ppPage = p = pPager->pMmapFreelist;
vendor/sqlite3.c:51523:    pPager->pMmapFreelist = p->pDirty;
vendor/sqlite3.c:51525:    assert( pPager->nExtra>=8 );
vendor/sqlite3.c:51528:    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);
vendor/sqlite3.c:51530:      sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);
vendor/sqlite3.c:51547:  pPager->nMmapOut++;
vendor/sqlite3.c:51559:  pPager->nMmapOut--;
vendor/sqlite3.c:51560:  pPg->pDirty = pPager->pMmapFreelist;
vendor/sqlite3.c:51561:  pPager->pMmapFreelist = pPg;
vendor/sqlite3.c:51563:  assert( pPager->fd->pMethods->iVersion>=3 );
vendor/sqlite3.c:51564:  sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);
vendor/sqlite3.c:51573:  for(p=pPager->pMmapFreelist; p; p=pNext){
vendor/sqlite3.c:51595:  u8 *pTmp = (u8 *)pPager->pTmpSpace;
vendor/sqlite3.c:51602:  /* pPager->errCode = 0; */
vendor/sqlite3.c:51603:  pPager->exclusiveMode = 0;
vendor/sqlite3.c:51605:  assert( db || pPager->pWal==0 );
vendor/sqlite3.c:51606:  sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,
vendor/sqlite3.c:51609:  pPager->pWal = 0;
vendor/sqlite3.c:51626:    if( isOpen(pPager->jfd) ){
vendor/sqlite3.c:51635:  sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:51636:  sqlite3OsClose(pPager->fd);
vendor/sqlite3.c:51638:  sqlite3PcacheClose(pPager->pPCache);
vendor/sqlite3.c:51641:  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);
vendor/sqlite3.c:51644:  assert( !pPager->aSavepoint && !pPager->pInJournal );
vendor/sqlite3.c:51645:  assert( !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) );
vendor/sqlite3.c:51705:  assert( pPager->eState==PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:51706:       || pPager->eState==PAGER_WRITER_DBMOD
vendor/sqlite3.c:51714:  if( !pPager->noSync ){
vendor/sqlite3.c:51715:    assert( !pPager->tempFile );
vendor/sqlite3.c:51716:    if( isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){
vendor/sqlite3.c:51717:      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
vendor/sqlite3.c:51718:      assert( isOpen(pPager->jfd) );
vendor/sqlite3.c:51726:        ** previous connection's transaction), and a crash or power-failure 
vendor/sqlite3.c:51748:        put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);
vendor/sqlite3.c:51751:        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);
vendor/sqlite3.c:51754:          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);
vendor/sqlite3.c:51771:        if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){
vendor/sqlite3.c:51774:          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
vendor/sqlite3.c:51777:        IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));
vendor/sqlite3.c:51779:            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr
vendor/sqlite3.c:51786:        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags| 
vendor/sqlite3.c:51787:          (pPager->syncFlags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0)
vendor/sqlite3.c:51792:      pPager->journalHdr = pPager->journalOff;
vendor/sqlite3.c:51794:        pPager->nRec = 0;
vendor/sqlite3.c:51799:      pPager->journalHdr = pPager->journalOff;
vendor/sqlite3.c:51807:  sqlite3PcacheClearSyncFlags(pPager->pPCache);
vendor/sqlite3.c:51808:  pPager->eState = PAGER_WRITER_DBMOD;
vendor/sqlite3.c:51850:  assert( pPager->tempFile || pPager->eState==PAGER_WRITER_DBMOD );
vendor/sqlite3.c:51851:  assert( pPager->eLock==EXCLUSIVE_LOCK );
vendor/sqlite3.c:51852:  assert( isOpen(pPager->fd) || pList->pDirty==0 );
vendor/sqlite3.c:51858:  if( !isOpen(pPager->fd) ){
vendor/sqlite3.c:51859:    assert( pPager->tempFile && rc==SQLITE_OK );
vendor/sqlite3.c:51860:    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
vendor/sqlite3.c:51866:  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );
vendor/sqlite3.c:51868:   && pPager->dbHintSize<pPager->dbSize
vendor/sqlite3.c:51869:   && (pList->pDirty || pList->pgno>pPager->dbHintSize)
vendor/sqlite3.c:51871:    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
vendor/sqlite3.c:51872:    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);
vendor/sqlite3.c:51873:    pPager->dbHintSize = pPager->dbSize;
vendor/sqlite3.c:51887:    if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){
vendor/sqlite3.c:51888:      i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */
vendor/sqlite3.c:51898:      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);
vendor/sqlite3.c:51905:        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
vendor/sqlite3.c:51907:      if( pgno>pPager->dbFileSize ){
vendor/sqlite3.c:51908:        pPager->dbFileSize = pgno;
vendor/sqlite3.c:51910:      pPager->aStat[PAGER_STAT_WRITE]++;
vendor/sqlite3.c:51913:      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);
vendor/sqlite3.c:51939:  if( !isOpen(pPager->sjfd) ){
vendor/sqlite3.c:51944:    if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory ){
vendor/sqlite3.c:51947:    rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);
vendor/sqlite3.c:51966:  if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){
vendor/sqlite3.c:51969:    assert( pPager->useJournal );
vendor/sqlite3.c:51970:    assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );
vendor/sqlite3.c:51971:    assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );
vendor/sqlite3.c:51974:         || pPg->pgno>pPager->dbOrigSize 
vendor/sqlite3.c:51982:      i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);
vendor/sqlite3.c:51986:      if( !pPager->subjInMemory ){
vendor/sqlite3.c:51992:      rc = write32bits(pPager->sjfd, offset, pPg->pgno);
vendor/sqlite3.c:51994:        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);
vendor/sqlite3.c:51999:    pPager->nSubRec++;
vendor/sqlite3.c:52000:    assert( pPager->nSavepoint>0 );
vendor/sqlite3.c:52055:  if( NEVER(pPager->errCode) ) return SQLITE_OK;
vendor/sqlite3.c:52056:  testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );
vendor/sqlite3.c:52057:  testcase( pPager->doNotSpill & SPILLFLAG_OFF );
vendor/sqlite3.c:52058:  testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );
vendor/sqlite3.c:52059:  if( pPager->doNotSpill
vendor/sqlite3.c:52060:   && ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0
vendor/sqlite3.c:52076:    if( pPager->tempFile==0 ){
vendor/sqlite3.c:52077:      rc = sqlite3JournalCreate(pPager->jfd);
vendor/sqlite3.c:52084:     || pPager->eState==PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:52109:  int rc = pPager->errCode;
vendor/sqlite3.c:52111:    PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
vendor/sqlite3.c:52265:  pPager->pPCache =    (PCache*)(pPtr += ROUND8(sizeof(*pPager)));
vendor/sqlite3.c:52266:  pPager->fd =   (sqlite3_file*)(pPtr += ROUND8(pcacheSize));
vendor/sqlite3.c:52267:  pPager->sjfd = (sqlite3_file*)(pPtr += ROUND8(pVfs->szOsFile));
vendor/sqlite3.c:52268:  pPager->jfd =  (sqlite3_file*)(pPtr += journalFileSize);
vendor/sqlite3.c:52269:  pPager->zFilename =    (char*)(pPtr += journalFileSize);
vendor/sqlite3.c:52270:  assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) );
vendor/sqlite3.c:52275:    pPager->zJournal =   (char*)(pPtr += nPathname + 1 + nUri);
vendor/sqlite3.c:52276:    memcpy(pPager->zFilename, zPathname, nPathname);
vendor/sqlite3.c:52277:    if( nUri ) memcpy(&pPager->zFilename[nPathname+1], zUri, nUri);
vendor/sqlite3.c:52278:    memcpy(pPager->zJournal, zPathname, nPathname);
vendor/sqlite3.c:52279:    memcpy(&pPager->zJournal[nPathname], "-journal\000", 8+2);
vendor/sqlite3.c:52280:    sqlite3FileSuffix3(pPager->zFilename, pPager->zJournal);
vendor/sqlite3.c:52282:    pPager->zWal = &pPager->zJournal[nPathname+8+1];
vendor/sqlite3.c:52283:    memcpy(pPager->zWal, zPathname, nPathname);
vendor/sqlite3.c:52284:    memcpy(&pPager->zWal[nPathname], "-wal\000", 4+1);
vendor/sqlite3.c:52285:    sqlite3FileSuffix3(pPager->zFilename, pPager->zWal);
vendor/sqlite3.c:52289:  pPager->pVfs = pVfs;
vendor/sqlite3.c:52290:  pPager->vfsFlags = vfsFlags;
vendor/sqlite3.c:52296:    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
vendor/sqlite3.c:52309:      int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
vendor/sqlite3.c:52313:        if( szPageDflt<pPager->sectorSize ){
vendor/sqlite3.c:52314:          if( pPager->sectorSize>SQLITE_MAX_DEFAULT_PAGE_SIZE ){
vendor/sqlite3.c:52317:            szPageDflt = (u32)pPager->sectorSize;
vendor/sqlite3.c:52334:      pPager->noLock = sqlite3_uri_boolean(zFilename, "nolock", 0);
vendor/sqlite3.c:52354:    pPager->eState = PAGER_READER;     /* Pretend we already have a lock */
vendor/sqlite3.c:52355:    pPager->eLock = EXCLUSIVE_LOCK;    /* Pretend we are in EXCLUSIVE mode */
vendor/sqlite3.c:52356:    pPager->noLock = 1;                /* Do no locking */
vendor/sqlite3.c:52364:    assert( pPager->memDb==0 );
vendor/sqlite3.c:52374:                       !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);
vendor/sqlite3.c:52380:    sqlite3OsClose(pPager->fd);
vendor/sqlite3.c:52381:    sqlite3PageFree(pPager->pTmpSpace);
vendor/sqlite3.c:52386:  PAGERTRACE(("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename));
vendor/sqlite3.c:52387:  IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename))
vendor/sqlite3.c:52389:  pPager->useJournal = (u8)useJournal;
vendor/sqlite3.c:52390:  /* pPager->stmtOpen = 0; */
vendor/sqlite3.c:52391:  /* pPager->stmtInUse = 0; */
vendor/sqlite3.c:52392:  /* pPager->nRef = 0; */
vendor/sqlite3.c:52393:  /* pPager->stmtSize = 0; */
vendor/sqlite3.c:52394:  /* pPager->stmtJSize = 0; */
vendor/sqlite3.c:52395:  /* pPager->nPage = 0; */
vendor/sqlite3.c:52396:  pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;
vendor/sqlite3.c:52397:  /* pPager->state = PAGER_UNLOCK; */
vendor/sqlite3.c:52398:  /* pPager->errMask = 0; */
vendor/sqlite3.c:52399:  pPager->tempFile = (u8)tempFile;
vendor/sqlite3.c:52403:  pPager->exclusiveMode = (u8)tempFile; 
vendor/sqlite3.c:52404:  pPager->changeCountDone = pPager->tempFile;
vendor/sqlite3.c:52405:  pPager->memDb = (u8)memDb;
vendor/sqlite3.c:52406:  pPager->readOnly = (u8)readOnly;
vendor/sqlite3.c:52407:  assert( useJournal || pPager->tempFile );
vendor/sqlite3.c:52408:  pPager->noSync = pPager->tempFile;
vendor/sqlite3.c:52409:  if( pPager->noSync ){
vendor/sqlite3.c:52410:    assert( pPager->fullSync==0 );
vendor/sqlite3.c:52411:    assert( pPager->extraSync==0 );
vendor/sqlite3.c:52412:    assert( pPager->syncFlags==0 );
vendor/sqlite3.c:52413:    assert( pPager->walSyncFlags==0 );
vendor/sqlite3.c:52415:    pPager->fullSync = 1;
vendor/sqlite3.c:52416:    pPager->extraSync = 0;
vendor/sqlite3.c:52417:    pPager->syncFlags = SQLITE_SYNC_NORMAL;
vendor/sqlite3.c:52418:    pPager->walSyncFlags = SQLITE_SYNC_NORMAL | (SQLITE_SYNC_NORMAL<<2);
vendor/sqlite3.c:52420:  /* pPager->pFirst = 0; */
vendor/sqlite3.c:52421:  /* pPager->pFirstSynced = 0; */
vendor/sqlite3.c:52422:  /* pPager->pLast = 0; */
vendor/sqlite3.c:52423:  pPager->nExtra = (u16)nExtra;
vendor/sqlite3.c:52424:  pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;
vendor/sqlite3.c:52425:  assert( isOpen(pPager->fd) || tempFile );
vendor/sqlite3.c:52428:    pPager->journalMode = PAGER_JOURNALMODE_OFF;
vendor/sqlite3.c:52430:    pPager->journalMode = PAGER_JOURNALMODE_MEMORY;
vendor/sqlite3.c:52432:  /* pPager->xBusyHandler = 0; */
vendor/sqlite3.c:52433:  /* pPager->pBusyHandlerArg = 0; */
vendor/sqlite3.c:52434:  pPager->xReiniter = xReinit;
vendor/sqlite3.c:52436:  /* memset(pPager->aHash, 0, sizeof(pPager->aHash)); */
vendor/sqlite3.c:52437:  /* pPager->szMmap = SQLITE_DEFAULT_MMAP_SIZE // will be set by btree.c */
vendor/sqlite3.c:52453:  if( pPager->tempFile ) return SQLITE_OK;
vendor/sqlite3.c:52454:  if( pPager->dbSize==0 ) return SQLITE_OK;
vendor/sqlite3.c:52455:  assert( pPager->zFilename && pPager->zFilename[0] );
vendor/sqlite3.c:52456:  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);
vendor/sqlite3.c:52501:  sqlite3_vfs * const pVfs = pPager->pVfs;
vendor/sqlite3.c:52504:  int jrnlOpen = !!isOpen(pPager->jfd);
vendor/sqlite3.c:52506:  assert( pPager->useJournal );
vendor/sqlite3.c:52507:  assert( isOpen(pPager->fd) );
vendor/sqlite3.c:52508:  assert( pPager->eState==PAGER_OPEN );
vendor/sqlite3.c:52510:  assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &
vendor/sqlite3.c:52516:    rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);
vendor/sqlite3.c:52529:    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);
vendor/sqlite3.c:52533:      assert( pPager->tempFile==0 );
vendor/sqlite3.c:52547:            sqlite3OsDelete(pVfs, pPager->zJournal, 0);
vendor/sqlite3.c:52548:            if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);
vendor/sqlite3.c:52560:            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);
vendor/sqlite3.c:52564:            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);
vendor/sqlite3.c:52569:              sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:52627:  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 );
vendor/sqlite3.c:52629:  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );
vendor/sqlite3.c:52630:  assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:52632:  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){
vendor/sqlite3.c:52636:    assert( pPager->tempFile==0 || pPager->eLock==EXCLUSIVE_LOCK );
vendor/sqlite3.c:52640:      assert( pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK );
vendor/sqlite3.c:52647:    if( pPager->eLock<=SHARED_LOCK ){
vendor/sqlite3.c:52654:      if( pPager->readOnly ){
vendor/sqlite3.c:52689:      ** may mean that the pager was in the error-state when this
vendor/sqlite3.c:52692:      if( !isOpen(pPager->jfd) ){
vendor/sqlite3.c:52693:        sqlite3_vfs * const pVfs = pPager->pVfs;
vendor/sqlite3.c:52696:            pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);
vendor/sqlite3.c:52700:          assert( !pPager->tempFile );
vendor/sqlite3.c:52701:          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);
vendor/sqlite3.c:52702:          assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );
vendor/sqlite3.c:52705:            sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:52718:      if( isOpen(pPager->jfd) ){
vendor/sqlite3.c:52722:          rc = pager_playback(pPager, !pPager->tempFile);
vendor/sqlite3.c:52723:          pPager->eState = PAGER_OPEN;
vendor/sqlite3.c:52725:      }else if( !pPager->exclusiveMode ){
vendor/sqlite3.c:52750:      assert( pPager->eState==PAGER_OPEN );
vendor/sqlite3.c:52751:      assert( (pPager->eLock==SHARED_LOCK)
vendor/sqlite3.c:52752:           || (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK)
vendor/sqlite3.c:52756:    if( !pPager->tempFile && pPager->hasHeldSharedLock ){
vendor/sqlite3.c:52773:      char dbFileVers[sizeof(pPager->dbFileVers)];
vendor/sqlite3.c:52776:      rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
vendor/sqlite3.c:52784:      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){
vendor/sqlite3.c:52794:          sqlite3OsUnfetch(pPager->fd, 0, 0);
vendor/sqlite3.c:52804:    assert( pPager->pWal==0 || rc==SQLITE_OK );
vendor/sqlite3.c:52813:  if( pPager->tempFile==0 && pPager->eState==PAGER_OPEN && rc==SQLITE_OK ){
vendor/sqlite3.c:52814:    rc = pagerPagecount(pPager, &pPager->dbSize);
vendor/sqlite3.c:52821:    assert( pPager->eState==PAGER_OPEN );
vendor/sqlite3.c:52823:    pPager->eState = PAGER_READER;
vendor/sqlite3.c:52824:    pPager->hasHeldSharedLock = 1;
vendor/sqlite3.c:52838:  if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){
vendor/sqlite3.c:52839:    assert( pPager->nMmapOut==0 ); /* because page1 is never memory mapped */
vendor/sqlite3.c:52912:  assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:52913:  assert( pPager->eState>=PAGER_READER );
vendor/sqlite3.c:52915:  assert( pPager->hasHeldSharedLock==1 );
vendor/sqlite3.c:52918:  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);
vendor/sqlite3.c:52921:    rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);
vendor/sqlite3.c:52928:  pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);
vendor/sqlite3.c:52938:    pPager->aStat[PAGER_STAT_HIT]++;
vendor/sqlite3.c:52955:    assert( !isOpen(pPager->fd) || !MEMDB );
vendor/sqlite3.c:52956:    if( !isOpen(pPager->fd) || pPager->dbSize<pgno || noContent ){
vendor/sqlite3.c:52957:      if( pgno>pPager->mxPgno ){
vendor/sqlite3.c:52969:        if( pgno<=pPager->dbOrigSize ){
vendor/sqlite3.c:52970:          TESTONLY( rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);
vendor/sqlite3.c:52977:      memset(pPg->pData, 0, pPager->pageSize);
vendor/sqlite3.c:52981:      pPager->aStat[PAGER_STAT_MISS]++;
vendor/sqlite3.c:53018:   && (pPager->eState==PAGER_READER || (flags & PAGER_GET_READONLY))
vendor/sqlite3.c:53023:  assert( pPager->xCodec==0 );
vendor/sqlite3.c:53033:  assert( pPager->eState>=PAGER_READER );
vendor/sqlite3.c:53035:  assert( pPager->hasHeldSharedLock==1 );
vendor/sqlite3.c:53036:  assert( pPager->errCode==SQLITE_OK );
vendor/sqlite3.c:53039:    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);
vendor/sqlite3.c:53047:    rc = sqlite3OsFetch(pPager->fd, 
vendor/sqlite3.c:53048:        (i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData
vendor/sqlite3.c:53051:      if( pPager->eState>PAGER_READER || pPager->tempFile ){
vendor/sqlite3.c:53057:        sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);
vendor/sqlite3.c:53083:  assert( pPager->errCode!=SQLITE_OK );
vendor/sqlite3.c:53085:  return pPager->errCode;
vendor/sqlite3.c:53097:  return pPager->xGet(pPager, pgno, ppPage, flags);
vendor/sqlite3.c:53115:  assert( pPager->pPCache!=0 );
vendor/sqlite3.c:53116:  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);
vendor/sqlite3.c:53117:  assert( pPage==0 || pPager->hasHeldSharedLock );
vendor/sqlite3.c:53119:  return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);
vendor/sqlite3.c:53144:  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 );
vendor/sqlite3.c:53183:  sqlite3_vfs * const pVfs = pPager->pVfs;   /* Local cache of vfs pointer */
vendor/sqlite3.c:53185:  assert( pPager->eState==PAGER_WRITER_LOCKED );
vendor/sqlite3.c:53187:  assert( pPager->pInJournal==0 );
vendor/sqlite3.c:53192:  if( NEVER(pPager->errCode) ) return pPager->errCode;
vendor/sqlite3.c:53194:  if( !pagerUseWal(pPager) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){
vendor/sqlite3.c:53195:    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);
vendor/sqlite3.c:53196:    if( pPager->pInJournal==0 ){
vendor/sqlite3.c:53201:    if( !isOpen(pPager->jfd) ){
vendor/sqlite3.c:53202:      if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){
vendor/sqlite3.c:53203:        sqlite3MemJournalOpen(pPager->jfd);
vendor/sqlite3.c:53208:        if( pPager->tempFile ){
vendor/sqlite3.c:53221:              pVfs, pPager->zJournal, pPager->jfd, flags, nSpill
vendor/sqlite3.c:53225:      assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );
vendor/sqlite3.c:53234:      pPager->nRec = 0;
vendor/sqlite3.c:53235:      pPager->journalOff = 0;
vendor/sqlite3.c:53236:      pPager->setMaster = 0;
vendor/sqlite3.c:53237:      pPager->journalHdr = 0;
vendor/sqlite3.c:53243:    sqlite3BitvecDestroy(pPager->pInJournal);
vendor/sqlite3.c:53244:    pPager->pInJournal = 0;
vendor/sqlite3.c:53246:    assert( pPager->eState==PAGER_WRITER_LOCKED );
vendor/sqlite3.c:53247:    pPager->eState = PAGER_WRITER_CACHEMOD;
vendor/sqlite3.c:53273:  if( pPager->errCode ) return pPager->errCode;
vendor/sqlite3.c:53274:  assert( pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR );
vendor/sqlite3.c:53275:  pPager->subjInMemory = (u8)subjInMemory;
vendor/sqlite3.c:53277:  if( ALWAYS(pPager->eState==PAGER_READER) ){
vendor/sqlite3.c:53278:    assert( pPager->pInJournal==0 );
vendor/sqlite3.c:53284:      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){
vendor/sqlite3.c:53289:        (void)sqlite3WalExclusiveMode(pPager->pWal, 1);
vendor/sqlite3.c:53297:      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);
vendor/sqlite3.c:53320:      pPager->eState = PAGER_WRITER_LOCKED;
vendor/sqlite3.c:53321:      pPager->dbHintSize = pPager->dbSize;
vendor/sqlite3.c:53322:      pPager->dbFileSize = pPager->dbSize;
vendor/sqlite3.c:53323:      pPager->dbOrigSize = pPager->dbSize;
vendor/sqlite3.c:53324:      pPager->journalOff = 0;
vendor/sqlite3.c:53327:    assert( rc==SQLITE_OK || pPager->eState==PAGER_READER );
vendor/sqlite3.c:53328:    assert( rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED );
vendor/sqlite3.c:53344:  i64 iOff = pPager->journalOff;
vendor/sqlite3.c:53351:  assert( pPager->journalHdr<=pPager->journalOff );
vendor/sqlite3.c:53364:  rc = write32bits(pPager->jfd, iOff, pPg->pgno);
vendor/sqlite3.c:53366:  rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);
vendor/sqlite3.c:53368:  rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);
vendor/sqlite3.c:53372:           pPager->journalOff, pPager->pageSize));
vendor/sqlite3.c:53378:  pPager->journalOff += 8 + pPager->pageSize;
vendor/sqlite3.c:53379:  pPager->nRec++;
vendor/sqlite3.c:53380:  assert( pPager->pInJournal!=0 );
vendor/sqlite3.c:53381:  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
vendor/sqlite3.c:53404:  assert( pPager->eState==PAGER_WRITER_LOCKED
vendor/sqlite3.c:53405:       || pPager->eState==PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:53406:       || pPager->eState==PAGER_WRITER_DBMOD
vendor/sqlite3.c:53409:  assert( pPager->errCode==0 );
vendor/sqlite3.c:53410:  assert( pPager->readOnly==0 );
vendor/sqlite3.c:53422:  if( pPager->eState==PAGER_WRITER_LOCKED ){
vendor/sqlite3.c:53426:  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );
vendor/sqlite3.c:53436:  assert( (pPager->pInJournal!=0) == isOpen(pPager->jfd) );
vendor/sqlite3.c:53437:  if( pPager->pInJournal!=0
vendor/sqlite3.c:53438:   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0
vendor/sqlite3.c:53441:    if( pPg->pgno<=pPager->dbOrigSize ){
vendor/sqlite3.c:53447:      if( pPager->eState!=PAGER_WRITER_DBMOD ){
vendor/sqlite3.c:53466:  if( pPager->nSavepoint>0 ){
vendor/sqlite3.c:53471:  if( pPager->dbSize<pPg->pgno ){
vendor/sqlite3.c:53472:    pPager->dbSize = pPg->pgno;
vendor/sqlite3.c:53496:  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);
vendor/sqlite3.c:53503:  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)==0 );
vendor/sqlite3.c:53504:  pPager->doNotSpill |= SPILLFLAG_NOSYNC;
vendor/sqlite3.c:53506:  /* This trick assumes that both the page-size and sector-size are
vendor/sqlite3.c:53510:  pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;
vendor/sqlite3.c:53512:  nPageCount = pPager->dbSize;
vendor/sqlite3.c:53515:  }else if( (pg1+nPagePerSector-1)>nPageCount ){
vendor/sqlite3.c:53527:    if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){
vendor/sqlite3.c:53563:  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)!=0 );
vendor/sqlite3.c:53564:  pPager->doNotSpill &= ~SPILLFLAG_NOSYNC;
vendor/sqlite3.c:53585:  assert( pPager->eState>=PAGER_WRITER_LOCKED );
vendor/sqlite3.c:53587:  if( (pPg->flags & PGHDR_WRITEABLE)!=0 && pPager->dbSize>=pPg->pgno ){
vendor/sqlite3.c:53588:    if( pPager->nSavepoint ) return subjournalPageIfRequired(pPg);
vendor/sqlite3.c:53590:  }else if( pPager->errCode ){
vendor/sqlite3.c:53591:    return pPager->errCode;
vendor/sqlite3.c:53592:  }else if( pPager->sectorSize > (u32)pPager->pageSize ){
vendor/sqlite3.c:53593:    assert( pPager->tempFile==0 );
vendor/sqlite3.c:53633:  if( !pPager->tempFile && (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint==0 ){
vendor/sqlite3.c:53649:** But this only happens if the pPager->changeCountDone flag is false.
vendor/sqlite3.c:53668:  assert( pPager->eState==PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:53669:       || pPager->eState==PAGER_WRITER_DBMOD
vendor/sqlite3.c:53691:  if( !pPager->changeCountDone && ALWAYS(pPager->dbSize>0) ){
vendor/sqlite3.c:53694:    assert( !pPager->tempFile && isOpen(pPager->fd) );
vendor/sqlite3.c:53716:        assert( pPager->dbFileSize>0 );
vendor/sqlite3.c:53717:        CODEC2(pPager, pPgHdr->pData, 1, 6, rc=SQLITE_NOMEM_BKPT, zBuf);
vendor/sqlite3.c:53719:          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);
vendor/sqlite3.c:53720:          pPager->aStat[PAGER_STAT_WRITE]++;
vendor/sqlite3.c:53727:          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
vendor/sqlite3.c:53728:          pPager->changeCountDone = 1;
vendor/sqlite3.c:53731:        pPager->changeCountDone = 1;
vendor/sqlite3.c:53751:  if( isOpen(pPager->fd) ){
vendor/sqlite3.c:53753:    rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);
vendor/sqlite3.c:53756:  if( rc==SQLITE_OK && !pPager->noSync ){
vendor/sqlite3.c:53758:    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);
vendor/sqlite3.c:53775:  int rc = pPager->errCode;
vendor/sqlite3.c:53778:    assert( pPager->eState==PAGER_WRITER_CACHEMOD 
vendor/sqlite3.c:53779:         || pPager->eState==PAGER_WRITER_DBMOD 
vendor/sqlite3.c:53780:         || pPager->eState==PAGER_WRITER_LOCKED 
vendor/sqlite3.c:53823:  assert( pPager->eState==PAGER_WRITER_LOCKED
vendor/sqlite3.c:53824:       || pPager->eState==PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:53825:       || pPager->eState==PAGER_WRITER_DBMOD
vendor/sqlite3.c:53826:       || pPager->eState==PAGER_ERROR
vendor/sqlite3.c:53831:  if( NEVER(pPager->errCode) ) return pPager->errCode;
vendor/sqlite3.c:53837:      pPager->zFilename, zMaster, pPager->dbSize));
vendor/sqlite3.c:53840:  if( pPager->eState<PAGER_WRITER_CACHEMOD ) return SQLITE_OK;
vendor/sqlite3.c:53842:  assert( MEMDB==0 || pPager->tempFile );
vendor/sqlite3.c:53843:  assert( isOpen(pPager->fd) || pPager->tempFile );
vendor/sqlite3.c:53848:    sqlite3BackupRestart(pPager->pBackup);
vendor/sqlite3.c:53851:      PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
vendor/sqlite3.c:53862:        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);
vendor/sqlite3.c:53866:        sqlite3PcacheCleanAll(pPager->pPCache);
vendor/sqlite3.c:53873:      sqlite3_file *fd = pPager->fd;
vendor/sqlite3.c:53877:        && !pPager->noSync
vendor/sqlite3.c:53878:        && sqlite3JournalIsInMemory(pPager->jfd);
vendor/sqlite3.c:53909:        assert( isOpen(pPager->jfd) 
vendor/sqlite3.c:53910:            || pPager->journalMode==PAGER_JOURNALMODE_OFF 
vendor/sqlite3.c:53911:            || pPager->journalMode==PAGER_JOURNALMODE_WAL 
vendor/sqlite3.c:53913:        if( !zMaster && isOpen(pPager->jfd) 
vendor/sqlite3.c:53914:         && pPager->journalOff==jrnlBufferSize(pPager) 
vendor/sqlite3.c:53915:         && pPager->dbSize>=pPager->dbOrigSize
vendor/sqlite3.c:53916:         && (!(pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0==pPg->pDirty)
vendor/sqlite3.c:53926:          rc = sqlite3JournalCreate(pPager->jfd);
vendor/sqlite3.c:53935:        rc = sqlite3JournalCreate(pPager->jfd);
vendor/sqlite3.c:53968:        sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:53972:      rc = pager_write_pagelist(pPager,sqlite3PcacheDirtyList(pPager->pPCache));
vendor/sqlite3.c:53985:      sqlite3PcacheCleanAll(pPager->pPCache);
vendor/sqlite3.c:53993:      if( pPager->dbSize>pPager->dbFileSize ){
vendor/sqlite3.c:53994:        Pgno nNew = pPager->dbSize - (pPager->dbSize==PAGER_MJ_PGNO(pPager));
vendor/sqlite3.c:53995:        assert( pPager->eState==PAGER_WRITER_DBMOD );
vendor/sqlite3.c:54010:    pPager->eState = PAGER_WRITER_FINISHED;
vendor/sqlite3.c:54037:  if( NEVER(pPager->errCode) ) return pPager->errCode;
vendor/sqlite3.c:54039:  assert( pPager->eState==PAGER_WRITER_LOCKED
vendor/sqlite3.c:54040:       || pPager->eState==PAGER_WRITER_FINISHED
vendor/sqlite3.c:54041:       || (pagerUseWal(pPager) && pPager->eState==PAGER_WRITER_CACHEMOD)
vendor/sqlite3.c:54056:  if( pPager->eState==PAGER_WRITER_LOCKED 
vendor/sqlite3.c:54057:   && pPager->exclusiveMode 
vendor/sqlite3.c:54058:   && pPager->journalMode==PAGER_JOURNALMODE_PERSIST
vendor/sqlite3.c:54060:    assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff );
vendor/sqlite3.c:54061:    pPager->eState = PAGER_READER;
vendor/sqlite3.c:54066:  pPager->iDataVersion++;
vendor/sqlite3.c:54067:  rc = pager_end_transaction(pPager, pPager->setMaster, 1);
vendor/sqlite3.c:54106:  if( pPager->eState==PAGER_ERROR ) return pPager->errCode;
vendor/sqlite3.c:54107:  if( pPager->eState<=PAGER_READER ) return SQLITE_OK;
vendor/sqlite3.c:54112:    rc2 = pager_end_transaction(pPager, pPager->setMaster, 0);
vendor/sqlite3.c:54114:  }else if( !isOpen(pPager->jfd) || pPager->eState==PAGER_WRITER_LOCKED ){
vendor/sqlite3.c:54115:    int eState = pPager->eState;
vendor/sqlite3.c:54122:      pPager->errCode = SQLITE_ABORT;
vendor/sqlite3.c:54123:      pPager->eState = PAGER_ERROR;
vendor/sqlite3.c:54131:  assert( pPager->eState==PAGER_READER || rc!=SQLITE_OK );
vendor/sqlite3.c:54148:  return pPager->readOnly;
vendor/sqlite3.c:54156:  return sqlite3PcacheRefCount(pPager->pPCache);
vendor/sqlite3.c:54165:  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)
vendor/sqlite3.c:54167:  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)
vendor/sqlite3.c:54169:           + pPager->pageSize;
vendor/sqlite3.c:54185:  a[0] = sqlite3PcacheRefCount(pPager->pPCache);
vendor/sqlite3.c:54186:  a[1] = sqlite3PcachePagecount(pPager->pPCache);
vendor/sqlite3.c:54187:  a[2] = sqlite3PcacheGetCachesize(pPager->pPCache);
vendor/sqlite3.c:54188:  a[3] = pPager->eState==PAGER_OPEN ? -1 : (int) pPager->dbSize;
vendor/sqlite3.c:54189:  a[4] = pPager->eState;
vendor/sqlite3.c:54190:  a[5] = pPager->errCode;
vendor/sqlite3.c:54191:  a[6] = pPager->aStat[PAGER_STAT_HIT];
vendor/sqlite3.c:54192:  a[7] = pPager->aStat[PAGER_STAT_MISS];
vendor/sqlite3.c:54193:  a[8] = 0;  /* Used to be pPager->nOvfl */
vendor/sqlite3.c:54194:  a[9] = pPager->nRead;
vendor/sqlite3.c:54195:  a[10] = pPager->aStat[PAGER_STAT_WRITE];
vendor/sqlite3.c:54218:  *pnVal += pPager->aStat[eStat - SQLITE_DBSTATUS_CACHE_HIT];
vendor/sqlite3.c:54220:    pPager->aStat[eStat - SQLITE_DBSTATUS_CACHE_HIT] = 0;
vendor/sqlite3.c:54228:  return pPager->tempFile;
vendor/sqlite3.c:54243:  int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */
vendor/sqlite3.c:54247:  assert( pPager->eState>=PAGER_WRITER_LOCKED );
vendor/sqlite3.c:54249:  assert( nSavepoint>nCurrent && pPager->useJournal );
vendor/sqlite3.c:54256:      pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint
vendor/sqlite3.c:54262:  pPager->aSavepoint = aNew;
vendor/sqlite3.c:54266:    aNew[ii].nOrig = pPager->dbSize;
vendor/sqlite3.c:54267:    if( isOpen(pPager->jfd) && pPager->journalOff>0 ){
vendor/sqlite3.c:54268:      aNew[ii].iOffset = pPager->journalOff;
vendor/sqlite3.c:54272:    aNew[ii].iSubRec = pPager->nSubRec;
vendor/sqlite3.c:54273:    aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
vendor/sqlite3.c:54278:      sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
vendor/sqlite3.c:54280:    pPager->nSavepoint = ii+1;
vendor/sqlite3.c:54282:  assert( pPager->nSavepoint==nSavepoint );
vendor/sqlite3.c:54287:  assert( pPager->eState>=PAGER_WRITER_LOCKED );
vendor/sqlite3.c:54290:  if( nSavepoint>pPager->nSavepoint && pPager->useJournal ){
vendor/sqlite3.c:54329:  int rc = pPager->errCode;
vendor/sqlite3.c:54338:  if( rc==SQLITE_OK && iSavepoint<pPager->nSavepoint ){
vendor/sqlite3.c:54347:    for(ii=nNew; ii<pPager->nSavepoint; ii++){
vendor/sqlite3.c:54348:      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
vendor/sqlite3.c:54350:    pPager->nSavepoint = nNew;
vendor/sqlite3.c:54355:      if( nNew==0 && isOpen(pPager->sjfd) ){
vendor/sqlite3.c:54357:        if( sqlite3JournalIsInMemory(pPager->sjfd) ){
vendor/sqlite3.c:54358:          rc = sqlite3OsTruncate(pPager->sjfd, 0);
vendor/sqlite3.c:54361:        pPager->nSubRec = 0;
vendor/sqlite3.c:54369:    else if( pagerUseWal(pPager) || isOpen(pPager->jfd) ){
vendor/sqlite3.c:54370:      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];
vendor/sqlite3.c:54381:        pPager->journalMode==PAGER_JOURNALMODE_OFF 
vendor/sqlite3.c:54382:     && pPager->eState>=PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:54384:      pPager->errCode = SQLITE_ABORT;
vendor/sqlite3.c:54385:      pPager->eState = PAGER_ERROR;
vendor/sqlite3.c:54405:  return (nullIfMemDb && pPager->memDb) ? "" : pPager->zFilename;
vendor/sqlite3.c:54412:  return pPager->pVfs;
vendor/sqlite3.c:54421:  return pPager->fd;
vendor/sqlite3.c:54430:  return pPager->jfd;
vendor/sqlite3.c:54432:  return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;
vendor/sqlite3.c:54440:  return pPager->zJournal;
vendor/sqlite3.c:54454:  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);
vendor/sqlite3.c:54455:  pPager->xCodec = pPager->memDb ? 0 : xCodec;
vendor/sqlite3.c:54456:  pPager->xCodecSizeChng = xCodecSizeChng;
vendor/sqlite3.c:54457:  pPager->xCodecFree = xCodecFree;
vendor/sqlite3.c:54458:  pPager->pCodec = pCodec;
vendor/sqlite3.c:54463:  return pPager->pCodec;
vendor/sqlite3.c:54483:  return pPager->eState;
vendor/sqlite3.c:54520:  assert( pPager->eState==PAGER_WRITER_CACHEMOD
vendor/sqlite3.c:54521:       || pPager->eState==PAGER_WRITER_DBMOD
vendor/sqlite3.c:54528:  assert( pPager->tempFile || !MEMDB );
vendor/sqlite3.c:54529:  if( pPager->tempFile ){
vendor/sqlite3.c:54571:    assert( pPager->journalMode==PAGER_JOURNALMODE_OFF ||
vendor/sqlite3.c:54572:            pageInJournal(pPager, pPg) || pPg->pgno>pPager->dbOrigSize );
vendor/sqlite3.c:54586:    if( pPager->tempFile ){
vendor/sqlite3.c:54589:      sqlite3PcacheMove(pPgOld, pPager->dbSize+1);
vendor/sqlite3.c:54603:  if( pPager->tempFile && pPgOld ){
vendor/sqlite3.c:54613:    ** loading the page into the pager-cache and setting the PGHDR_NEED_SYNC
vendor/sqlite3.c:54626:      if( needSyncPgno<=pPager->dbOrigSize ){
vendor/sqlite3.c:54627:        assert( pPager->pTmpSpace!=0 );
vendor/sqlite3.c:54628:        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);
vendor/sqlite3.c:54632:    pPgHdr->flags |= PGHDR_NEED_SYNC;
vendor/sqlite3.c:54657:  assert( pPg->nRef>0 || pPg->pPager->memDb );
vendor/sqlite3.c:54685:  assert( pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) );
vendor/sqlite3.c:54686:  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){
vendor/sqlite3.c:54687:    pPager->exclusiveMode = (u8)eMode;
vendor/sqlite3.c:54689:  return (int)pPager->exclusiveMode;
vendor/sqlite3.c:54713:  u8 eOld = pPager->journalMode;    /* Prior journalmode */
vendor/sqlite3.c:54734:  assert( pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL );
vendor/sqlite3.c:54749:    assert( pPager->eState!=PAGER_ERROR );
vendor/sqlite3.c:54750:    pPager->journalMode = (u8)eMode;
vendor/sqlite3.c:54763:    assert( isOpen(pPager->fd) || pPager->exclusiveMode );
vendor/sqlite3.c:54764:    if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){
vendor/sqlite3.c:54774:      sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:54775:      if( pPager->eLock>=RESERVED_LOCK ){
vendor/sqlite3.c:54776:        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
vendor/sqlite3.c:54779:        int state = pPager->eState;
vendor/sqlite3.c:54784:        if( pPager->eState==PAGER_READER ){
vendor/sqlite3.c:54789:          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
vendor/sqlite3.c:54796:        assert( state==pPager->eState );
vendor/sqlite3.c:54799:      sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:54804:  return (int)pPager->journalMode;
vendor/sqlite3.c:54811:  return (int)pPager->journalMode;
vendor/sqlite3.c:54821:  if( pPager->eState>=PAGER_WRITER_CACHEMOD ) return 0;
vendor/sqlite3.c:54822:  if( NEVER(isOpen(pPager->jfd) && pPager->journalOff>0) ) return 0;
vendor/sqlite3.c:54834:    pPager->journalSizeLimit = iLimit;
vendor/sqlite3.c:54835:    sqlite3WalLimit(pPager->pWal, iLimit);
vendor/sqlite3.c:54837:  return pPager->journalSizeLimit;
vendor/sqlite3.c:54841:** Return a pointer to the pPager->pBackup variable. The backup module
vendor/sqlite3.c:54847:  return &pPager->pBackup;
vendor/sqlite3.c:54855:  assert( MEMDB==0 || pPager->tempFile );
vendor/sqlite3.c:54856:  if( pPager->tempFile==0 ) pager_reset(pPager);
vendor/sqlite3.c:54877:  if( pPager->pWal ){
vendor/sqlite3.c:54878:    rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode,
vendor/sqlite3.c:54879:        (eMode==SQLITE_CHECKPOINT_PASSIVE ? 0 : pPager->xBusyHandler),
vendor/sqlite3.c:54880:        pPager->pBusyHandlerArg,
vendor/sqlite3.c:54881:        pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
vendor/sqlite3.c:54889:  return sqlite3WalCallback(pPager->pWal);
vendor/sqlite3.c:54897:  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;
vendor/sqlite3.c:54898:  if( pPager->noLock ) return 0;
vendor/sqlite3.c:54899:  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);
vendor/sqlite3.c:54909:  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );
vendor/sqlite3.c:54929:  assert( pPager->pWal==0 && pPager->tempFile==0 );
vendor/sqlite3.c:54930:  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );
vendor/sqlite3.c:54937:  if( pPager->exclusiveMode ){
vendor/sqlite3.c:54945:    rc = sqlite3WalOpen(pPager->pVfs,
vendor/sqlite3.c:54946:        pPager->fd, pPager->zWal, pPager->exclusiveMode,
vendor/sqlite3.c:54947:        pPager->journalSizeLimit, &pPager->pWal
vendor/sqlite3.c:54978:  assert( pPager->eState==PAGER_OPEN   || pbOpen );
vendor/sqlite3.c:54979:  assert( pPager->eState==PAGER_READER || !pbOpen );
vendor/sqlite3.c:54981:  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) );
vendor/sqlite3.c:54983:  if( !pPager->tempFile && !pPager->pWal ){
vendor/sqlite3.c:54987:    sqlite3OsClose(pPager->jfd);
vendor/sqlite3.c:54991:      pPager->journalMode = PAGER_JOURNALMODE_WAL;
vendor/sqlite3.c:54992:      pPager->eState = PAGER_OPEN;
vendor/sqlite3.c:55013:  assert( pPager->journalMode==PAGER_JOURNALMODE_WAL );
vendor/sqlite3.c:55019:  if( !pPager->pWal ){
vendor/sqlite3.c:55024:          pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &logexists
vendor/sqlite3.c:55035:  if( rc==SQLITE_OK && pPager->pWal ){
vendor/sqlite3.c:55038:      rc = sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags,
vendor/sqlite3.c:55039:                           pPager->pageSize, (u8*)pPager->pTmpSpace);
vendor/sqlite3.c:55040:      pPager->pWal = 0;
vendor/sqlite3.c:55042:      if( rc && !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);
vendor/sqlite3.c:55055:  if( pPager->pWal ){
vendor/sqlite3.c:55056:    rc = sqlite3WalSnapshotGet(pPager->pWal, ppSnapshot);
vendor/sqlite3.c:55068:  if( pPager->pWal ){
vendor/sqlite3.c:55069:    sqlite3WalSnapshotOpen(pPager->pWal, pSnapshot);
vendor/sqlite3.c:55082:  if( pPager->pWal ){
vendor/sqlite3.c:55083:    rc = sqlite3WalSnapshotRecover(pPager->pWal);
vendor/sqlite3.c:55101:  assert( pPager->eState>=PAGER_READER );
vendor/sqlite3.c:55102:  return sqlite3WalFramesize(pPager->pWal);
vendor/sqlite3.c:55891:    return "RECOVER-LOCK";
vendor/sqlite3.c:56817:** in the WAL and can be recovered following a power-loss or hard reset.
vendor/sqlite3.c:56865:    /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
vendor/sqlite3.c:56984:      rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);
vendor/sqlite3.c:56987:          /* IMPLEMENTATION-OF: R-44699-57140 This mode works the same way as
vendor/sqlite3.c:57003:        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);
vendor/sqlite3.c:57991:      rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);
vendor/sqlite3.c:58003:        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);
vendor/sqlite3.c:58408:  /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
vendor/sqlite3.c:58415:  /* IMPLEMENTATION-OF: R-62028-47212 All calls obtain an exclusive 
vendor/sqlite3.c:58419:    /* EVIDENCE-OF: R-10421-19736 If any other process is running a
vendor/sqlite3.c:58422:    ** EVIDENCE-OF: R-53820-33897 Even if there is a busy-handler configured,
vendor/sqlite3.c:58431:  /* IMPLEMENTATION-OF: R-59782-36818 The SQLITE_CHECKPOINT_FULL, RESTART and
vendor/sqlite3.c:58435:  ** EVIDENCE-OF: R-60642-04082 If the writer lock cannot be obtained
vendor/sqlite3.c:58477:    ** performed, then the pager-cache associated with pWal is now
vendor/sqlite3.c:58719:** page, or a pointer-map page.
vendor/sqlite3.c:59021:  u32 iDataVersion;  /* Combines with pBt->pPager->iDataVersion */
vendor/sqlite3.c:59073:**   This feature is included to help prevent writer-starvation.
vendor/sqlite3.c:59083:  u8 incrVacuum;        /* True if incr-vacuum is enabled */
vendor/sqlite3.c:59249:** These macros define the location of the pointer-map entry for a 
vendor/sqlite3.c:59254:** PTRMAP_PAGENO returns the database page number of the pointer-map
vendor/sqlite3.c:59258:** If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
vendor/sqlite3.c:59260:** used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
vendor/sqlite3.c:59352:** Routines to read or write a two- and four-byte big-endian integer values.
vendor/sqlite3.c:59480:  for(pLater=p->pNext; pLater; pLater=pLater->pNext){
vendor/sqlite3.c:59481:    assert( pLater->sharable );
vendor/sqlite3.c:59482:    assert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt );
vendor/sqlite3.c:59483:    assert( !pLater->locked || pLater->wantToLock>0 );
vendor/sqlite3.c:59484:    if( pLater->locked ){
vendor/sqlite3.c:59489:  for(pLater=p->pNext; pLater; pLater=pLater->pNext){
vendor/sqlite3.c:59490:    if( pLater->wantToLock ){
vendor/sqlite3.c:59656:  sqlite3BtreeEnter(pCur->pBtree);
vendor/sqlite3.c:59660:  sqlite3BtreeLeave(pCur->pBtree);
vendor/sqlite3.c:59940:    sqlite3ConnectionBlocked(p->db, pBt->pWriter->db);
vendor/sqlite3.c:59944:  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
vendor/sqlite3.c:59945:    /* The condition (pIter->eLock!=eLock) in the following if(...) 
vendor/sqlite3.c:59948:    **   (eLock==WRITE_LOCK || pIter->eLock==WRITE_LOCK)
vendor/sqlite3.c:59954:    assert( pIter->eLock==READ_LOCK || pIter->eLock==WRITE_LOCK );
vendor/sqlite3.c:59955:    assert( eLock==READ_LOCK || pIter->pBtree==p || pIter->eLock==READ_LOCK);
vendor/sqlite3.c:59956:    if( pIter->pBtree!=p && pIter->iTable==iTab && pIter->eLock!=eLock ){
vendor/sqlite3.c:59957:      sqlite3ConnectionBlocked(p->db, pIter->pBtree->db);
vendor/sqlite3.c:60008:  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
vendor/sqlite3.c:60009:    if( pIter->iTable==iTable && pIter->pBtree==p ){
vendor/sqlite3.c:60142:#define invalidateOverflowCache(pCur) (pCur->curFlags &= ~BTCF_ValidOvfl)
vendor/sqlite3.c:60271:  if( pCur->iPage>=0 ){
vendor/sqlite3.c:60272:    for(i=0; i<pCur->iPage; i++){
vendor/sqlite3.c:60273:      releasePageNotNull(pCur->apPage[i]);
vendor/sqlite3.c:60275:    releasePageNotNull(pCur->pPage);
vendor/sqlite3.c:60276:    pCur->iPage = -1;
vendor/sqlite3.c:60283:** function saves the current cursor key in variables pCur->nKey and
vendor/sqlite3.c:60284:** pCur->pKey. SQLITE_OK is returned if successful or an SQLite error 
vendor/sqlite3.c:60288:** (the rowid) is stored in pCur->nKey and pCur->pKey is left set to
vendor/sqlite3.c:60289:** NULL. If the cursor is open on a non-intkey table, then pCur->pKey is 
vendor/sqlite3.c:60290:** set to point to a malloced buffer pCur->nKey bytes in size containing 
vendor/sqlite3.c:60295:  assert( CURSOR_VALID==pCur->eState );
vendor/sqlite3.c:60296:  assert( 0==pCur->pKey );
vendor/sqlite3.c:60299:  if( pCur->curIntKey ){
vendor/sqlite3.c:60301:    pCur->nKey = sqlite3BtreeIntegerKey(pCur);
vendor/sqlite3.c:60305:    pCur->nKey = sqlite3BtreePayloadSize(pCur);
vendor/sqlite3.c:60306:    pKey = sqlite3Malloc( pCur->nKey );
vendor/sqlite3.c:60308:      rc = sqlite3BtreePayload(pCur, 0, (int)pCur->nKey, pKey);
vendor/sqlite3.c:60310:        pCur->pKey = pKey;
vendor/sqlite3.c:60318:  assert( !pCur->curIntKey || !pCur->pKey );
vendor/sqlite3.c:60332:  assert( CURSOR_VALID==pCur->eState || CURSOR_SKIPNEXT==pCur->eState );
vendor/sqlite3.c:60333:  assert( 0==pCur->pKey );
vendor/sqlite3.c:60336:  if( pCur->eState==CURSOR_SKIPNEXT ){
vendor/sqlite3.c:60337:    pCur->eState = CURSOR_VALID;
vendor/sqlite3.c:60339:    pCur->skipNext = 0;
vendor/sqlite3.c:60345:    pCur->eState = CURSOR_REQUIRESEEK;
vendor/sqlite3.c:60348:  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl|BTCF_AtLast);
vendor/sqlite3.c:60420:  sqlite3_free(pCur->pKey);
vendor/sqlite3.c:60421:  pCur->pKey = 0;
vendor/sqlite3.c:60422:  pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:60442:    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pCur->pKeyInfo);
vendor/sqlite3.c:60444:    sqlite3VdbeRecordUnpack(pCur->pKeyInfo, (int)nKey, pKey, pIdxKey);
vendor/sqlite3.c:60455:    sqlite3DbFree(pCur->pKeyInfo->db, pIdxKey);
vendor/sqlite3.c:60471:  assert( pCur->eState>=CURSOR_REQUIRESEEK );
vendor/sqlite3.c:60472:  if( pCur->eState==CURSOR_FAULT ){
vendor/sqlite3.c:60473:    return pCur->skipNext;
vendor/sqlite3.c:60475:  pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:60476:  rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &skipNext);
vendor/sqlite3.c:60478:    sqlite3_free(pCur->pKey);
vendor/sqlite3.c:60479:    pCur->pKey = 0;
vendor/sqlite3.c:60480:    assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_INVALID );
vendor/sqlite3.c:60481:    pCur->skipNext |= skipNext;
vendor/sqlite3.c:60482:    if( pCur->skipNext && pCur->eState==CURSOR_VALID ){
vendor/sqlite3.c:60483:      pCur->eState = CURSOR_SKIPNEXT;
vendor/sqlite3.c:60507:  return pCur->eState!=CURSOR_VALID;
vendor/sqlite3.c:60538:  assert( pCur->eState!=CURSOR_VALID );
vendor/sqlite3.c:60544:  if( pCur->eState!=CURSOR_VALID ){
vendor/sqlite3.c:60547:    assert( pCur->skipNext==0 );
vendor/sqlite3.c:60569:  pCur->hints = x;
vendor/sqlite3.c:60576:** number for the pointer-map page that contains the entry for the
vendor/sqlite3.c:60617:  /* The master-journal page number must never be used as a pointer map page */
vendor/sqlite3.c:60987:** to an overflow page, insert an entry into the pointer-map
vendor/sqlite3.c:61010:** EVIDENCE-OF: R-44582-60138 SQLite may from time to time reorganize a
vendor/sqlite3.c:61167:    /* EVIDENCE-OF: R-22710-53328 The third and fourth bytes of each
vendor/sqlite3.c:61178:        /* EVIDENCE-OF: R-11498-58022 In a well-formed b-tree page, the total
vendor/sqlite3.c:61235:  /* EVIDENCE-OF: R-29356-02391 If the database uses a 65536-byte page size
vendor/sqlite3.c:61424:    /* EVIDENCE-OF: R-07291-35328 A value of 5 (0x05) means the page is an
vendor/sqlite3.c:61427:    /* EVIDENCE-OF: R-26900-09176 A value of 13 (0x0d) means the page is a
vendor/sqlite3.c:61442:    /* EVIDENCE-OF: R-43316-37308 A value of 2 (0x02) means the page is an
vendor/sqlite3.c:61445:    /* EVIDENCE-OF: R-59615-42828 A value of 10 (0x0a) means the page is a
vendor/sqlite3.c:61454:    /* EVIDENCE-OF: R-47608-56469 Any other value for the b-tree page type is
vendor/sqlite3.c:61494:  /* EVIDENCE-OF: R-28594-02890 The one-byte flag at offset 0 indicating
vendor/sqlite3.c:61507:  /* EVIDENCE-OF: R-58015-48175 The two-byte integer at offset 5 designates
vendor/sqlite3.c:61511:  /* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the
vendor/sqlite3.c:61519:  /* EVIDENCE-OF: R-24089-57979 If a page contains no cells (which is only
vendor/sqlite3.c:61556:  ** EVIDENCE-OF: R-23588-34450 The two-byte integer at offset 1 gives the
vendor/sqlite3.c:61564:      /* EVIDENCE-OF: R-55530-52930 In a well-formed b-tree page, there will
vendor/sqlite3.c:61720:** And if the fetch fails, this routine must decrement pCur->iPage.
vendor/sqlite3.c:61738:  assert( pCur==0 || ppPage==&pCur->pPage );
vendor/sqlite3.c:61739:  assert( pCur==0 || bReadOnly==pCur->curPagerFlags );
vendor/sqlite3.c:61740:  assert( pCur==0 || pCur->iPage>0 );
vendor/sqlite3.c:61764:  if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){
vendor/sqlite3.c:61773:    pCur->iPage--;
vendor/sqlite3.c:61774:    pCur->pPage = pCur->apPage[pCur->iPage];
vendor/sqlite3.c:62063:    /* EVIDENCE-OF: R-51873-39618 The page size for a database file is
vendor/sqlite3.c:62084:      /* EVIDENCE-OF: R-37497-42412 The size of the reserved region is
vendor/sqlite3.c:62165:    /* If the B-Tree was successfully opened, set the pager-cache size to the
vendor/sqlite3.c:62166:    ** default value. Except, when opening on an existing shared pager-cache,
vendor/sqlite3.c:62167:    ** do not change the pager-cache size.
vendor/sqlite3.c:62281:    pCur = pCur->pNext;
vendor/sqlite3.c:62650:    /* EVIDENCE-OF: R-43737-39999 Every valid SQLite database file begins
vendor/sqlite3.c:62698:    /* EVIDENCE-OF: R-15465-20813 The maximum and minimum embedded payload
vendor/sqlite3.c:62707:    /* EVIDENCE-OF: R-51873-39618 The page size for a database file is
vendor/sqlite3.c:62711:    /* EVIDENCE-OF: R-25008-21688 The size of a page is a power of two
vendor/sqlite3.c:62720:    /* EVIDENCE-OF: R-59310-51205 The "reserved space" size in the 1-byte
vendor/sqlite3.c:62724:    ** EVIDENCE-OF: R-37497-42412 The size of the reserved region is
vendor/sqlite3.c:62747:    /* EVIDENCE-OF: R-28312-64704 However, the usable size is not allowed to
vendor/sqlite3.c:62810:  for(pCur=pBt->pCursor; pCur; pCur=pCur->pNext){
vendor/sqlite3.c:62811:    if( (wrOnly==0 || (pCur->curFlags & BTCF_WriteFlag)!=0)
vendor/sqlite3.c:62812:     && pCur->eState!=CURSOR_FAULT ) r++; 
vendor/sqlite3.c:62963:      pBlock = pBt->pWriter->db;
vendor/sqlite3.c:62966:      for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
vendor/sqlite3.c:62967:        if( pIter->pBtree!=p ){
vendor/sqlite3.c:62968:          pBlock = pIter->pBtree->db;
vendor/sqlite3.c:63074:** Set the pointer-map entries for all children of page pPage. Also, if
vendor/sqlite3.c:63458:      ** is either a pointer-map page or the pending-byte page. If one
vendor/sqlite3.c:63628:    p->iDataVersion--;  /* Compensate for pPager->iDataVersion++; */
vendor/sqlite3.c:63929:  pCur->pgnoRoot = (Pgno)iTable;
vendor/sqlite3.c:63930:  pCur->iPage = -1;
vendor/sqlite3.c:63931:  pCur->pKeyInfo = pKeyInfo;
vendor/sqlite3.c:63932:  pCur->pBtree = p;
vendor/sqlite3.c:63933:  pCur->pBt = pBt;
vendor/sqlite3.c:63934:  pCur->curFlags = wrFlag ? BTCF_WriteFlag : 0;
vendor/sqlite3.c:63935:  pCur->curPagerFlags = wrFlag ? 0 : PAGER_GET_READONLY;
vendor/sqlite3.c:63941:      pCur->curFlags |= BTCF_Multiple;
vendor/sqlite3.c:63944:  pCur->pNext = pBt->pCursor;
vendor/sqlite3.c:63946:  pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:63996:  Btree *pBtree = pCur->pBtree;
vendor/sqlite3.c:63998:    BtShared *pBt = pCur->pBt;
vendor/sqlite3.c:64002:      pBt->pCursor = pCur->pNext;
vendor/sqlite3.c:64007:          pPrev->pNext = pCur->pNext;
vendor/sqlite3.c:64015:    sqlite3_free(pCur->aOverflow);
vendor/sqlite3.c:64016:    sqlite3_free(pCur->pKey);
vendor/sqlite3.c:64034:    btreeParseCell(pCur->pPage, pCur->ix, &info);
vendor/sqlite3.c:64035:    assert( CORRUPT_DB || memcmp(&info, &pCur->info, sizeof(info))==0 );
vendor/sqlite3.c:64041:  if( pCur->info.nSize==0 ){
vendor/sqlite3.c:64042:    pCur->curFlags |= BTCF_ValidNKey;
vendor/sqlite3.c:64043:    btreeParseCell(pCur->pPage,pCur->ix,&pCur->info);
vendor/sqlite3.c:64056:  return pCur && pCur->eState==CURSOR_VALID;
vendor/sqlite3.c:64061:  return pCur->eState==CURSOR_VALID;
vendor/sqlite3.c:64072:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64073:  assert( pCur->curIntKey );
vendor/sqlite3.c:64075:  return pCur->info.nKey;
vendor/sqlite3.c:64089:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64091:  return pCur->info.nPayload;
vendor/sqlite3.c:64098:** pointer-map data instead of reading the content of page ovfl to do so. 
vendor/sqlite3.c:64110:** the pointer-map was used to obtain the value for *pPgnoNext), then
vendor/sqlite3.c:64128:  ** autovacuum pointer-map pages. Guess that the next page in 
vendor/sqlite3.c:64241:  MemPage *pPage = pCur->pPage;               /* Btree page of current entry */
vendor/sqlite3.c:64242:  BtShared *pBt = pCur->pBt;                  /* Btree this cursor belongs to */
vendor/sqlite3.c:64249:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64250:  assert( pCur->ix<pPage->nCell );
vendor/sqlite3.c:64254:  aPayload = pCur->info.pPayload;
vendor/sqlite3.c:64255:  assert( offset+amt <= pCur->info.nPayload );
vendor/sqlite3.c:64258:  if( (uptr)(aPayload - pPage->aData) > (pBt->usableSize - pCur->info.nLocal) ){
vendor/sqlite3.c:64261:    **    &aPayload[pCur->info.nLocal] > &pPage->aData[pBt->usableSize]
vendor/sqlite3.c:64268:  if( offset<pCur->info.nLocal ){
vendor/sqlite3.c:64270:    if( a+offset>pCur->info.nLocal ){
vendor/sqlite3.c:64271:      a = pCur->info.nLocal - offset;
vendor/sqlite3.c:64278:    offset -= pCur->info.nLocal;
vendor/sqlite3.c:64286:    nextPage = get4byte(&aPayload[pCur->info.nLocal]);
vendor/sqlite3.c:64295:    if( (pCur->curFlags & BTCF_ValidOvfl)==0 ){
vendor/sqlite3.c:64296:      int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize;
vendor/sqlite3.c:64297:      if( nOvfl>pCur->nOvflAlloc ){
vendor/sqlite3.c:64299:            pCur->aOverflow, nOvfl*2*sizeof(Pgno)
vendor/sqlite3.c:64304:          pCur->nOvflAlloc = nOvfl*2;
vendor/sqlite3.c:64305:          pCur->aOverflow = aNew;
vendor/sqlite3.c:64308:      memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));
vendor/sqlite3.c:64309:      pCur->curFlags |= BTCF_ValidOvfl;
vendor/sqlite3.c:64315:      if( pCur->aOverflow[offset/ovflSize] ){
vendor/sqlite3.c:64317:        nextPage = pCur->aOverflow[iIdx];
vendor/sqlite3.c:64325:      assert( pCur->aOverflow[iIdx]==0
vendor/sqlite3.c:64326:              || pCur->aOverflow[iIdx]==nextPage
vendor/sqlite3.c:64328:      pCur->aOverflow[iIdx] = nextPage;
vendor/sqlite3.c:64337:        assert( pCur->curFlags & BTCF_ValidOvfl );
vendor/sqlite3.c:64338:        assert( pCur->pBtree->db==pBt->db );
vendor/sqlite3.c:64339:        if( pCur->aOverflow[iIdx+1] ){
vendor/sqlite3.c:64340:          nextPage = pCur->aOverflow[iIdx+1];
vendor/sqlite3.c:64436:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64437:  assert( pCur->iPage>=0 && pCur->pPage );
vendor/sqlite3.c:64438:  assert( pCur->ix<pCur->pPage->nCell );
vendor/sqlite3.c:64455:  if ( pCur->eState==CURSOR_INVALID ){
vendor/sqlite3.c:64463:  if( pCur->eState==CURSOR_VALID ){
vendor/sqlite3.c:64496:  assert( pCur!=0 && pCur->iPage>=0 && pCur->pPage);
vendor/sqlite3.c:64497:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64498:  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
vendor/sqlite3.c:64500:  assert( pCur->ix<pCur->pPage->nCell );
vendor/sqlite3.c:64501:  assert( pCur->info.nSize>0 );
vendor/sqlite3.c:64502:  assert( pCur->info.pPayload>pCur->pPage->aData || CORRUPT_DB );
vendor/sqlite3.c:64503:  assert( pCur->info.pPayload<pCur->pPage->aDataEnd ||CORRUPT_DB);
vendor/sqlite3.c:64504:  amt = (int)(pCur->pPage->aDataEnd - pCur->info.pPayload);
vendor/sqlite3.c:64505:  if( pCur->info.nLocal<amt ) amt = pCur->info.nLocal;
vendor/sqlite3.c:64507:  return (void*)pCur->info.pPayload;
vendor/sqlite3.c:64540:  BtShared *pBt = pCur->pBt;
vendor/sqlite3.c:64543:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64544:  assert( pCur->iPage<BTCURSOR_MAX_DEPTH );
vendor/sqlite3.c:64545:  assert( pCur->iPage>=0 );
vendor/sqlite3.c:64546:  if( pCur->iPage>=(BTCURSOR_MAX_DEPTH-1) ){
vendor/sqlite3.c:64549:  pCur->info.nSize = 0;
vendor/sqlite3.c:64550:  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
vendor/sqlite3.c:64551:  pCur->aiIdx[pCur->iPage] = pCur->ix;
vendor/sqlite3.c:64552:  pCur->apPage[pCur->iPage] = pCur->pPage;
vendor/sqlite3.c:64553:  pCur->ix = 0;
vendor/sqlite3.c:64554:  pCur->iPage++;
vendor/sqlite3.c:64555:  return getAndInitPage(pBt, newPgno, &pCur->pPage, pCur, pCur->curPagerFlags);
vendor/sqlite3.c:64583:** pCur->idx is set to the cell index that contains the pointer
vendor/sqlite3.c:64585:** right-most child page then pCur->idx is set to one more than
vendor/sqlite3.c:64591:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64592:  assert( pCur->iPage>0 );
vendor/sqlite3.c:64593:  assert( pCur->pPage );
vendor/sqlite3.c:64595:    pCur->apPage[pCur->iPage-1], 
vendor/sqlite3.c:64596:    pCur->aiIdx[pCur->iPage-1], 
vendor/sqlite3.c:64597:    pCur->pPage->pgno
vendor/sqlite3.c:64599:  testcase( pCur->aiIdx[pCur->iPage-1] > pCur->apPage[pCur->iPage-1]->nCell );
vendor/sqlite3.c:64600:  pCur->info.nSize = 0;
vendor/sqlite3.c:64601:  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
vendor/sqlite3.c:64602:  pCur->ix = pCur->aiIdx[pCur->iPage-1];
vendor/sqlite3.c:64603:  pLeaf = pCur->pPage;
vendor/sqlite3.c:64604:  pCur->pPage = pCur->apPage[--pCur->iPage];
vendor/sqlite3.c:64637:  assert( pCur->eState < CURSOR_REQUIRESEEK || pCur->iPage<0 );
vendor/sqlite3.c:64638:  assert( pCur->pgnoRoot>0 || pCur->iPage<0 );
vendor/sqlite3.c:64640:  if( pCur->iPage>=0 ){
vendor/sqlite3.c:64641:    if( pCur->iPage ){
vendor/sqlite3.c:64642:      releasePageNotNull(pCur->pPage);
vendor/sqlite3.c:64643:      while( --pCur->iPage ){
vendor/sqlite3.c:64644:        releasePageNotNull(pCur->apPage[pCur->iPage]);
vendor/sqlite3.c:64646:      pCur->pPage = pCur->apPage[0];
vendor/sqlite3.c:64649:  }else if( pCur->pgnoRoot==0 ){
vendor/sqlite3.c:64650:    pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:64653:    assert( pCur->iPage==(-1) );
vendor/sqlite3.c:64654:    if( pCur->eState>=CURSOR_REQUIRESEEK ){
vendor/sqlite3.c:64655:      if( pCur->eState==CURSOR_FAULT ){
vendor/sqlite3.c:64656:        assert( pCur->skipNext!=SQLITE_OK );
vendor/sqlite3.c:64657:        return pCur->skipNext;
vendor/sqlite3.c:64661:    rc = getAndInitPage(pCur->pBtree->pBt, pCur->pgnoRoot, &pCur->pPage,
vendor/sqlite3.c:64662:                        0, pCur->curPagerFlags);
vendor/sqlite3.c:64664:      pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:64667:    pCur->iPage = 0;
vendor/sqlite3.c:64668:    pCur->curIntKey = pCur->pPage->intKey;
vendor/sqlite3.c:64670:  pRoot = pCur->pPage;
vendor/sqlite3.c:64671:  assert( pRoot->pgno==pCur->pgnoRoot );
vendor/sqlite3.c:64673:  /* If pCur->pKeyInfo is not NULL, then the caller that opened this cursor
vendor/sqlite3.c:64680:  ** if pCur->iPage>=0). But this is not so if the database is corrupted 
vendor/sqlite3.c:64684:  if( pRoot->isInit==0 || (pCur->pKeyInfo==0)!=pRoot->intKey ){
vendor/sqlite3.c:64685:    return SQLITE_CORRUPT_PGNO(pCur->pPage->pgno);
vendor/sqlite3.c:64689:  pCur->ix = 0;
vendor/sqlite3.c:64690:  pCur->info.nSize = 0;
vendor/sqlite3.c:64691:  pCur->curFlags &= ~(BTCF_AtLast|BTCF_ValidNKey|BTCF_ValidOvfl);
vendor/sqlite3.c:64693:  pRoot = pCur->pPage;
vendor/sqlite3.c:64695:    pCur->eState = CURSOR_VALID;
vendor/sqlite3.c:64700:    pCur->eState = CURSOR_VALID;
vendor/sqlite3.c:64703:    pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:64722:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64723:  while( rc==SQLITE_OK && !(pPage = pCur->pPage)->leaf ){
vendor/sqlite3.c:64724:    assert( pCur->ix<pPage->nCell );
vendor/sqlite3.c:64725:    pgno = get4byte(findCell(pPage, pCur->ix));
vendor/sqlite3.c:64747:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64748:  while( !(pPage = pCur->pPage)->leaf ){
vendor/sqlite3.c:64750:    pCur->ix = pPage->nCell;
vendor/sqlite3.c:64754:  pCur->ix = pPage->nCell-1;
vendor/sqlite3.c:64755:  assert( pCur->info.nSize==0 );
vendor/sqlite3.c:64756:  assert( (pCur->curFlags & BTCF_ValidNKey)==0 );
vendor/sqlite3.c:64768:  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
vendor/sqlite3.c:64771:    assert( pCur->pPage->nCell>0 );
vendor/sqlite3.c:64775:    assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );
vendor/sqlite3.c:64790:  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
vendor/sqlite3.c:64793:  if( CURSOR_VALID==pCur->eState && (pCur->curFlags & BTCF_AtLast)!=0 ){
vendor/sqlite3.c:64798:    for(ii=0; ii<pCur->iPage; ii++){
vendor/sqlite3.c:64799:      assert( pCur->aiIdx[ii]==pCur->apPage[ii]->nCell );
vendor/sqlite3.c:64801:    assert( pCur->ix==pCur->pPage->nCell-1 );
vendor/sqlite3.c:64802:    assert( pCur->pPage->leaf );
vendor/sqlite3.c:64809:    assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64813:      pCur->curFlags |= BTCF_AtLast;
vendor/sqlite3.c:64815:      pCur->curFlags &= ~BTCF_AtLast;
vendor/sqlite3.c:64818:    assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );
vendor/sqlite3.c:64866:  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
vendor/sqlite3.c:64868:  assert( (pIdxKey==0)==(pCur->pKeyInfo==0) );
vendor/sqlite3.c:64869:  assert( pCur->eState!=CURSOR_VALID || (pIdxKey==0)==(pCur->curIntKey!=0) );
vendor/sqlite3.c:64874:   && pCur->eState==CURSOR_VALID && (pCur->curFlags & BTCF_ValidNKey)!=0
vendor/sqlite3.c:64876:    if( pCur->info.nKey==intKey ){
vendor/sqlite3.c:64880:    if( pCur->info.nKey<intKey ){
vendor/sqlite3.c:64881:      if( (pCur->curFlags & BTCF_AtLast)!=0 ){
vendor/sqlite3.c:64889:      if( pCur->info.nKey+1==intKey && !pCur->skipNext ){
vendor/sqlite3.c:64894:          if( pCur->info.nKey==intKey ){
vendor/sqlite3.c:64920:      assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );
vendor/sqlite3.c:64926:  assert( pCur->pPage );
vendor/sqlite3.c:64927:  assert( pCur->pPage->isInit );
vendor/sqlite3.c:64928:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:64929:  assert( pCur->pPage->nCell > 0 );
vendor/sqlite3.c:64930:  assert( pCur->iPage==0 || pCur->apPage[0]->intKey==pCur->curIntKey );
vendor/sqlite3.c:64931:  assert( pCur->curIntKey || pIdxKey );
vendor/sqlite3.c:64935:    MemPage *pPage = pCur->pPage;
vendor/sqlite3.c:64950:    pCur->ix = (u16)idx;
vendor/sqlite3.c:64971:          pCur->ix = (u16)idx;
vendor/sqlite3.c:64976:            pCur->curFlags |= BTCF_ValidNKey;
vendor/sqlite3.c:64977:            pCur->info.nKey = nCellKey;
vendor/sqlite3.c:64978:            pCur->info.nSize = 0;
vendor/sqlite3.c:65025:          pPage->xParseCell(pPage, pCellBody, &pCur->info);
vendor/sqlite3.c:65026:          nCell = (int)pCur->info.nKey;
vendor/sqlite3.c:65040:          pCur->ix = (u16)idx;
vendor/sqlite3.c:65042:          pCur->curFlags &= ~BTCF_ValidOvfl;
vendor/sqlite3.c:65052:         && (pIdxKey->errCode!=SQLITE_NOMEM || pCur->pBtree->db->mallocFailed)
vendor/sqlite3.c:65062:          pCur->ix = (u16)idx;
vendor/sqlite3.c:65074:      assert( pCur->ix<pCur->pPage->nCell );
vendor/sqlite3.c:65075:      pCur->ix = (u16)idx;
vendor/sqlite3.c:65086:    pCur->ix = (u16)lwr;
vendor/sqlite3.c:65091:  pCur->info.nSize = 0;
vendor/sqlite3.c:65092:  assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );
vendor/sqlite3.c:65109:  return (CURSOR_VALID!=pCur->eState);
vendor/sqlite3.c:65122:  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
vendor/sqlite3.c:65127:  if( NEVER(pCur->eState!=CURSOR_VALID) ) return -1;
vendor/sqlite3.c:65128:  if( NEVER(pCur->pPage->leaf==0) ) return -1;
vendor/sqlite3.c:65130:  n = pCur->pPage->nCell;
vendor/sqlite3.c:65131:  for(i=0; i<pCur->iPage; i++){
vendor/sqlite3.c:65132:    n *= pCur->apPage[i]->nCell;
vendor/sqlite3.c:65163:  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
vendor/sqlite3.c:65164:  if( pCur->eState!=CURSOR_VALID ){
vendor/sqlite3.c:65165:    assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );
vendor/sqlite3.c:65170:    if( CURSOR_INVALID==pCur->eState ){
vendor/sqlite3.c:65173:    if( pCur->skipNext ){
vendor/sqlite3.c:65174:      assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
vendor/sqlite3.c:65175:      pCur->eState = CURSOR_VALID;
vendor/sqlite3.c:65176:      if( pCur->skipNext>0 ){
vendor/sqlite3.c:65177:        pCur->skipNext = 0;
vendor/sqlite3.c:65180:      pCur->skipNext = 0;
vendor/sqlite3.c:65184:  pPage = pCur->pPage;
vendor/sqlite3.c:65185:  idx = ++pCur->ix;
vendor/sqlite3.c:65202:      if( pCur->iPage==0 ){
vendor/sqlite3.c:65203:        pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:65207:      pPage = pCur->pPage;
vendor/sqlite3.c:65208:    }while( pCur->ix>=pPage->nCell );
vendor/sqlite3.c:65226:  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
vendor/sqlite3.c:65227:  pCur->info.nSize = 0;
vendor/sqlite3.c:65228:  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);
vendor/sqlite3.c:65229:  if( pCur->eState!=CURSOR_VALID ) return btreeNext(pCur);
vendor/sqlite3.c:65230:  pPage = pCur->pPage;
vendor/sqlite3.c:65231:  if( (++pCur->ix)>=pPage->nCell ){
vendor/sqlite3.c:65232:    pCur->ix--;
vendor/sqlite3.c:65267:  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
vendor/sqlite3.c:65268:  assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );
vendor/sqlite3.c:65269:  assert( pCur->info.nSize==0 );
vendor/sqlite3.c:65270:  if( pCur->eState!=CURSOR_VALID ){
vendor/sqlite3.c:65275:    if( CURSOR_INVALID==pCur->eState ){
vendor/sqlite3.c:65278:    if( pCur->skipNext ){
vendor/sqlite3.c:65279:      assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_SKIPNEXT );
vendor/sqlite3.c:65280:      pCur->eState = CURSOR_VALID;
vendor/sqlite3.c:65281:      if( pCur->skipNext<0 ){
vendor/sqlite3.c:65282:        pCur->skipNext = 0;
vendor/sqlite3.c:65285:      pCur->skipNext = 0;
vendor/sqlite3.c:65289:  pPage = pCur->pPage;
vendor/sqlite3.c:65292:    int idx = pCur->ix;
vendor/sqlite3.c:65297:    while( pCur->ix==0 ){
vendor/sqlite3.c:65298:      if( pCur->iPage==0 ){
vendor/sqlite3.c:65299:        pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:65304:    assert( pCur->info.nSize==0 );
vendor/sqlite3.c:65305:    assert( (pCur->curFlags & (BTCF_ValidOvfl))==0 );
vendor/sqlite3.c:65307:    pCur->ix--;
vendor/sqlite3.c:65308:    pPage = pCur->pPage;
vendor/sqlite3.c:65320:  assert( pCur->skipNext==0 || pCur->eState!=CURSOR_VALID );
vendor/sqlite3.c:65322:  pCur->curFlags &= ~(BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey);
vendor/sqlite3.c:65323:  pCur->info.nSize = 0;
vendor/sqlite3.c:65324:  if( pCur->eState!=CURSOR_VALID
vendor/sqlite3.c:65325:   || pCur->ix==0
vendor/sqlite3.c:65326:   || pCur->pPage->leaf==0
vendor/sqlite3.c:65330:  pCur->ix--;
vendor/sqlite3.c:65375:  /* EVIDENCE-OF: R-05119-02637 The 4-byte big-endian integer at offset 36
vendor/sqlite3.c:65388:    /* If eMode==BTALLOC_EXACT and a query of the pointer-map
vendor/sqlite3.c:65424:        /* EVIDENCE-OF: R-01506-11053 The first integer on a freelist trunk page
vendor/sqlite3.c:65429:        /* EVIDENCE-OF: R-59841-13798 The 4-byte big-endian integer at offset 32
vendor/sqlite3.c:65446:      /* EVIDENCE-OF: R-13523-04394 The second integer on a freelist trunk page
vendor/sqlite3.c:65625:      /* If *pPgno refers to a pointer-map page, allocate two new pages
vendor/sqlite3.c:65627:      ** becomes a new pointer-map page, the second is used by the caller.
vendor/sqlite3.c:65630:      TRACE(("ALLOCATE: %d from end of file (pointer-map page)\n", pBt->nPage));
vendor/sqlite3.c:65716:  /* If the database supports auto-vacuum, write an entry in the pointer-map
vendor/sqlite3.c:65761:      ** EVIDENCE-OF: R-19920-11576 However, newer versions of SQLite still
vendor/sqlite3.c:66024:      Pgno pgnoPtrmap = pgnoOvfl; /* Overflow page pointer-map entry page */
vendor/sqlite3.c:66036:      ** overflow page is being allocated, add an entry to the pointer-map
vendor/sqlite3.c:66040:      ** to the pointer-map. If we write nothing to this pointer-map slot,
vendor/sqlite3.c:66686:** for setting pointer-map entries.
vendor/sqlite3.c:66727:** the pointer-map entries for each child page are updated so that the
vendor/sqlite3.c:66773:    /* If this is an auto-vacuum database, update the pointer-map entries
vendor/sqlite3.c:67192:      r--;
vendor/sqlite3.c:67238:      /* Set the pointer-map entry for the new sibling page. */
vendor/sqlite3.c:67500:    ** sets all pointer-map entries corresponding to database image pages 
vendor/sqlite3.c:67573:** Before returning, all pointer-map entries corresponding to pages 
vendor/sqlite3.c:67642:  const int nMin = pCur->pBt->usableSize * 2 / 3;
vendor/sqlite3.c:67650:    int iPage = pCur->iPage;
vendor/sqlite3.c:67651:    MemPage *pPage = pCur->pPage;
vendor/sqlite3.c:67662:        rc = balance_deeper(pPage, &pCur->apPage[1]);
vendor/sqlite3.c:67664:          pCur->iPage = 1;
vendor/sqlite3.c:67665:          pCur->ix = 0;
vendor/sqlite3.c:67666:          pCur->aiIdx[0] = 0;
vendor/sqlite3.c:67667:          pCur->apPage[0] = pPage;
vendor/sqlite3.c:67668:          pCur->pPage = pCur->apPage[1];
vendor/sqlite3.c:67669:          assert( pCur->pPage->nOverflow );
vendor/sqlite3.c:67677:      MemPage * const pParent = pCur->apPage[iPage-1];
vendor/sqlite3.c:67678:      int const iIdx = pCur->aiIdx[iPage-1];
vendor/sqlite3.c:67725:          u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);
vendor/sqlite3.c:67727:                               pCur->hints&BTREE_BULKLOAD);
vendor/sqlite3.c:67747:      pCur->iPage--;
vendor/sqlite3.c:67748:      assert( pCur->iPage>=0 );
vendor/sqlite3.c:67749:      pCur->pPage = pCur->apPage[pCur->iPage];
vendor/sqlite3.c:67801:  Btree *p = pCur->pBtree;
vendor/sqlite3.c:67808:  if( pCur->eState==CURSOR_FAULT ){
vendor/sqlite3.c:67809:    assert( pCur->skipNext!=SQLITE_OK );
vendor/sqlite3.c:67810:    return pCur->skipNext;
vendor/sqlite3.c:67814:  assert( (pCur->curFlags & BTCF_WriteFlag)!=0
vendor/sqlite3.c:67817:  assert( hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) );
vendor/sqlite3.c:67824:  assert( (pX->pKey==0)==(pCur->pKeyInfo==0) );
vendor/sqlite3.c:67837:  if( pCur->curFlags & BTCF_Multiple ){
vendor/sqlite3.c:67838:    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
vendor/sqlite3.c:67842:  if( pCur->pKeyInfo==0 ){
vendor/sqlite3.c:67846:    invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);
vendor/sqlite3.c:67851:            ((pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey==pCur->info.nKey) );
vendor/sqlite3.c:67856:    if( (pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey==pCur->info.nKey ){
vendor/sqlite3.c:67865:      r.pKeyInfo = pCur->pKeyInfo;
vendor/sqlite3.c:67879:  assert( pCur->eState==CURSOR_VALID || (pCur->eState==CURSOR_INVALID && loc) );
vendor/sqlite3.c:67881:  pPage = pCur->pPage;
vendor/sqlite3.c:67886:          pCur->pgnoRoot, pX->nKey, pX->nData, pPage->pgno,
vendor/sqlite3.c:67895:  idx = pCur->ix;
vendor/sqlite3.c:67919:      ** necessary to add the PTRMAP_OVERFLOW1 pointer-map entry.  */
vendor/sqlite3.c:67929:    idx = ++pCur->ix;
vendor/sqlite3.c:67930:    pCur->curFlags &= ~BTCF_ValidNKey;
vendor/sqlite3.c:67958:  pCur->info.nSize = 0;
vendor/sqlite3.c:67961:    pCur->curFlags &= ~(BTCF_ValidNKey);
vendor/sqlite3.c:67968:    pCur->pPage->nOverflow = 0;
vendor/sqlite3.c:67969:    pCur->eState = CURSOR_INVALID;
vendor/sqlite3.c:67972:      if( pCur->pKeyInfo ){
vendor/sqlite3.c:67973:        assert( pCur->pKey==0 );
vendor/sqlite3.c:67974:        pCur->pKey = sqlite3Malloc( pX->nKey );
vendor/sqlite3.c:67975:        if( pCur->pKey==0 ){
vendor/sqlite3.c:67978:          memcpy(pCur->pKey, pX->pKey, pX->nKey);
vendor/sqlite3.c:67981:      pCur->eState = CURSOR_REQUIRESEEK;
vendor/sqlite3.c:67982:      pCur->nKey = pX->nKey;
vendor/sqlite3.c:67985:  assert( pCur->iPage<0 || pCur->pPage->nOverflow==0 );
vendor/sqlite3.c:68009:  Btree *p = pCur->pBtree;
vendor/sqlite3.c:68023:  assert( pCur->curFlags & BTCF_WriteFlag );
vendor/sqlite3.c:68024:  assert( hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) );
vendor/sqlite3.c:68025:  assert( !hasReadConflicts(p, pCur->pgnoRoot) );
vendor/sqlite3.c:68026:  assert( pCur->ix<pCur->pPage->nCell );
vendor/sqlite3.c:68027:  assert( pCur->eState==CURSOR_VALID );
vendor/sqlite3.c:68030:  iCellDepth = pCur->iPage;
vendor/sqlite3.c:68031:  iCellIdx = pCur->ix;
vendor/sqlite3.c:68032:  pPage = pCur->pPage;
vendor/sqlite3.c:68072:  if( pCur->curFlags & BTCF_Multiple ){
vendor/sqlite3.c:68073:    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
vendor/sqlite3.c:68079:  if( pCur->pKeyInfo==0 ){
vendor/sqlite3.c:68080:    invalidateIncrblobCursors(p, pCur->pgnoRoot, pCur->info.nKey, 0);
vendor/sqlite3.c:68098:    MemPage *pLeaf = pCur->pPage;
vendor/sqlite3.c:68103:    if( iCellDepth<pCur->iPage-1 ){
vendor/sqlite3.c:68104:      n = pCur->apPage[iCellDepth+1]->pgno;
vendor/sqlite3.c:68106:      n = pCur->pPage->pgno;
vendor/sqlite3.c:68138:  if( rc==SQLITE_OK && pCur->iPage>iCellDepth ){
vendor/sqlite3.c:68139:    releasePageNotNull(pCur->pPage);
vendor/sqlite3.c:68140:    pCur->iPage--;
vendor/sqlite3.c:68141:    while( pCur->iPage>iCellDepth ){
vendor/sqlite3.c:68142:      releasePage(pCur->apPage[pCur->iPage--]);
vendor/sqlite3.c:68144:    pCur->pPage = pCur->apPage[pCur->iPage];
vendor/sqlite3.c:68150:      assert( bPreserve && (pCur->iPage==iCellDepth || CORRUPT_DB) );
vendor/sqlite3.c:68151:      assert( pPage==pCur->pPage || CORRUPT_DB );
vendor/sqlite3.c:68153:      pCur->eState = CURSOR_SKIPNEXT;
vendor/sqlite3.c:68155:        pCur->skipNext = -1;
vendor/sqlite3.c:68156:        pCur->ix = pPage->nCell-1;
vendor/sqlite3.c:68158:        pCur->skipNext = 1;
vendor/sqlite3.c:68164:        pCur->eState = CURSOR_REQUIRESEEK;
vendor/sqlite3.c:68218:    /* The new root-page may not be allocated on a pointer-map page, or the
vendor/sqlite3.c:68291:    /* Update the pointer-map and meta-data with the new root-page number. */
vendor/sqlite3.c:68430:  return sqlite3BtreeClearTable(pCur->pBtree, pCur->pgnoRoot, 0);
vendor/sqlite3.c:68648:    pPage = pCur->pPage;
vendor/sqlite3.c:68656:    ** pCur->aiIdx[pCur->iPage] value is set to the index of the parent cell
vendor/sqlite3.c:68665:        if( pCur->iPage==0 ){
vendor/sqlite3.c:68671:      }while ( pCur->ix>=pCur->pPage->nCell );
vendor/sqlite3.c:68673:      pCur->ix++;
vendor/sqlite3.c:68674:      pPage = pCur->pPage;
vendor/sqlite3.c:68680:    iIdx = pCur->ix;
vendor/sqlite3.c:68712:  pCheck->mxErr--;
vendor/sqlite3.c:68773:** Check that the entry in the pointer-map for page iChild maps to 
vendor/sqlite3.c:68857:      ** page in this overflow list, check that the pointer-map entry for
vendor/sqlite3.c:69006:  /* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the
vendor/sqlite3.c:69011:  /* EVIDENCE-OF: R-23882-45353 The cell pointer array of a b-tree page
vendor/sqlite3.c:69035:  /* EVIDENCE-OF: R-02776-14802 The cell pointer array consists of K 2-byte
vendor/sqlite3.c:69123:    ** EVIDENCE-OF: R-20690-50594 The second field of the b-tree page header
vendor/sqlite3.c:69134:      /* EVIDENCE-OF: R-58208-19414 The first 2 bytes of a freeblock are a
vendor/sqlite3.c:69139:      /* EVIDENCE-OF: R-06866-39125 Freeblocks are always connected in order of
vendor/sqlite3.c:69171:    /* EVIDENCE-OF: R-43263-13491 The total number of bytes in all fragments
vendor/sqlite3.c:69173:    ** EVIDENCE-OF: R-07161-27322 The one-byte integer at offset 7 gives the
vendor/sqlite3.c:69288:    ** references to pointer-map pages.
vendor/sqlite3.c:69478:  assert( sqlite3_mutex_held(pCsr->pBtree->db->mutex) );
vendor/sqlite3.c:69479:  assert( pCsr->curFlags & BTCF_Incrblob );
vendor/sqlite3.c:69485:  assert( pCsr->eState!=CURSOR_REQUIRESEEK );
vendor/sqlite3.c:69486:  if( pCsr->eState!=CURSOR_VALID ){
vendor/sqlite3.c:69498:  VVA_ONLY(rc =) saveAllCursors(pCsr->pBt, pCsr->pgnoRoot, pCsr);
vendor/sqlite3.c:69508:  if( (pCsr->curFlags & BTCF_WriteFlag)==0 ){
vendor/sqlite3.c:69511:  assert( (pCsr->pBt->btsFlags & BTS_READ_ONLY)==0
vendor/sqlite3.c:69512:              && pCsr->pBt->inTransaction==TRANS_WRITE );
vendor/sqlite3.c:69513:  assert( hasSharedCacheTableLock(pCsr->pBtree, pCsr->pgnoRoot, 0, 2) );
vendor/sqlite3.c:69514:  assert( !hasReadConflicts(pCsr->pBtree, pCsr->pgnoRoot) );
vendor/sqlite3.c:69515:  assert( pCsr->pPage->intKey );
vendor/sqlite3.c:69524:  pCur->curFlags |= BTCF_Incrblob;
vendor/sqlite3.c:69525:  pCur->pBtree->hasIncrblobCur = 1;
vendor/sqlite3.c:69570:  return (pCsr->hints & mask)!=0;
vendor/sqlite3.c:69779:    ** EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a
vendor/sqlite3.c:70246:    /* EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a
vendor/sqlite3.c:70774:    pFunc->xFinalize(&ctx); /* IMP: R-24505-23230 */
vendor/sqlite3.c:71489:    sqlite3VdbeMemNulTerminate(pVal); /* IMP: R-31275-44060 */
vendor/sqlite3.c:71509:** (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.
vendor/sqlite3.c:71733:  while( (op = pExpr->op)==TK_UPLUS || op==TK_SPAN ) pExpr = pExpr->pLeft;
vendor/sqlite3.c:71734:  if( NEVER(op==TK_REGISTER) ) op = pExpr->op2;
vendor/sqlite3.c:71740:  assert( (pExpr->flags & EP_TokenOnly)==0 || pCtx==0 );
vendor/sqlite3.c:71743:    u8 aff = sqlite3AffinityType(pExpr->u.zToken,0);
vendor/sqlite3.c:71744:    rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
vendor/sqlite3.c:71757:   && (pExpr->pLeft->op==TK_INTEGER || pExpr->pLeft->op==TK_FLOAT) ){
vendor/sqlite3.c:71758:    pExpr = pExpr->pLeft;
vendor/sqlite3.c:71759:    op = pExpr->op;
vendor/sqlite3.c:71768:      sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);
vendor/sqlite3.c:71770:      zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);
vendor/sqlite3.c:71785:    if( SQLITE_OK==valueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal,pCtx) 
vendor/sqlite3.c:71807:    assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );
vendor/sqlite3.c:71808:    assert( pExpr->u.zToken[1]=='\'' );
vendor/sqlite3.c:71811:    zVal = &pExpr->u.zToken[2];
vendor/sqlite3.c:71942:  assert( pExpr==0 || pExpr->op!=TK_REGISTER || pExpr->op2!=TK_VARIABLE );
vendor/sqlite3.c:71948:  }else if( pExpr->op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){
vendor/sqlite3.c:71950:    int iBindVar = pExpr->iColumn;
vendor/sqlite3.c:71955:        rc = sqlite3VdbeMemCopy((Mem*)pVal, &v->aVar[iBindVar-1]);
vendor/sqlite3.c:72015:  if( pExpr==0 || pExpr->op!=TK_SELECT ){
vendor/sqlite3.c:73417:  switch( pExpr->op ){
vendor/sqlite3.c:73419:      sqlite3XPrintf(p, "%Q", pExpr->u.zToken);
vendor/sqlite3.c:73422:      sqlite3XPrintf(p, "%d", pExpr->u.iValue);
vendor/sqlite3.c:73428:      sqlite3XPrintf(p, "r[%d]", pExpr->iTable);
vendor/sqlite3.c:73432:      if( pExpr->iColumn<0 ){
vendor/sqlite3.c:73435:        sqlite3XPrintf(p, "c%d", (int)pExpr->iColumn);
vendor/sqlite3.c:73473:    displayP4Expr(p, pExpr->pLeft);
vendor/sqlite3.c:73474:    if( pExpr->pRight ){
vendor/sqlite3.c:73476:      displayP4Expr(p, pExpr->pRight);
vendor/sqlite3.c:74252:      const sqlite3_module *pModule = pVCur->pVtab->pModule;
vendor/sqlite3.c:74253:      assert( pVCur->pVtab->nRef>0 );
vendor/sqlite3.c:74254:      pVCur->pVtab->nRef--;
vendor/sqlite3.c:74399:                   ** master-journal */
vendor/sqlite3.c:74466:  ** master-journal.
vendor/sqlite3.c:75582:    /* EVIDENCE-OF: R-29851-52272 Value is a big-endian 64-bit
vendor/sqlite3.c:75588:    /* EVIDENCE-OF: R-57343-49114 Value is a big-endian IEEE 754-2008 64-bit
vendor/sqlite3.c:75618:      /* EVIDENCE-OF: R-24078-09375 Value is a NULL. */
vendor/sqlite3.c:75623:      /* EVIDENCE-OF: R-44885-25196 Value is an 8-bit twos-complement
vendor/sqlite3.c:75631:      /* EVIDENCE-OF: R-49794-35026 Value is a big-endian 16-bit
vendor/sqlite3.c:75639:      /* EVIDENCE-OF: R-37839-54301 Value is a big-endian 24-bit
vendor/sqlite3.c:75647:      /* EVIDENCE-OF: R-01849-26079 Value is a big-endian 32-bit
vendor/sqlite3.c:75659:      /* EVIDENCE-OF: R-50385-09674 Value is a big-endian 48-bit
vendor/sqlite3.c:75674:      /* EVIDENCE-OF: R-12976-22893 Value is the integer 0. */
vendor/sqlite3.c:75675:      /* EVIDENCE-OF: R-18143-12121 Value is the integer 1. */
vendor/sqlite3.c:75681:      /* EVIDENCE-OF: R-14606-31564 Value is a BLOB that is (N-12)/2 bytes in
vendor/sqlite3.c:75683:      ** EVIDENCE-OF: R-28401-00140 Value is a string in the text encoding and
vendor/sqlite3.c:76605:  (void)getVarint32((u8*)&m.z[szHdr-1], typeRowid);
vendor/sqlite3.c:76703:** programs obsolete.  Removing user-defined functions or collating
vendor/sqlite3.c:76739:    Mem *pMem = &v->aVar[iVar-1];
vendor/sqlite3.c:76764:    v->expmask |= ((u32)1 << (iVar-1));
vendor/sqlite3.c:76864:  assert( pCsr->nField==pTab->nCol 
vendor/sqlite3.c:76865:       || (pCsr->nField==pTab->nCol+1 && op==SQLITE_DELETE && iReg==-1)
vendor/sqlite3.c:76888:    for(i=0; i<pCsr->nField; i++){
vendor/sqlite3.c:76997:    /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
vendor/sqlite3.c:77126:/* EVIDENCE-OF: R-12793-43283 Every value in SQLite has one of five
vendor/sqlite3.c:77199:** The following routines are used by user-defined functions to specify
vendor/sqlite3.c:77634:** IMPLEMENTATION-OF: R-46798-50301 The sqlite3_context_db_handle() interface
vendor/sqlite3.c:77729:** the user-function defined by pCtx.
vendor/sqlite3.c:77756:** argument to the user-function defined by pCtx. Any previous value is
vendor/sqlite3.c:78187:  pVar->flags = MEM_Null;
vendor/sqlite3.c:78193:  ** IMPLEMENTATION-OF: R-48440-37595 If the specific value bound to host
vendor/sqlite3.c:78645:  if( iIdx>=p->pCsr->nField || iIdx<0 ){
vendor/sqlite3.c:78655:    nRec = sqlite3BtreePayloadSize(p->pCsr->uc.pCursor);
vendor/sqlite3.c:78658:    rc = sqlite3BtreePayload(p->pCsr->uc.pCursor, 0, nRec, aRec);
vendor/sqlite3.c:78733:  if( iIdx>=p->pCsr->nField || iIdx<0 ){
vendor/sqlite3.c:78767:      p->aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem) * p->pCsr->nField);
vendor/sqlite3.c:78773:    assert( iIdx>=0 && iIdx<p->pCsr->nField );
vendor/sqlite3.c:78993:      if( pVar->flags & MEM_Null ){
vendor/sqlite3.c:78995:      }else if( pVar->flags & MEM_Int ){
vendor/sqlite3.c:78996:        sqlite3XPrintf(&out, "%lld", pVar->u.i);
vendor/sqlite3.c:78997:      }else if( pVar->flags & MEM_Real ){
vendor/sqlite3.c:78998:        sqlite3XPrintf(&out, "%!.15g", pVar->u.r);
vendor/sqlite3.c:78999:      }else if( pVar->flags & MEM_Str ){
vendor/sqlite3.c:79006:          sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, SQLITE_STATIC);
vendor/sqlite3.c:79014:        nOut = pVar->n;
vendor/sqlite3.c:79018:          while( nOut<pVar->n && (pVar->z[nOut]&0xc0)==0x80 ){ nOut++; }
vendor/sqlite3.c:79021:        sqlite3XPrintf(&out, "'%.*q'", nOut, pVar->z);
vendor/sqlite3.c:79023:        if( nOut<pVar->n ){
vendor/sqlite3.c:79024:          sqlite3XPrintf(&out, "/*+%d bytes*/", pVar->n-nOut);
vendor/sqlite3.c:79030:      }else if( pVar->flags & MEM_Zero ){
vendor/sqlite3.c:79031:        sqlite3XPrintf(&out, "zeroblob(%d)", pVar->u.nZero);
vendor/sqlite3.c:79034:        assert( pVar->flags & MEM_Blob );
vendor/sqlite3.c:79036:        nOut = pVar->n;
vendor/sqlite3.c:79041:          sqlite3XPrintf(&out, "%02x", pVar->z[i]&0xff);
vendor/sqlite3.c:79045:        if( nOut<pVar->n ){
vendor/sqlite3.c:79046:          sqlite3XPrintf(&out, "/*+%d bytes*/", pVar->n-nOut);
vendor/sqlite3.c:80019:  assert( pCaller->opcode==OP_Yield );
vendor/sqlite3.c:80020:  assert( pCaller->p2>=0 && pCaller->p2<p->nOp );
vendor/sqlite3.c:80021:  pOp = &aOp[pCaller->p2 - 1];
vendor/sqlite3.c:81855:  ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 | 
vendor/sqlite3.c:81863:  ** hdr-size field is also a varint which is the offset from the beginning
vendor/sqlite3.c:81930:  /* EVIDENCE-OF: R-22564-11647 The header begins with a single varint
vendor/sqlite3.c:81967:    /* EVIDENCE-OF: R-06529-47362 Following the size varint are one or more
vendor/sqlite3.c:81970:    /* EVIDENCE-OF: R-64536-51728 The values for each column in the record
vendor/sqlite3.c:82337:    ** IMPLEMENTATION-OF: R-03189-51135 As each SQL statement runs, the schema
vendor/sqlite3.c:82521:  if( pCur && pCur->pgnoRoot==(u32)pOp->p2 ){
vendor/sqlite3.c:82522:    assert( pCur->iDb==pOp->p3 );      /* Guaranteed by the code generator */
vendor/sqlite3.c:82586:  pCur->nullRow = 1;
vendor/sqlite3.c:82587:  pCur->isOrdered = 1;
vendor/sqlite3.c:82588:  pCur->pgnoRoot = p2;
vendor/sqlite3.c:82590:  pCur->wrFlag = wrFlag;
vendor/sqlite3.c:82592:  rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);
vendor/sqlite3.c:82593:  pCur->pKeyInfo = pKeyInfo;
vendor/sqlite3.c:82598:  pCur->isTable = pOp->p4type!=P4_KEYINFO;
vendor/sqlite3.c:82607:  sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,
vendor/sqlite3.c:83414:        v = 1;   /* IMP: R-61914-48074 */
vendor/sqlite3.c:83421:          v++;   /* IMP: R-29538-34987 */
vendor/sqlite3.c:83447:        rc = SQLITE_FULL;   /* IMP: R-17817-00630 */
vendor/sqlite3.c:83457:      /* IMPLEMENTATION-OF: R-07677-41881 If the largest ROWID is equal to the
vendor/sqlite3.c:83473:        rc = SQLITE_FULL;   /* IMP: R-38219-53002 */
vendor/sqlite3.c:83476:      assert( v>0 );  /* EV: R-40812-03570 */
vendor/sqlite3.c:83917:    pVtab = pC->uc.pVCur->pVtab;
vendor/sqlite3.c:84408:      assert( pTabCur->eCurType==CURTYPE_BTREE );
vendor/sqlite3.c:84409:      assert( pTabCur->uc.pCursor!=0 );
vendor/sqlite3.c:84410:      assert( pTabCur->isTable );
vendor/sqlite3.c:84411:      pTabCur->nullRow = 0;
vendor/sqlite3.c:84412:      pTabCur->movetoTarget = rowid;
vendor/sqlite3.c:84413:      pTabCur->deferredMoveto = 1;
vendor/sqlite3.c:84415:      pTabCur->aAltMap = pOp->p4.ai;
vendor/sqlite3.c:84416:      pTabCur->pAltCursor = pC;
vendor/sqlite3.c:84827:  assert( (pnErr->flags & MEM_Int)!=0 );
vendor/sqlite3.c:84828:  assert( (pnErr->flags & (MEM_Str|MEM_Blob))==0 );
vendor/sqlite3.c:84833:                                 (int)pnErr->u.i+1, &nErr);
vendor/sqlite3.c:84840:    pnErr->u.i -= nErr-1;
vendor/sqlite3.c:85359:  (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); /* IMP: R-24505-23230 */
vendor/sqlite3.c:85737:  pVCur->pVtab = pVtab;
vendor/sqlite3.c:85742:    pCur->uc.pVCur = pVCur;
vendor/sqlite3.c:85791:  assert( pCur->eCurType==CURTYPE_VTAB );
vendor/sqlite3.c:85792:  pVCur = pCur->uc.pVCur;
vendor/sqlite3.c:85793:  pVtab = pVCur->pVtab;
vendor/sqlite3.c:85811:  pCur->nullRow = 0;
vendor/sqlite3.c:85833:  assert( pCur->eCurType==CURTYPE_VTAB );
vendor/sqlite3.c:85837:  if( pCur->nullRow ){
vendor/sqlite3.c:85841:  pVtab = pCur->uc.pVCur->pVtab;
vendor/sqlite3.c:85847:  rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);
vendor/sqlite3.c:85879:  assert( pCur->eCurType==CURTYPE_VTAB );
vendor/sqlite3.c:85880:  if( pCur->nullRow ){
vendor/sqlite3.c:85883:  pVtab = pCur->uc.pVCur->pVtab;
vendor/sqlite3.c:85893:  rc = pModule->xNext(pCur->uc.pVCur);
vendor/sqlite3.c:85896:  res = pModule->xEof(pCur->uc.pVCur);
vendor/sqlite3.c:86149:  (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);/* IMP: R-24505-23230 */
vendor/sqlite3.c:86199:  ** EVIDENCE-OF: R-50676-09860 The callback can compute the same text that
vendor/sqlite3.c:87377:  sqlite3_free(pReadr->aAlloc);
vendor/sqlite3.c:87378:  sqlite3_free(pReadr->aBuffer);
vendor/sqlite3.c:87379:  if( pReadr->aMap ) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
vendor/sqlite3.c:87380:  vdbeIncrFree(pReadr->pIncr);
vendor/sqlite3.c:87494:    if( iBuf && (p->nBuffer-iBuf)>=9 ){
vendor/sqlite3.c:87522:  if( pFile->iEof<=(i64)(pTask->pSorter->db->nMaxSorterMmap) ){
vendor/sqlite3.c:87545:  assert( pReadr->pIncr==0 || pReadr->pIncr->bEof==0 );
vendor/sqlite3.c:87548:  if( pReadr->aMap ){
vendor/sqlite3.c:87549:    sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
vendor/sqlite3.c:87550:    pReadr->aMap = 0;
vendor/sqlite3.c:87552:  pReadr->iReadOff = iOff;
vendor/sqlite3.c:87553:  pReadr->iEof = pFile->iEof;
vendor/sqlite3.c:87554:  pReadr->pFd = pFile->pFd;
vendor/sqlite3.c:87556:  rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);
vendor/sqlite3.c:87557:  if( rc==SQLITE_OK && pReadr->aMap==0 ){
vendor/sqlite3.c:87558:    int pgsz = pTask->pSorter->pgsz;
vendor/sqlite3.c:87559:    int iBuf = pReadr->iReadOff % pgsz;
vendor/sqlite3.c:87560:    if( pReadr->aBuffer==0 ){
vendor/sqlite3.c:87561:      pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);
vendor/sqlite3.c:87562:      if( pReadr->aBuffer==0 ) rc = SQLITE_NOMEM_BKPT;
vendor/sqlite3.c:87563:      pReadr->nBuffer = pgsz;
vendor/sqlite3.c:87567:      if( (pReadr->iReadOff + nRead) > pReadr->iEof ){
vendor/sqlite3.c:87568:        nRead = (int)(pReadr->iEof - pReadr->iReadOff);
vendor/sqlite3.c:87571:          pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff
vendor/sqlite3.c:87589:  if( pReadr->iReadOff>=pReadr->iEof ){
vendor/sqlite3.c:87590:    IncrMerger *pIncr = pReadr->pIncr;
vendor/sqlite3.c:87594:      if( rc==SQLITE_OK && pIncr->bEof==0 ){
vendor/sqlite3.c:87596:            pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff
vendor/sqlite3.c:87614:    pReadr->nKey = (int)nRec;
vendor/sqlite3.c:87615:    rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);
vendor/sqlite3.c:87641:  assert( pReadr->aAlloc==0 && pReadr->nAlloc==0 );
vendor/sqlite3.c:87642:  assert( pReadr->aBuffer==0 );
vendor/sqlite3.c:87643:  assert( pReadr->aMap==0 );
vendor/sqlite3.c:87649:    pReadr->iEof = pReadr->iReadOff + nByte;
vendor/sqlite3.c:87672:    sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
vendor/sqlite3.c:87699:    sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
vendor/sqlite3.c:87733:    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
vendor/sqlite3.c:87739:    if( pTask->pSorter->pKeyInfo->aSortOrder[0] ){
vendor/sqlite3.c:87802:    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
vendor/sqlite3.c:87807:  }else if( pTask->pSorter->pKeyInfo->aSortOrder[0] ){
vendor/sqlite3.c:87817:** Usually, the sorter module uses the value of (pCsr->pKeyInfo->nKeyField)
vendor/sqlite3.c:87841:  KeyInfo *pKeyInfo;              /* Copy of pCsr->pKeyInfo with db==0 */
vendor/sqlite3.c:87842:  int szKeyInfo;                  /* Size of pCsr->pKeyInfo in bytes */
vendor/sqlite3.c:87868:  assert( pCsr->pKeyInfo && pCsr->pBtx==0 );
vendor/sqlite3.c:87869:  assert( pCsr->eCurType==CURTYPE_SORTER );
vendor/sqlite3.c:87870:  szKeyInfo = sizeof(KeyInfo) + (pCsr->pKeyInfo->nKeyField-1)*sizeof(CollSeq*);
vendor/sqlite3.c:87874:  pCsr->uc.pSorter = pSorter;
vendor/sqlite3.c:87878:    pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);
vendor/sqlite3.c:87879:    memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
vendor/sqlite3.c:87884:    pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(db->aDb[0].pBt);
vendor/sqlite3.c:87885:    pSorter->nTask = nWorker + 1;
vendor/sqlite3.c:87886:    pSorter->iPrev = (u8)(nWorker - 1);
vendor/sqlite3.c:87887:    pSorter->bUseThreads = (pSorter->nTask>1);
vendor/sqlite3.c:87888:    pSorter->db = db;
vendor/sqlite3.c:87889:    for(i=0; i<pSorter->nTask; i++){
vendor/sqlite3.c:87890:      SortSubtask *pTask = &pSorter->aTask[i];
vendor/sqlite3.c:87897:      pSorter->mnPmaSize = szPma * pgsz;
vendor/sqlite3.c:87908:      pSorter->mxPmaSize = MAX(pSorter->mnPmaSize, (int)mxCache);
vendor/sqlite3.c:87913:        assert( pSorter->iMemory==0 );
vendor/sqlite3.c:87914:        pSorter->nMemory = pgsz;
vendor/sqlite3.c:87915:        pSorter->list.aMemory = (u8*)sqlite3Malloc(pgsz);
vendor/sqlite3.c:87916:        if( !pSorter->list.aMemory ) rc = SQLITE_NOMEM_BKPT;
vendor/sqlite3.c:87923:      pSorter->typeMask = SORTER_TYPE_INTEGER | SORTER_TYPE_TEXT;
vendor/sqlite3.c:87972:  int iTask = (pTask - pTask->pSorter->aTask);
vendor/sqlite3.c:87973:  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
vendor/sqlite3.c:87986:  int iTask = (pTask - pTask->pSorter->aTask);
vendor/sqlite3.c:87987:  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
vendor/sqlite3.c:87997:    sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
vendor/sqlite3.c:88053:  ** it is possible that thread pSorter->aTask[pSorter->nTask-1].pThread
vendor/sqlite3.c:88056:  ** thread pSorter->aTask[pSorter->nTask-1].pThread first. */
vendor/sqlite3.c:88057:  for(i=pSorter->nTask-1; i>=0; i--){
vendor/sqlite3.c:88058:    SortSubtask *pTask = &pSorter->aTask[i];
vendor/sqlite3.c:88102:    for(i=0; i<pMerger->nTree; i++){
vendor/sqlite3.c:88103:      vdbePmaReaderClear(&pMerger->aReadr[i]);
vendor/sqlite3.c:88116:    if( pIncr->bUseThread ){
vendor/sqlite3.c:88117:      vdbeSorterJoinThread(pIncr->pTask);
vendor/sqlite3.c:88118:      if( pIncr->aFile[0].pFd ) sqlite3OsCloseFree(pIncr->aFile[0].pFd);
vendor/sqlite3.c:88119:      if( pIncr->aFile[1].pFd ) sqlite3OsCloseFree(pIncr->aFile[1].pFd);
vendor/sqlite3.c:88122:    vdbeMergeEngineFree(pIncr->pMerger);
vendor/sqlite3.c:88133:  assert( pSorter->bUseThreads || pSorter->pReader==0 );
vendor/sqlite3.c:88135:  if( pSorter->pReader ){
vendor/sqlite3.c:88136:    vdbePmaReaderClear(pSorter->pReader);
vendor/sqlite3.c:88137:    sqlite3DbFree(db, pSorter->pReader);
vendor/sqlite3.c:88138:    pSorter->pReader = 0;
vendor/sqlite3.c:88141:  vdbeMergeEngineFree(pSorter->pMerger);
vendor/sqlite3.c:88142:  pSorter->pMerger = 0;
vendor/sqlite3.c:88143:  for(i=0; i<pSorter->nTask; i++){
vendor/sqlite3.c:88144:    SortSubtask *pTask = &pSorter->aTask[i];
vendor/sqlite3.c:88148:  if( pSorter->list.aMemory==0 ){
vendor/sqlite3.c:88149:    vdbeSorterRecordFree(0, pSorter->list.pList);
vendor/sqlite3.c:88151:  pSorter->list.pList = 0;
vendor/sqlite3.c:88152:  pSorter->list.szPMA = 0;
vendor/sqlite3.c:88153:  pSorter->bUsePMA = 0;
vendor/sqlite3.c:88154:  pSorter->iMemory = 0;
vendor/sqlite3.c:88155:  pSorter->mxKeysize = 0;
vendor/sqlite3.c:88156:  sqlite3DbFree(db, pSorter->pUnpacked);
vendor/sqlite3.c:88157:  pSorter->pUnpacked = 0;
vendor/sqlite3.c:88165:  assert( pCsr->eCurType==CURTYPE_SORTER );
vendor/sqlite3.c:88166:  pSorter = pCsr->uc.pSorter;
vendor/sqlite3.c:88169:    sqlite3_free(pSorter->list.aMemory);
vendor/sqlite3.c:88171:    pCsr->uc.pSorter = 0;
vendor/sqlite3.c:88233:    pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask->pSorter->pKeyInfo);
vendor/sqlite3.c:88235:    pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nKeyField;
vendor/sqlite3.c:88453:  sqlite3 *db = pTask->pSorter->db;
vendor/sqlite3.c:88489:    vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,
vendor/sqlite3.c:88521:  int iPrev = pMerger->aTree[1];/* Index of PmaReader to advance */
vendor/sqlite3.c:88522:  SortSubtask *pTask = pMerger->pTask;
vendor/sqlite3.c:88525:  rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);
vendor/sqlite3.c:88536:    pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];
vendor/sqlite3.c:88537:    pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];
vendor/sqlite3.c:88539:    for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){
vendor/sqlite3.c:88568:        pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);
vendor/sqlite3.c:88569:        pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
vendor/sqlite3.c:88573:        pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);
vendor/sqlite3.c:88574:        pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
vendor/sqlite3.c:88577:    *pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd==0);
vendor/sqlite3.c:88603:  pSorter->bUsePMA = 1;
vendor/sqlite3.c:88604:  return vdbeSorterListToPMA(&pSorter->aTask[0], &pSorter->list);
vendor/sqlite3.c:88609:  int nWorker = (pSorter->nTask-1);
vendor/sqlite3.c:88613:  pSorter->bUsePMA = 1;
vendor/sqlite3.c:88617:  ** round-robin between the first (pSorter->nTask-1) tasks. Except, if
vendor/sqlite3.c:88619:  ** skip it. If the first (pSorter->nTask-1) sub-tasks are all still busy,
vendor/sqlite3.c:88620:  ** fall back to using the final sub-task. The first (pSorter->nTask-1)
vendor/sqlite3.c:88624:    int iTest = (pSorter->iPrev + i + 1) % nWorker;
vendor/sqlite3.c:88625:    pTask = &pSorter->aTask[iTest];
vendor/sqlite3.c:88635:      rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);
vendor/sqlite3.c:88643:      assert( pTask->list.aMemory==0 || pSorter->list.aMemory!=0 );
vendor/sqlite3.c:88645:      pSorter->iPrev = (u8)(pTask - pSorter->aTask);
vendor/sqlite3.c:88646:      pTask->list = pSorter->list;
vendor/sqlite3.c:88647:      pSorter->list.pList = 0;
vendor/sqlite3.c:88648:      pSorter->list.szPMA = 0;
vendor/sqlite3.c:88650:        pSorter->list.aMemory = aMem;
vendor/sqlite3.c:88651:        pSorter->nMemory = sqlite3MallocSize(aMem);
vendor/sqlite3.c:88652:      }else if( pSorter->list.aMemory ){
vendor/sqlite3.c:88653:        pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);
vendor/sqlite3.c:88654:        if( !pSorter->list.aMemory ) return SQLITE_NOMEM_BKPT;
vendor/sqlite3.c:88680:  assert( pCsr->eCurType==CURTYPE_SORTER );
vendor/sqlite3.c:88681:  pSorter = pCsr->uc.pSorter;
vendor/sqlite3.c:88684:    pSorter->typeMask &= SORTER_TYPE_INTEGER;
vendor/sqlite3.c:88686:    pSorter->typeMask &= SORTER_TYPE_TEXT;
vendor/sqlite3.c:88688:    pSorter->typeMask = 0;
vendor/sqlite3.c:88696:  ** If using the single large allocation mode (pSorter->aMemory!=0), then
vendor/sqlite3.c:88711:  if( pSorter->mxPmaSize ){
vendor/sqlite3.c:88712:    if( pSorter->list.aMemory ){
vendor/sqlite3.c:88713:      bFlush = pSorter->iMemory && (pSorter->iMemory+nReq) > pSorter->mxPmaSize;
vendor/sqlite3.c:88716:          (pSorter->list.szPMA > pSorter->mxPmaSize)
vendor/sqlite3.c:88717:       || (pSorter->list.szPMA > pSorter->mnPmaSize && sqlite3HeapNearlyFull())
vendor/sqlite3.c:88722:      pSorter->list.szPMA = 0;
vendor/sqlite3.c:88723:      pSorter->iMemory = 0;
vendor/sqlite3.c:88724:      assert( rc!=SQLITE_OK || pSorter->list.pList==0 );
vendor/sqlite3.c:88728:  pSorter->list.szPMA += nPMA;
vendor/sqlite3.c:88729:  if( nPMA>pSorter->mxKeysize ){
vendor/sqlite3.c:88730:    pSorter->mxKeysize = nPMA;
vendor/sqlite3.c:88733:  if( pSorter->list.aMemory ){
vendor/sqlite3.c:88734:    int nMin = pSorter->iMemory + nReq;
vendor/sqlite3.c:88736:    if( nMin>pSorter->nMemory ){
vendor/sqlite3.c:88738:      int iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;
vendor/sqlite3.c:88739:      int nNew = pSorter->nMemory * 2;
vendor/sqlite3.c:88741:      if( nNew > pSorter->mxPmaSize ) nNew = pSorter->mxPmaSize;
vendor/sqlite3.c:88744:      aNew = sqlite3Realloc(pSorter->list.aMemory, nNew);
vendor/sqlite3.c:88746:      pSorter->list.pList = (SorterRecord*)&aNew[iListOff];
vendor/sqlite3.c:88747:      pSorter->list.aMemory = aNew;
vendor/sqlite3.c:88748:      pSorter->nMemory = nNew;
vendor/sqlite3.c:88751:    pNew = (SorterRecord*)&pSorter->list.aMemory[pSorter->iMemory];
vendor/sqlite3.c:88752:    pSorter->iMemory += ROUND8(nReq);
vendor/sqlite3.c:88753:    if( pSorter->list.pList ){
vendor/sqlite3.c:88754:      pNew->u.iNext = (int)((u8*)(pSorter->list.pList) - pSorter->list.aMemory);
vendor/sqlite3.c:88761:    pNew->u.pNext = pSorter->list.pList;
vendor/sqlite3.c:88766:  pSorter->list.pList = pNew;
vendor/sqlite3.c:88772:** Read keys from pIncr->pMerger and populate pIncr->aFile[1]. The format
vendor/sqlite3.c:88774:** except that the number-of-bytes varint is omitted from the start.
vendor/sqlite3.c:88779:  i64 iStart = pIncr->iStartOff;
vendor/sqlite3.c:88780:  SorterFile *pOut = &pIncr->aFile[1];
vendor/sqlite3.c:88781:  SortSubtask *pTask = pIncr->pTask;
vendor/sqlite3.c:88782:  MergeEngine *pMerger = pIncr->pMerger;
vendor/sqlite3.c:88784:  assert( pIncr->bEof==0 );
vendor/sqlite3.c:88788:  vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);
vendor/sqlite3.c:88791:    PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];
vendor/sqlite3.c:88792:    int nKey = pReader->nKey;
vendor/sqlite3.c:88797:    if( pReader->pFd==0 ) break;
vendor/sqlite3.c:88798:    if( (iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz) ) break;
vendor/sqlite3.c:88802:    vdbePmaWriteBlob(&writer, pReader->aKey, nKey);
vendor/sqlite3.c:88803:    assert( pIncr->pMerger->pTask==pTask );
vendor/sqlite3.c:88804:    rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);
vendor/sqlite3.c:88821:  pIncr->pTask->bDone = 1;
vendor/sqlite3.c:88830:  assert( pIncr->bUseThread );
vendor/sqlite3.c:88831:  return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p);
vendor/sqlite3.c:88842:** keys from pIncr->pMerger and repopulating aFile[0]. 
vendor/sqlite3.c:88856:  if( pIncr->bUseThread ){
vendor/sqlite3.c:88857:    rc = vdbeSorterJoinThread(pIncr->pTask);
vendor/sqlite3.c:88860:      SorterFile f0 = pIncr->aFile[0];
vendor/sqlite3.c:88861:      pIncr->aFile[0] = pIncr->aFile[1];
vendor/sqlite3.c:88862:      pIncr->aFile[1] = f0;
vendor/sqlite3.c:88866:      if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
vendor/sqlite3.c:88867:        pIncr->bEof = 1;
vendor/sqlite3.c:88876:    pIncr->aFile[0] = pIncr->aFile[1];
vendor/sqlite3.c:88877:    if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
vendor/sqlite3.c:88878:      pIncr->bEof = 1;
vendor/sqlite3.c:88900:    pIncr->pMerger = pMerger;
vendor/sqlite3.c:88901:    pIncr->pTask = pTask;
vendor/sqlite3.c:88902:    pIncr->mxSz = MAX(pTask->pSorter->mxKeysize+9,pTask->pSorter->mxPmaSize/2);
vendor/sqlite3.c:88903:    pTask->file2.iEof += pIncr->mxSz;
vendor/sqlite3.c:88916:  pIncr->bUseThread = 1;
vendor/sqlite3.c:88917:  pIncr->pTask->file2.iEof -= pIncr->mxSz;
vendor/sqlite3.c:88924:** Recompute pMerger->aTree[iOut] by comparing the next keys on the
vendor/sqlite3.c:88930:  int iOut               /* Store the result in pMerger->aTree[iOut] */
vendor/sqlite3.c:88938:  assert( iOut<pMerger->nTree && iOut>0 );
vendor/sqlite3.c:88940:  if( iOut>=(pMerger->nTree/2) ){
vendor/sqlite3.c:88941:    i1 = (iOut - pMerger->nTree/2) * 2;
vendor/sqlite3.c:88944:    i1 = pMerger->aTree[iOut*2];
vendor/sqlite3.c:88945:    i2 = pMerger->aTree[iOut*2+1];
vendor/sqlite3.c:88948:  p1 = &pMerger->aReadr[i1];
vendor/sqlite3.c:88949:  p2 = &pMerger->aReadr[i2];
vendor/sqlite3.c:88956:    SortSubtask *pTask = pMerger->pTask;
vendor/sqlite3.c:88970:  pMerger->aTree[iOut] = iRes;
vendor/sqlite3.c:89017:  int nTree = pMerger->nTree;
vendor/sqlite3.c:89023:  assert( pMerger->pTask==0 );
vendor/sqlite3.c:89024:  pMerger->pTask = pTask;
vendor/sqlite3.c:89035:      rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);
vendor/sqlite3.c:89037:      rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], INCRINIT_NORMAL);
vendor/sqlite3.c:89042:  for(i=pMerger->nTree-1; i>0; i--){
vendor/sqlite3.c:89050:** incremental-reader (pReadr->pIncr!=0). This function serves to open
vendor/sqlite3.c:89052:** object at (pReadr->pIncr).
vendor/sqlite3.c:89074:** that pReadr->pIncr is a multi-threaded IncrMerge objects, and that all
vendor/sqlite3.c:89083:  IncrMerger *pIncr = pReadr->pIncr;
vendor/sqlite3.c:89084:  SortSubtask *pTask = pIncr->pTask;
vendor/sqlite3.c:89085:  sqlite3 *db = pTask->pSorter->db;
vendor/sqlite3.c:89090:  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);
vendor/sqlite3.c:89096:    int mxSz = pIncr->mxSz;
vendor/sqlite3.c:89098:    if( pIncr->bUseThread ){
vendor/sqlite3.c:89099:      rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);
vendor/sqlite3.c:89101:        rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);
vendor/sqlite3.c:89105:    /*if( !pIncr->bUseThread )*/{
vendor/sqlite3.c:89112:        pIncr->aFile[1].pFd = pTask->file2.pFd;
vendor/sqlite3.c:89113:        pIncr->iStartOff = pTask->file2.iEof;
vendor/sqlite3.c:89120:  if( rc==SQLITE_OK && pIncr->bUseThread ){
vendor/sqlite3.c:89124:    ** pIncr->pTask->thread. 
vendor/sqlite3.c:89153:  pReader->pIncr->pTask->bDone = 1;
vendor/sqlite3.c:89160:** (if pReadr->pIncr==0), then this function is a no-op. Otherwise, it invokes
vendor/sqlite3.c:89170:  IncrMerger *pIncr = pReadr->pIncr;   /* Incremental merger */
vendor/sqlite3.c:89174:    assert( pIncr->bUseThread==0 || eMode==INCRINIT_TASK );
vendor/sqlite3.c:89175:    if( pIncr->bUseThread ){
vendor/sqlite3.c:89177:      rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);
vendor/sqlite3.c:89217:    iOff = pReadr->iEof;
vendor/sqlite3.c:89279:    if( pReadr->pIncr==0 ){
vendor/sqlite3.c:89284:        rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);
vendor/sqlite3.c:89288:      p = pReadr->pIncr->pMerger;
vendor/sqlite3.c:89324:  assert( pSorter->bUseThreads || pSorter->nTask==1 );
vendor/sqlite3.c:89325:  if( pSorter->nTask>1 ){
vendor/sqlite3.c:89326:    pMain = vdbeMergeEngineNew(pSorter->nTask);
vendor/sqlite3.c:89331:  for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){
vendor/sqlite3.c:89332:    SortSubtask *pTask = &pSorter->aTask[iTask];
vendor/sqlite3.c:89393:  SortSubtask *pTask0 = &pSorter->aTask[0];
vendor/sqlite3.c:89396:  sqlite3 *db = pTask0->pSorter->db;
vendor/sqlite3.c:89399:  for(i=0; i<pSorter->nTask; i++){
vendor/sqlite3.c:89400:    pSorter->aTask[i].xCompare = xCompare;
vendor/sqlite3.c:89407:    assert( pSorter->bUseThreads==0 || pSorter->nTask>1 );
vendor/sqlite3.c:89408:    if( pSorter->bUseThreads ){
vendor/sqlite3.c:89411:      SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];
vendor/sqlite3.c:89415:        pSorter->pReader = pReadr;
vendor/sqlite3.c:89419:        rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);
vendor/sqlite3.c:89421:          vdbeIncrMergerSetThreads(pReadr->pIncr);
vendor/sqlite3.c:89422:          for(iTask=0; iTask<(pSorter->nTask-1); iTask++){
vendor/sqlite3.c:89426:              assert( pIncr->pTask!=pLast );
vendor/sqlite3.c:89429:          for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){
vendor/sqlite3.c:89441:                (p->pIncr->pTask==&pSorter->aTask[iTask])             /* a */
vendor/sqlite3.c:89442:             && (iTask!=pSorter->nTask-1 || p->pIncr->bUseThread==0)  /* b */
vendor/sqlite3.c:89456:      pSorter->pMerger = pMain;
vendor/sqlite3.c:89477:  assert( pCsr->eCurType==CURTYPE_SORTER );
vendor/sqlite3.c:89478:  pSorter = pCsr->uc.pSorter;
vendor/sqlite3.c:89484:  if( pSorter->bUsePMA==0 ){
vendor/sqlite3.c:89485:    if( pSorter->list.pList ){
vendor/sqlite3.c:89487:      rc = vdbeSorterSort(&pSorter->aTask[0], &pSorter->list);
vendor/sqlite3.c:89498:  assert( pSorter->list.pList );
vendor/sqlite3.c:89508:  assert( pSorter->pReader==0 );
vendor/sqlite3.c:89529:  assert( pCsr->eCurType==CURTYPE_SORTER );
vendor/sqlite3.c:89530:  pSorter = pCsr->uc.pSorter;
vendor/sqlite3.c:89531:  assert( pSorter->bUsePMA || (pSorter->pReader==0 && pSorter->pMerger==0) );
vendor/sqlite3.c:89532:  if( pSorter->bUsePMA ){
vendor/sqlite3.c:89533:    assert( pSorter->pReader==0 || pSorter->pMerger==0 );
vendor/sqlite3.c:89534:    assert( pSorter->bUseThreads==0 || pSorter->pReader );
vendor/sqlite3.c:89535:    assert( pSorter->bUseThreads==1 || pSorter->pMerger );
vendor/sqlite3.c:89537:    if( pSorter->bUseThreads ){
vendor/sqlite3.c:89538:      rc = vdbePmaReaderNext(pSorter->pReader);
vendor/sqlite3.c:89539:      if( rc==SQLITE_OK && pSorter->pReader->pFd==0 ) rc = SQLITE_DONE;
vendor/sqlite3.c:89542:    /*if( !pSorter->bUseThreads )*/ {
vendor/sqlite3.c:89544:      assert( pSorter->pMerger!=0 );
vendor/sqlite3.c:89545:      assert( pSorter->pMerger->pTask==(&pSorter->aTask[0]) );
vendor/sqlite3.c:89546:      rc = vdbeMergeEngineStep(pSorter->pMerger, &res);
vendor/sqlite3.c:89550:    SorterRecord *pFree = pSorter->list.pList;
vendor/sqlite3.c:89551:    pSorter->list.pList = pFree->u.pNext;
vendor/sqlite3.c:89553:    if( pSorter->list.aMemory==0 ) vdbeSorterRecordFree(db, pFree);
vendor/sqlite3.c:89554:    rc = pSorter->list.pList ? SQLITE_OK : SQLITE_DONE;
vendor/sqlite3.c:89568:  if( pSorter->bUsePMA ){
vendor/sqlite3.c:89571:    if( pSorter->bUseThreads ){
vendor/sqlite3.c:89572:      pReader = pSorter->pReader;
vendor/sqlite3.c:89575:    /*if( !pSorter->bUseThreads )*/{
vendor/sqlite3.c:89576:      pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];
vendor/sqlite3.c:89578:    *pnKey = pReader->nKey;
vendor/sqlite3.c:89579:    pKey = pReader->aKey;
vendor/sqlite3.c:89581:    *pnKey = pSorter->list.pList->nVal;
vendor/sqlite3.c:89582:    pKey = SRVAL(pSorter->list.pList);
vendor/sqlite3.c:89594:  assert( pCsr->eCurType==CURTYPE_SORTER );
vendor/sqlite3.c:89595:  pSorter = pCsr->uc.pSorter;
vendor/sqlite3.c:89635:  assert( pCsr->eCurType==CURTYPE_SORTER );
vendor/sqlite3.c:89636:  pSorter = pCsr->uc.pSorter;
vendor/sqlite3.c:89637:  r2 = pSorter->pUnpacked;
vendor/sqlite3.c:89638:  pKeyInfo = pCsr->pKeyInfo;
vendor/sqlite3.c:89640:    r2 = pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
vendor/sqlite3.c:89678:** smaller journals that are not critical for power-loss recovery.
vendor/sqlite3.c:89803:    pNext = pIter->pNext;
vendor/sqlite3.c:89823:    for(pIter=copy.pFirst; pIter; pIter=pIter->pNext){
vendor/sqlite3.c:89827:      rc = sqlite3OsWrite(pReal, (u8*)pIter->zChunk, nChunk, iOff);
vendor/sqlite3.c:90141:    rc = pWalker->xExprCallback(pWalker, pExpr);
vendor/sqlite3.c:90144:      if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;
vendor/sqlite3.c:90145:       assert( pExpr->x.pList==0 || pExpr->pRight==0 );
vendor/sqlite3.c:90146:      if( pExpr->pRight ){
vendor/sqlite3.c:90147:        pExpr = pExpr->pRight;
vendor/sqlite3.c:90150:        if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return WRC_Abort;
vendor/sqlite3.c:90151:      }else if( pExpr->x.pList ){
vendor/sqlite3.c:90152:        if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;
vendor/sqlite3.c:90243:  if( pWalker->xSelectCallback==0 ) return WRC_Continue;
vendor/sqlite3.c:90245:    rc = pWalker->xSelectCallback(pWalker, p);
vendor/sqlite3.c:90252:    if( pWalker->xSelectCallback2 ){
vendor/sqlite3.c:90253:      pWalker->xSelectCallback2(pWalker, p);
vendor/sqlite3.c:90290:  if( pExpr->op==TK_AGG_FUNCTION ) pExpr->op2 += pWalker->u.n;
vendor/sqlite3.c:90325:  int iCol,              /* A column in the result set.  0..pEList->nExpr-1 */
vendor/sqlite3.c:90341:  if( pExpr->op==TK_COLLATE ){
vendor/sqlite3.c:90342:    pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);
vendor/sqlite3.c:90349:  ** The pExpr->u.zToken might point into memory that will be freed by the
vendor/sqlite3.c:90356:  if( !ExprHasProperty(pExpr, EP_IntValue) && pExpr->u.zToken!=0 ){
vendor/sqlite3.c:90357:    assert( (pExpr->flags & (EP_Reduced|EP_TokenOnly))==0 );
vendor/sqlite3.c:90358:    pExpr->u.zToken = sqlite3DbStrDup(db, pExpr->u.zToken);
vendor/sqlite3.c:90359:    pExpr->flags |= EP_MemToken;
vendor/sqlite3.c:90417:**    pExpr->iDb           Set the index in db->aDb[] of the database X
vendor/sqlite3.c:90419:**    pExpr->iTable        Set to the cursor number for the table obtained
vendor/sqlite3.c:90421:**    pExpr->pTab          Points to the Table structure of X.Y (even if
vendor/sqlite3.c:90423:**    pExpr->iColumn       Set to the column number within the table.
vendor/sqlite3.c:90424:**    pExpr->op            Set to TK_COLUMN.
vendor/sqlite3.c:90425:**    pExpr->pLeft         Any expression this points to is deleted
vendor/sqlite3.c:90426:**    pExpr->pRight        Any expression this points to is deleted.
vendor/sqlite3.c:90464:  pExpr->iTable = -1;
vendor/sqlite3.c:90465:  pExpr->pTab = 0;
vendor/sqlite3.c:90492:  /* Start at the inner-most context and move outward until a match is found */
vendor/sqlite3.c:90511:              pExpr->iColumn = j;
vendor/sqlite3.c:90543:            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;
vendor/sqlite3.c:90549:        pExpr->iTable = pMatch->iCursor;
vendor/sqlite3.c:90550:        pExpr->pTab = pMatch->pTab;
vendor/sqlite3.c:90556:        pSchema = pExpr->pTab->pSchema;
vendor/sqlite3.c:90568:        pExpr->iTable = 1;
vendor/sqlite3.c:90571:        pExpr->iTable = 0;
vendor/sqlite3.c:90590:          /* IMP: R-51414-32910 */
vendor/sqlite3.c:90596:            pExpr->affinity = SQLITE_AFF_INTEGER;
vendor/sqlite3.c:90597:          }else if( pExpr->iTable==0 ){
vendor/sqlite3.c:90606:          pExpr->iColumn = (i16)iCol;
vendor/sqlite3.c:90607:          pExpr->pTab = pTab;
vendor/sqlite3.c:90625:      pExpr->iColumn = -1;
vendor/sqlite3.c:90626:      pExpr->affinity = SQLITE_AFF_INTEGER;
vendor/sqlite3.c:90655:          assert( pExpr->pLeft==0 && pExpr->pRight==0 );
vendor/sqlite3.c:90656:          assert( pExpr->x.pList==0 );
vendor/sqlite3.c:90657:          assert( pExpr->x.pSelect==0 );
vendor/sqlite3.c:90696:    pExpr->op = TK_STRING;
vendor/sqlite3.c:90697:    pExpr->pTab = 0;
vendor/sqlite3.c:90725:  if( pExpr->iColumn>=0 && pMatch!=0 ){
vendor/sqlite3.c:90726:    int n = pExpr->iColumn;
vendor/sqlite3.c:90731:    assert( pMatch->iCursor==pExpr->iTable );
vendor/sqlite3.c:90737:  sqlite3ExprDelete(db, pExpr->pLeft);
vendor/sqlite3.c:90738:  pExpr->pLeft = 0;
vendor/sqlite3.c:90739:  sqlite3ExprDelete(db, pExpr->pRight);
vendor/sqlite3.c:90740:  pExpr->pRight = 0;
vendor/sqlite3.c:90741:  pExpr->op = (isTrigger ? TK_TRIGGER : TK_COLUMN);
vendor/sqlite3.c:90835:  pNC = pWalker->u.pNC;
vendor/sqlite3.c:90838:  assert( pParse==pWalker->pParse );
vendor/sqlite3.c:90849:  switch( pExpr->op ){
vendor/sqlite3.c:90861:      pExpr->op = TK_COLUMN;
vendor/sqlite3.c:90862:      pExpr->pTab = pItem->pTab;
vendor/sqlite3.c:90863:      pExpr->iTable = pItem->iCursor;
vendor/sqlite3.c:90864:      pExpr->iColumn = -1;
vendor/sqlite3.c:90865:      pExpr->affinity = SQLITE_AFF_INTEGER;
vendor/sqlite3.c:90886:      if( pExpr->op==TK_ID ){
vendor/sqlite3.c:90889:        zColumn = pExpr->u.zToken;
vendor/sqlite3.c:90892:        pRight = pExpr->pRight;
vendor/sqlite3.c:90895:          zTable = pExpr->pLeft->u.zToken;
vendor/sqlite3.c:90899:          zDb = pExpr->pLeft->u.zToken;
vendor/sqlite3.c:90910:      ExprList *pList = pExpr->x.pList;    /* The argument list */
vendor/sqlite3.c:90921:      zId = pExpr->u.zToken;
vendor/sqlite3.c:90936:            pExpr->iTable = exprProbability(pList->a[1].pExpr);
vendor/sqlite3.c:90937:            if( pExpr->iTable<0 ){
vendor/sqlite3.c:90944:            /* EVIDENCE-OF: R-61304-29449 The unlikely(X) function is
vendor/sqlite3.c:90946:            ** EVIDENCE-OF: R-01283-11636 The unlikely(X) function is
vendor/sqlite3.c:90948:            ** EVIDENCE-OF: R-36850-34127 The likely(X) function is short-hand
vendor/sqlite3.c:90950:            ** EVIDENCE-OF: R-53436-40973 The likely(X) function is equivalent
vendor/sqlite3.c:90953:            pExpr->iTable = pDef->zName[0]=='u' ? 8388608 : 125829120;
vendor/sqlite3.c:90965:            pExpr->op = TK_NULL;
vendor/sqlite3.c:91004:        pExpr->op = TK_AGG_FUNCTION;
vendor/sqlite3.c:91005:        pExpr->op2 = 0;
vendor/sqlite3.c:91007:          pExpr->op2++;
vendor/sqlite3.c:91019:      /* FIX ME:  Compute pExpr->affinity based on the expected return
vendor/sqlite3.c:91026:    case TK_EXISTS:  testcase( pExpr->op==TK_EXISTS );
vendor/sqlite3.c:91029:      testcase( pExpr->op==TK_IN );
vendor/sqlite3.c:91033:        sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
vendor/sqlite3.c:91057:      assert( pExpr->pLeft!=0 );
vendor/sqlite3.c:91058:      nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
vendor/sqlite3.c:91059:      if( pExpr->op==TK_BETWEEN ){
vendor/sqlite3.c:91060:        nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[0].pExpr);
vendor/sqlite3.c:91062:          nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[1].pExpr);
vendor/sqlite3.c:91065:        assert( pExpr->pRight!=0 );
vendor/sqlite3.c:91066:        nRight = sqlite3ExprVectorSize(pExpr->pRight);
vendor/sqlite3.c:91069:        testcase( pExpr->op==TK_EQ );
vendor/sqlite3.c:91070:        testcase( pExpr->op==TK_NE );
vendor/sqlite3.c:91071:        testcase( pExpr->op==TK_LT );
vendor/sqlite3.c:91072:        testcase( pExpr->op==TK_LE );
vendor/sqlite3.c:91073:        testcase( pExpr->op==TK_GT );
vendor/sqlite3.c:91074:        testcase( pExpr->op==TK_GE );
vendor/sqlite3.c:91075:        testcase( pExpr->op==TK_IS );
vendor/sqlite3.c:91076:        testcase( pExpr->op==TK_ISNOT );
vendor/sqlite3.c:91077:        testcase( pExpr->op==TK_BETWEEN );
vendor/sqlite3.c:91234:    pSelect->pPrior->pNext = pSelect;
vendor/sqlite3.c:91347:** If the order-by term is an integer I between 1 and N (where N is the
vendor/sqlite3.c:91350:** the order-by term is an identifier that corresponds to the AS-name of
vendor/sqlite3.c:91391:      ** order-by term to a copy of the result-set expression */
vendor/sqlite3.c:91433:  pOuterNC = pWalker->u.pNC;
vendor/sqlite3.c:91434:  pParse = pWalker->pParse;
vendor/sqlite3.c:91701:  w.pParse->nHeight += pExpr->nHeight;
vendor/sqlite3.c:91708:  w.pParse->nHeight -= pExpr->nHeight;
vendor/sqlite3.c:91847:  if( pExpr->flags & EP_Generic ) return 0;
vendor/sqlite3.c:91848:  op = pExpr->op;
vendor/sqlite3.c:91850:    assert( pExpr->flags&EP_xIsSelect );
vendor/sqlite3.c:91851:    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
vendor/sqlite3.c:91853:  if( op==TK_REGISTER ) op = pExpr->op2;
vendor/sqlite3.c:91857:    return sqlite3AffinityType(pExpr->u.zToken, 0);
vendor/sqlite3.c:91860:  if( (op==TK_AGG_COLUMN || op==TK_COLUMN) && pExpr->pTab ){
vendor/sqlite3.c:91861:    return sqlite3TableColumnAffinity(pExpr->pTab, pExpr->iColumn);
vendor/sqlite3.c:91864:    assert( pExpr->pLeft->flags&EP_xIsSelect );
vendor/sqlite3.c:91866:        pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr
vendor/sqlite3.c:91869:  return pExpr->affinity;
vendor/sqlite3.c:91911:      assert( pExpr->x.pList->nExpr>0 );
vendor/sqlite3.c:91912:      assert( pExpr->op==TK_FUNCTION );
vendor/sqlite3.c:91913:      pExpr = pExpr->x.pList->a[0].pExpr;
vendor/sqlite3.c:91915:      assert( pExpr->op==TK_COLLATE );
vendor/sqlite3.c:91916:      pExpr = pExpr->pLeft;
vendor/sqlite3.c:92055:  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||
vendor/sqlite3.c:92056:          pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||
vendor/sqlite3.c:92057:          pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );
vendor/sqlite3.c:92058:  assert( pExpr->pLeft );
vendor/sqlite3.c:92059:  aff = sqlite3ExprAffinity(pExpr->pLeft);
vendor/sqlite3.c:92060:  if( pExpr->pRight ){
vendor/sqlite3.c:92061:    aff = sqlite3CompareAffinity(pExpr->pRight, aff);
vendor/sqlite3.c:92063:    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);
vendor/sqlite3.c:92174:  u8 op = pExpr->op;
vendor/sqlite3.c:92175:  if( op==TK_REGISTER ) op = pExpr->op2;
vendor/sqlite3.c:92177:    return pExpr->x.pList->nExpr;
vendor/sqlite3.c:92179:    return pExpr->x.pSelect->pEList->nExpr;
vendor/sqlite3.c:92203:    assert( pVector->op2==0 || pVector->op==TK_REGISTER );
vendor/sqlite3.c:92204:    if( pVector->op==TK_SELECT || pVector->op2==TK_SELECT ){
vendor/sqlite3.c:92205:      return pVector->x.pSelect->pEList->a[i].pExpr;
vendor/sqlite3.c:92207:      return pVector->x.pList->a[i].pExpr;
vendor/sqlite3.c:92240:  if( pVector->op==TK_SELECT ){
vendor/sqlite3.c:92241:    assert( pVector->flags & EP_xIsSelect );
vendor/sqlite3.c:92265:    if( pVector->op==TK_VECTOR ) pVector = pVector->x.pList->a[iField].pExpr;
vendor/sqlite3.c:92282:  if( pExpr->op==TK_SELECT ){
vendor/sqlite3.c:92315:  u8 op = pVector->op;
vendor/sqlite3.c:92319:    return pVector->iTable+iField;
vendor/sqlite3.c:92322:    *ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;
vendor/sqlite3.c:92325:  *ppExpr = pVector->x.pList->a[iField].pExpr;
vendor/sqlite3.c:92336:**    if pExpr->op==TK_IS:      op==TK_EQ and p5==SQLITE_NULLEQ
vendor/sqlite3.c:92337:**    if pExpr->op==TK_ISNOT:   op==TK_NE and p5==SQLITE_NULLEQ
vendor/sqlite3.c:92338:**    otherwise:                op==pExpr->op and p5==0
vendor/sqlite3.c:92348:  Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:92349:  Expr *pRight = pExpr->pRight;
vendor/sqlite3.c:92361:  assert( pExpr->op==TK_EQ || pExpr->op==TK_NE 
vendor/sqlite3.c:92362:       || pExpr->op==TK_IS || pExpr->op==TK_ISNOT 
vendor/sqlite3.c:92363:       || pExpr->op==TK_LT || pExpr->op==TK_GT 
vendor/sqlite3.c:92364:       || pExpr->op==TK_LE || pExpr->op==TK_GE 
vendor/sqlite3.c:92366:  assert( pExpr->op==op || (pExpr->op==TK_IS && op==TK_EQ)
vendor/sqlite3.c:92367:            || (pExpr->op==TK_ISNOT && op==TK_NE) );
vendor/sqlite3.c:92368:  assert( p5==0 || pExpr->op!=op );
vendor/sqlite3.c:92369:  assert( p5==SQLITE_NULLEQ || pExpr->op==op );
vendor/sqlite3.c:92679:    pExpr->x.pSelect = pSelect;
vendor/sqlite3.c:92782:  z = pExpr->u.zToken;
vendor/sqlite3.c:92834:  pExpr->iColumn = x;
vendor/sqlite3.c:92897:** The dupedExprStructSize() function returns two values OR-ed together:  
vendor/sqlite3.c:93145:     && pOldExpr->op==TK_SELECT_COLUMN
vendor/sqlite3.c:93148:      assert( pNewExpr->iColumn==0 || i>0 );
vendor/sqlite3.c:93149:      if( pNewExpr->iColumn==0 ){
vendor/sqlite3.c:93150:        assert( pOldExpr->pLeft==pOldExpr->pRight );
vendor/sqlite3.c:93151:        pPriorSelectCol = pNewExpr->pLeft = pNewExpr->pRight;
vendor/sqlite3.c:93155:        assert( pNewExpr->iColumn==pItem[-1].pExpr->iColumn+1 );
vendor/sqlite3.c:93156:        assert( pPriorSelectCol==pItem[-1].pExpr->pLeft );
vendor/sqlite3.c:93157:        pNewExpr->pLeft = pPriorSelectCol;
vendor/sqlite3.c:93316:  }else if( (pList->nExpr & (pList->nExpr-1))==0 ){
vendor/sqlite3.c:93370:  if( pExpr->op!=TK_SELECT && pColumns->nId!=(n=sqlite3ExprVectorSize(pExpr)) ){
vendor/sqlite3.c:93381:      pList->a[pList->nExpr-1].zName = pColumns->a[i].zName;
vendor/sqlite3.c:93386:  if( !db->mallocFailed && pExpr->op==TK_SELECT && ALWAYS(pList!=0) ){
vendor/sqlite3.c:93415:    assert( p->a[p->nExpr-1].sortOrder==SQLITE_SO_ASC );
vendor/sqlite3.c:93418:  p->a[p->nExpr-1].sortOrder = (u8)iSortOrder;
vendor/sqlite3.c:93439:    pItem = &pList->a[pList->nExpr-1];
vendor/sqlite3.c:93462:    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];
vendor/sqlite3.c:93518:     m |= pExpr->flags;
vendor/sqlite3.c:93526:** pWalker->eCode to zero and abort.
vendor/sqlite3.c:93532:  pWalker->eCode = 0;
vendor/sqlite3.c:93544:**     sqlite3ExprIsConstant()                  pWalker->eCode==1
vendor/sqlite3.c:93545:**     sqlite3ExprIsConstantNotJoin()           pWalker->eCode==2
vendor/sqlite3.c:93546:**     sqlite3ExprIsTableConstant()             pWalker->eCode==3
vendor/sqlite3.c:93547:**     sqlite3ExprIsConstantOrFunction()        pWalker->eCode==4 or 5
vendor/sqlite3.c:93563:  /* If pWalker->eCode is 2 then any term of the expression that comes from
vendor/sqlite3.c:93566:  if( pWalker->eCode==2 && ExprHasProperty(pExpr, EP_FromJoin) ){
vendor/sqlite3.c:93567:    pWalker->eCode = 0;
vendor/sqlite3.c:93571:  switch( pExpr->op ){
vendor/sqlite3.c:93573:    ** and either pWalker->eCode==4 or 5 or the function has the
vendor/sqlite3.c:93576:      if( pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_ConstFunc) ){
vendor/sqlite3.c:93579:        pWalker->eCode = 0;
vendor/sqlite3.c:93586:      testcase( pExpr->op==TK_ID );
vendor/sqlite3.c:93587:      testcase( pExpr->op==TK_COLUMN );
vendor/sqlite3.c:93588:      testcase( pExpr->op==TK_AGG_FUNCTION );
vendor/sqlite3.c:93589:      testcase( pExpr->op==TK_AGG_COLUMN );
vendor/sqlite3.c:93590:      if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){
vendor/sqlite3.c:93595:      testcase( pExpr->op==TK_IF_NULL_ROW );
vendor/sqlite3.c:93596:      pWalker->eCode = 0;
vendor/sqlite3.c:93599:      if( pWalker->eCode==5 ){
vendor/sqlite3.c:93603:        pExpr->op = TK_NULL;
vendor/sqlite3.c:93604:      }else if( pWalker->eCode==4 ){
vendor/sqlite3.c:93607:        pWalker->eCode = 0;
vendor/sqlite3.c:93612:      testcase( pExpr->op==TK_SELECT ); /* sqlite3SelectWalkFail will disallow */
vendor/sqlite3.c:93613:      testcase( pExpr->op==TK_EXISTS ); /* sqlite3SelectWalkFail will disallow */
vendor/sqlite3.c:93667:  ExprList *pGroupBy = pWalker->u.pGroupBy;
vendor/sqlite3.c:93675:      CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);
vendor/sqlite3.c:93684:    pWalker->eCode = 0;
vendor/sqlite3.c:93700:** assumes that no other collating sequence will have a finer-grained
vendor/sqlite3.c:94093:    if( nExpr==1 && pEList->a[0].pExpr->iColumn<0 ){
vendor/sqlite3.c:94113:        int iCol = pEList->a[i].pExpr->iColumn;
vendor/sqlite3.c:94263:  Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:94265:  Select *pSelect = (pExpr->flags & EP_xIsSelect) ? pExpr->x.pSelect : 0;
vendor/sqlite3.c:94268:  assert( pExpr->op==TK_IN );
vendor/sqlite3.c:94313:  if( pExpr->flags & EP_xIsSelect ){
vendor/sqlite3.c:94314:    sqlite3SubselectError(pParse, pExpr->x.pSelect->pEList->nExpr, 1);
vendor/sqlite3.c:94382:        pExpr->op==TK_IN?"LIST":"SCALAR",
vendor/sqlite3.c:94389:  switch( pExpr->op ){
vendor/sqlite3.c:94392:      Expr *pLeft = pExpr->pLeft; /* the LHS of the IN operator */
vendor/sqlite3.c:94412:      pExpr->iTable = pParse->nTab++;
vendor/sqlite3.c:94414:          pExpr->iTable, (isRowid?0:nVal));
vendor/sqlite3.c:94423:        Select *pSelect = pExpr->x.pSelect;
vendor/sqlite3.c:94432:          sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);
vendor/sqlite3.c:94454:      }else if( ALWAYS(pExpr->x.pList!=0) ){
vendor/sqlite3.c:94464:        ExprList *pList = pExpr->x.pList;
vendor/sqlite3.c:94474:          pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
vendor/sqlite3.c:94497:            sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);
vendor/sqlite3.c:94504:              sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);
vendor/sqlite3.c:94508:              sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);
vendor/sqlite3.c:94541:      testcase( pExpr->op==TK_EXISTS );
vendor/sqlite3.c:94542:      testcase( pExpr->op==TK_SELECT );
vendor/sqlite3.c:94543:      assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );
vendor/sqlite3.c:94546:      pSel = pExpr->x.pSelect;
vendor/sqlite3.c:94547:      nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;
vendor/sqlite3.c:94550:      if( pExpr->op==TK_SELECT ){
vendor/sqlite3.c:94576:    sqlite3SetHasNullFlag(v, pExpr->iTable, rHasNullFlag);
vendor/sqlite3.c:94659:  pLeft = pExpr->pLeft;
vendor/sqlite3.c:94662:  nVector = sqlite3ExprVectorSize(pExpr->pLeft);
vendor/sqlite3.c:94669:  ** IN_INDEX_NOOP is returned, the table opened ith cursor pExpr->iTable 
vendor/sqlite3.c:94684:  ** nVector-1. */
vendor/sqlite3.c:94722:    ExprList *pList = pExpr->x.pList;
vendor/sqlite3.c:94723:    CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
vendor/sqlite3.c:94738:      if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){
vendor/sqlite3.c:94741:        VdbeCoverageIf(v, ii<pList->nExpr-1);
vendor/sqlite3.c:94742:        VdbeCoverageIf(v, ii==pList->nExpr-1);
vendor/sqlite3.c:94771:    Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);
vendor/sqlite3.c:94786:    sqlite3VdbeAddOp3(v, OP_SeekRowid, pExpr->iTable, destIfFalse, rLhs);
vendor/sqlite3.c:94793:      sqlite3VdbeAddOp4Int(v, OP_NotFound, pExpr->iTable, destIfFalse,
vendor/sqlite3.c:94798:    addrTruthOp = sqlite3VdbeAddOp4Int(v, OP_Found, pExpr->iTable, 0,
vendor/sqlite3.c:94823:  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, pExpr->iTable, destIfFalse);
vendor/sqlite3.c:94838:    sqlite3VdbeAddOp3(v, OP_Column, pExpr->iTable, i, r3);
vendor/sqlite3.c:94847:    sqlite3VdbeAddOp2(v, OP_Next, pExpr->iTable, addrTop+1);
vendor/sqlite3.c:94897:  if( pExpr->flags & EP_IntValue ){
vendor/sqlite3.c:94898:    int i = pExpr->u.iValue;
vendor/sqlite3.c:94905:    const char *z = pExpr->u.zToken;
vendor/sqlite3.c:95081:    assert( pIdx->aColExpr->nExpr>iIdxCol );
vendor/sqlite3.c:95083:    sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);
vendor/sqlite3.c:95309:    op = pExpr->op;
vendor/sqlite3.c:95313:      AggInfo *pAggInfo = pExpr->pAggInfo;
vendor/sqlite3.c:95314:      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];
vendor/sqlite3.c:95326:      int iTab = pExpr->iTable;
vendor/sqlite3.c:95330:          return pExpr->iColumn - pParse->iSelfTab;
vendor/sqlite3.c:95337:      return sqlite3ExprCodeGetColumn(pParse, pExpr->pTab,
vendor/sqlite3.c:95338:                               pExpr->iColumn, iTab, target,
vendor/sqlite3.c:95339:                               pExpr->op2);
vendor/sqlite3.c:95348:      codeReal(v, pExpr->u.zToken, 0, target);
vendor/sqlite3.c:95354:      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);
vendor/sqlite3.c:95367:      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );
vendor/sqlite3.c:95368:      assert( pExpr->u.zToken[1]=='\'' );
vendor/sqlite3.c:95369:      z = &pExpr->u.zToken[2];
vendor/sqlite3.c:95379:      assert( pExpr->u.zToken!=0 );
vendor/sqlite3.c:95380:      assert( pExpr->u.zToken[0]!=0 );
vendor/sqlite3.c:95381:      sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);
vendor/sqlite3.c:95382:      if( pExpr->u.zToken[1]!=0 ){
vendor/sqlite3.c:95383:        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);
vendor/sqlite3.c:95384:        assert( pExpr->u.zToken[0]=='?' || strcmp(pExpr->u.zToken, z)==0 );
vendor/sqlite3.c:95391:      return pExpr->iTable;
vendor/sqlite3.c:95396:      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
vendor/sqlite3.c:95402:                        sqlite3AffinityType(pExpr->u.zToken, 0));
vendor/sqlite3.c:95419:      Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:95424:        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
vendor/sqlite3.c:95425:        codeCompare(pParse, pLeft, pExpr->pRight, op,
vendor/sqlite3.c:95461:      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
vendor/sqlite3.c:95462:      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
vendor/sqlite3.c:95469:      Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:95485:        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);
vendor/sqlite3.c:95495:      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
vendor/sqlite3.c:95506:      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
vendor/sqlite3.c:95516:      AggInfo *pInfo = pExpr->pAggInfo;
vendor/sqlite3.c:95519:        sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
vendor/sqlite3.c:95521:        return pInfo->aFunc[pExpr->iAgg].iMem;
vendor/sqlite3.c:95545:        pFarg = pExpr->x.pList;
vendor/sqlite3.c:95549:      zId = pExpr->u.zToken;
vendor/sqlite3.c:95631:          exprOp = pFarg->a[0].pExpr->op;
vendor/sqlite3.c:95636:            pFarg->a[0].pExpr->op2 = 
vendor/sqlite3.c:95661:      if( nFarg>=2 && (pExpr->flags & EP_InfixFunc) ){
vendor/sqlite3.c:95685:      if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){
vendor/sqlite3.c:95694:      if( pExpr->pLeft->iTable==0 ){
vendor/sqlite3.c:95695:        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft, 0, 0);
vendor/sqlite3.c:95697:      assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );
vendor/sqlite3.c:95698:      if( pExpr->iTable
vendor/sqlite3.c:95699:       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft)) 
vendor/sqlite3.c:95702:                                pExpr->iTable, n);
vendor/sqlite3.c:95704:      return pExpr->pLeft->iTable + pExpr->iColumn;
vendor/sqlite3.c:95727:    ** X is stored in pExpr->pLeft.
vendor/sqlite3.c:95728:    ** Y is stored in pExpr->pList->a[0].pExpr.
vendor/sqlite3.c:95729:    ** Z is stored in pExpr->pList->a[1].pExpr.
vendor/sqlite3.c:95738:      return sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
vendor/sqlite3.c:95767:      Table *pTab = pExpr->pTab;
vendor/sqlite3.c:95768:      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 + pExpr->iColumn;
vendor/sqlite3.c:95770:      assert( pExpr->iTable==0 || pExpr->iTable==1 );
vendor/sqlite3.c:95771:      assert( pExpr->iColumn>=-1 && pExpr->iColumn<pTab->nCol );
vendor/sqlite3.c:95772:      assert( pTab->iPKey<0 || pExpr->iColumn!=pTab->iPKey );
vendor/sqlite3.c:95777:        (pExpr->iTable ? "new" : "old"),
vendor/sqlite3.c:95778:        (pExpr->iColumn<0 ? "rowid" : pExpr->pTab->aCol[pExpr->iColumn].zName),
vendor/sqlite3.c:95786:      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to
vendor/sqlite3.c:95788:      if( pExpr->iColumn>=0 
vendor/sqlite3.c:95789:       && pTab->aCol[pExpr->iColumn].affinity==SQLITE_AFF_REAL
vendor/sqlite3.c:95804:      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);
vendor/sqlite3.c:95806:      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
vendor/sqlite3.c:95824:    ** X (if it exists) is in pExpr->pLeft.
vendor/sqlite3.c:95825:    ** Y is in the last element of pExpr->x.pList if pExpr->x.pList->nExpr is
vendor/sqlite3.c:95828:    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].
vendor/sqlite3.c:95846:      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );
vendor/sqlite3.c:95847:      assert(pExpr->x.pList->nExpr > 0);
vendor/sqlite3.c:95848:      pEList = pExpr->x.pList;
vendor/sqlite3.c:95852:      if( (pX = pExpr->pLeft)!=0 ){
vendor/sqlite3.c:95867:      for(i=0; i<nExpr-1; i=i+2){
vendor/sqlite3.c:95878:        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );
vendor/sqlite3.c:95886:        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);
vendor/sqlite3.c:95898:      assert( pExpr->affinity==OE_Rollback 
vendor/sqlite3.c:95899:           || pExpr->affinity==OE_Abort
vendor/sqlite3.c:95900:           || pExpr->affinity==OE_Fail
vendor/sqlite3.c:95901:           || pExpr->affinity==OE_Ignore
vendor/sqlite3.c:95905:                       "RAISE() may only be used within a trigger-program");
vendor/sqlite3.c:95908:      if( pExpr->affinity==OE_Abort ){
vendor/sqlite3.c:95912:      if( pExpr->affinity==OE_Ignore ){
vendor/sqlite3.c:95914:            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);
vendor/sqlite3.c:95918:                              pExpr->affinity, pExpr->u.zToken, 0, 0);
vendor/sqlite3.c:95959:     struct ExprList_item *pItem = &p->a[p->nExpr-1];
vendor/sqlite3.c:95985:   && pExpr->op!=TK_REGISTER
vendor/sqlite3.c:96012:  if( pExpr && pExpr->op==TK_REGISTER ){
vendor/sqlite3.c:96013:    sqlite3VdbeAddOp2(pParse->pVdbe, OP_Copy, pExpr->iTable, target);
vendor/sqlite3.c:96066:  assert( pExpr->op!=TK_REGISTER );
vendor/sqlite3.c:96178:  exprX = *pExpr->pLeft;
vendor/sqlite3.c:96184:  compLeft.pRight = pExpr->x.pList->a[0].pExpr;
vendor/sqlite3.c:96187:  compRight.pRight = pExpr->x.pList->a[1].pExpr;
vendor/sqlite3.c:96238:  op = pExpr->op;
vendor/sqlite3.c:96243:      sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,jumpIfNull^SQLITE_JUMPIFNULL);
vendor/sqlite3.c:96245:      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
vendor/sqlite3.c:96252:      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
vendor/sqlite3.c:96254:      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
vendor/sqlite3.c:96260:      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
vendor/sqlite3.c:96276:      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;
vendor/sqlite3.c:96278:      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
vendor/sqlite3.c:96279:      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
vendor/sqlite3.c:96280:      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
vendor/sqlite3.c:96300:      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
vendor/sqlite3.c:96362:  /* The value of pExpr->op and op are related as follows:
vendor/sqlite3.c:96364:  **       pExpr->op            op
vendor/sqlite3.c:96375:  ** For other values of pExpr->op, op is undefined and unused.
vendor/sqlite3.c:96380:  op = ((pExpr->op+(TK_ISNULL&1))^1)-(TK_ISNULL&1);
vendor/sqlite3.c:96384:  assert( pExpr->op!=TK_ISNULL || op==OP_NotNull );
vendor/sqlite3.c:96385:  assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull );
vendor/sqlite3.c:96386:  assert( pExpr->op!=TK_NE || op==OP_Eq );
vendor/sqlite3.c:96387:  assert( pExpr->op!=TK_EQ || op==OP_Ne );
vendor/sqlite3.c:96388:  assert( pExpr->op!=TK_LT || op==OP_Ge );
vendor/sqlite3.c:96389:  assert( pExpr->op!=TK_LE || op==OP_Gt );
vendor/sqlite3.c:96390:  assert( pExpr->op!=TK_GT || op==OP_Le );
vendor/sqlite3.c:96391:  assert( pExpr->op!=TK_GE || op==OP_Lt );
vendor/sqlite3.c:96393:  switch( pExpr->op ){
vendor/sqlite3.c:96396:      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
vendor/sqlite3.c:96398:      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
vendor/sqlite3.c:96405:      sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull^SQLITE_JUMPIFNULL);
vendor/sqlite3.c:96407:      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
vendor/sqlite3.c:96414:      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
vendor/sqlite3.c:96419:      testcase( pExpr->op==TK_IS );
vendor/sqlite3.c:96420:      testcase( pExpr->op==TK_ISNOT );
vendor/sqlite3.c:96421:      op = (pExpr->op==TK_IS) ? TK_NE : TK_EQ;
vendor/sqlite3.c:96430:      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;
vendor/sqlite3.c:96432:      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
vendor/sqlite3.c:96433:      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
vendor/sqlite3.c:96434:      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
vendor/sqlite3.c:96452:      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
vendor/sqlite3.c:96530:    iVar = pVar->iColumn;
vendor/sqlite3.c:96718:** pWalker->u.pIdxCover->iCur can be satisfied using the index
vendor/sqlite3.c:96719:** pWalker->u.pIdxCover->pIdx.
vendor/sqlite3.c:96722:  if( pExpr->op==TK_COLUMN
vendor/sqlite3.c:96723:   && pExpr->iTable==pWalker->u.pIdxCover->iCur
vendor/sqlite3.c:96724:   && sqlite3ColumnOfIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0
vendor/sqlite3.c:96726:    pWalker->eCode = 1;
vendor/sqlite3.c:96780:  if( pExpr->op==TK_COLUMN || NEVER(pExpr->op==TK_AGG_COLUMN) ){
vendor/sqlite3.c:96782:    struct SrcCount *p = pWalker->u.pSrcCount;
vendor/sqlite3.c:96786:      if( pExpr->iTable==pSrc->a[i].iCursor ) break;
vendor/sqlite3.c:96806:  assert( pExpr->op==TK_AGG_FUNCTION );
vendor/sqlite3.c:96813:  sqlite3WalkExprList(&w, pExpr->x.pList);
vendor/sqlite3.c:96856:  NameContext *pNC = pWalker->u.pNC;
vendor/sqlite3.c:96861:  switch( pExpr->op ){
vendor/sqlite3.c:96864:      testcase( pExpr->op==TK_AGG_COLUMN );
vendor/sqlite3.c:96865:      testcase( pExpr->op==TK_COLUMN );
vendor/sqlite3.c:96873:          if( pExpr->iTable==pItem->iCursor ){
vendor/sqlite3.c:96883:              if( pCol->iTable==pExpr->iTable &&
vendor/sqlite3.c:96884:                  pCol->iColumn==pExpr->iColumn ){
vendor/sqlite3.c:96892:              pCol->pTab = pExpr->pTab;
vendor/sqlite3.c:96893:              pCol->iTable = pExpr->iTable;
vendor/sqlite3.c:96894:              pCol->iColumn = pExpr->iColumn;
vendor/sqlite3.c:96905:                  if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable &&
vendor/sqlite3.c:96906:                      pE->iColumn==pExpr->iColumn ){
vendor/sqlite3.c:96922:            pExpr->pAggInfo = pAggInfo;
vendor/sqlite3.c:96923:            pExpr->op = TK_AGG_COLUMN;
vendor/sqlite3.c:96924:            pExpr->iAgg = (i16)k;
vendor/sqlite3.c:96926:          } /* endif pExpr->iTable==pItem->iCursor */
vendor/sqlite3.c:96933:       && pWalker->walkerDepth==pExpr->op2
vendor/sqlite3.c:96956:                   pExpr->u.zToken, 
vendor/sqlite3.c:96957:                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);
vendor/sqlite3.c:96958:            if( pExpr->flags & EP_Distinct ){
vendor/sqlite3.c:96969:        pExpr->iAgg = (i16)i;
vendor/sqlite3.c:96970:        pExpr->pAggInfo = pAggInfo;
vendor/sqlite3.c:96981:  pWalker->walkerDepth++;
vendor/sqlite3.c:96986:  pWalker->walkerDepth--;
vendor/sqlite3.c:99883:    if( pExpr->op!=TK_ID ){
vendor/sqlite3.c:99886:      pExpr->op = TK_STRING;
vendor/sqlite3.c:99893:** An SQL user-function registered to do the work of an ATTACH statement. The
vendor/sqlite3.c:100096:** An SQL user-function registered to do the work of an DETACH statement. The
vendor/sqlite3.c:100363:    if( pExpr->op==TK_VARIABLE ){
vendor/sqlite3.c:100365:        pExpr->op = TK_NULL;
vendor/sqlite3.c:100373:      if( sqlite3FixSelect(pFix, pExpr->x.pSelect) ) return 1;
vendor/sqlite3.c:100375:      if( sqlite3FixExprList(pFix, pExpr->x.pList) ) return 1;
vendor/sqlite3.c:100377:    if( sqlite3FixExpr(pFix, pExpr->pRight) ){
vendor/sqlite3.c:100380:    pExpr = pExpr->pLeft;
vendor/sqlite3.c:100484:** means that the SQL statement will never-run - the sqlite3_exec() call
vendor/sqlite3.c:100510:** user-supplied authorization function returned an illegal value.
vendor/sqlite3.c:100583:  assert( pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER );
vendor/sqlite3.c:100584:  if( pExpr->op==TK_TRIGGER ){
vendor/sqlite3.c:100589:      if( pExpr->iTable==pTabList->a[iSrc].iCursor ){
vendor/sqlite3.c:100595:  iCol = pExpr->iColumn;
vendor/sqlite3.c:100609:    pExpr->op = TK_NULL;
vendor/sqlite3.c:100640:  /* EVIDENCE-OF: R-43249-19882 The third through sixth parameters to the
vendor/sqlite3.c:102023:      if( pCExpr->op==TK_ID ){
vendor/sqlite3.c:102024:        const char *zCName = pCExpr->u.zToken;
vendor/sqlite3.c:102172:** IMPLEMENTATION-OF: R-34230-56049 SQLite automatically increments
vendor/sqlite3.c:103158:    assert( pTrigger->pSchema==pTab->pSchema || 
vendor/sqlite3.c:103159:        pTrigger->pSchema==db->aDb[1].pSchema );
vendor/sqlite3.c:103161:    pTrigger = pTrigger->pNext;
vendor/sqlite3.c:103222:  if( noErr ) db->suppressErr--;
vendor/sqlite3.c:103449:  assert( isDeferred==0 || isDeferred==1 ); /* EV: R-30323-21917 */
vendor/sqlite3.c:103798:    if( pExpr->op==TK_COLLATE ){
vendor/sqlite3.c:103799:      nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));
vendor/sqlite3.c:103857:    if( pCExpr->op!=TK_COLUMN ){
vendor/sqlite3.c:103875:      j = pCExpr->iColumn;
vendor/sqlite3.c:103885:    if( pListItem->pExpr->op==TK_COLLATE ){
vendor/sqlite3.c:103887:      zColl = pListItem->pExpr->u.zToken;
vendor/sqlite3.c:104114:      while( pOther->pNext && pOther->pNext->onError!=OE_Replace ){
vendor/sqlite3.c:104115:        pOther = pOther->pNext;
vendor/sqlite3.c:104117:      pIndex->pNext = pOther->pNext;
vendor/sqlite3.c:104118:      pOther->pNext = pIndex;
vendor/sqlite3.c:105455:      assert( pOther!=&aDef[i] && pOther->pNext!=&aDef[i] );
vendor/sqlite3.c:105456:      aDef[i].pNext = pOther->pNext;
vendor/sqlite3.c:105457:      pOther->pNext = &aDef[i];
vendor/sqlite3.c:105985:  ** IMPLEMENTATION-OF: R-17228-37124 If the action code is SQLITE_DELETE and
vendor/sqlite3.c:106127:      if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){
vendor/sqlite3.c:106499:  if( pPrior && (regBase!=regPrior || pPrior->pPartIdxWhere) ) pPrior = 0;
vendor/sqlite3.c:106502:     && pPrior->aiColumn[j]==pIdx->aiColumn[j]
vendor/sqlite3.c:106503:     && pPrior->aiColumn[j]!=XN_EXPR
vendor/sqlite3.c:106629:  /* EVIDENCE-OF: R-01470-60482 The sqlite3_value_type(V) interface returns
vendor/sqlite3.c:106677:** IMP: R-23979-26855 The abs(X) function returns the absolute value of
vendor/sqlite3.c:106688:          /* IMP: R-31676-45509 If X is the integer -9223372036854775808
vendor/sqlite3.c:106700:      /* IMP: R-37434-19929 Abs(X) returns NULL if X is NULL. */
vendor/sqlite3.c:106707:      ** IMP: R-01992-00519 Abs(X) returns 0.0 if X is a string or blob
vendor/sqlite3.c:107076:  /* IMP: R-51513-12026 The last_insert_rowid() SQL function is a
vendor/sqlite3.c:107085:** IMP: R-62073-11209 The changes() SQL function is a wrapper
vendor/sqlite3.c:107110:  /* IMP: R-52756-41993 This function is a wrapper around the
vendor/sqlite3.c:107175:** "[a-z]" matches any single lower-case letter.  To match a '-', make
vendor/sqlite3.c:107441:  /* IMP: R-48699-48617 This function is an SQL wrapper around the
vendor/sqlite3.c:107457:  /* IMP: R-24470-31136 This function is an SQL wrapper around the
vendor/sqlite3.c:107491:  /* IMP: R-39564-36305 The sqlite_compileoption_used() SQL
vendor/sqlite3.c:107515:  /* IMP: R-04922-24076 The sqlite_compileoption_get() SQL function
vendor/sqlite3.c:107708:  rc = sqlite3_result_zeroblob64(context, n); /* IMP: R-00293-64994 */
vendor/sqlite3.c:107792:  assert( j+nStr-i+1==nOut );
vendor/sqlite3.c:107793:  memcpy(&zOut[j], &zStr[i], nStr-i);
vendor/sqlite3.c:107905:/* IMP: R-25361-16150 This function is omitted from SQLite by default. It
vendor/sqlite3.c:107913:** IMP: R-59782-00072 The soundex(X) function returns a string that is the
vendor/sqlite3.c:107958:    /* IMP: R-64894-50321 The string "?000" is returned if the argument
vendor/sqlite3.c:108204:** This routine does per-connection function registration.  Most
vendor/sqlite3.c:108268:  if( pExpr->op!=TK_FUNCTION || !pExpr->x.pList ){
vendor/sqlite3.c:108272:  nExpr = pExpr->x.pList->nExpr;
vendor/sqlite3.c:108273:  pDef = sqlite3FindFunction(db, pExpr->u.zToken, nExpr, SQLITE_UTF8, 0);
vendor/sqlite3.c:108280:    Expr *pEscape = pExpr->x.pList->a[2].pExpr;
vendor/sqlite3.c:108907:      pExpr->iTable = regBase + iCol + 1;
vendor/sqlite3.c:108908:      pExpr->affinity = pCol->affinity;
vendor/sqlite3.c:108913:      pExpr->iTable = regBase;
vendor/sqlite3.c:108914:      pExpr->affinity = SQLITE_AFF_INTEGER;
vendor/sqlite3.c:108932:    pExpr->pTab = pTab;
vendor/sqlite3.c:108933:    pExpr->iTable = iCursor;
vendor/sqlite3.c:108934:    pExpr->iColumn = iCol;
vendor/sqlite3.c:109733:      pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];
vendor/sqlite3.c:109742:        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);
vendor/sqlite3.c:109772:    pTrigger->pSchema = pTab->pSchema;
vendor/sqlite3.c:109773:    pTrigger->pTabSchema = pTab->pSchema;
vendor/sqlite3.c:109775:    pTrigger->op = (pChanges ? TK_UPDATE : TK_DELETE);
vendor/sqlite3.c:109839:    /* EV: R-30323-21917 Each foreign key constraint in SQLite is
vendor/sqlite3.c:109956:        aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);
vendor/sqlite3.c:110120:  /* This routine is never called during trigger-generation.  It is
vendor/sqlite3.c:110944:** Meanings of bits in of pWalker->eCode for checkConstraintUnchanged()
vendor/sqlite3.c:110950:** bit 0x01 of pWalker->eCode if
vendor/sqlite3.c:110951:** pWalker->eCode to 0 if this expression node references any of the
vendor/sqlite3.c:110955:  if( pExpr->op==TK_COLUMN ){
vendor/sqlite3.c:110956:    assert( pExpr->iColumn>=0 || pExpr->iColumn==-1 );
vendor/sqlite3.c:110957:    if( pExpr->iColumn>=0 ){
vendor/sqlite3.c:110958:      if( pWalker->u.aiCol[pExpr->iColumn]>=0 ){
vendor/sqlite3.c:110959:        pWalker->eCode |= CKCNSTRNT_COLUMN;
vendor/sqlite3.c:110962:      pWalker->eCode |= CKCNSTRNT_ROWID;
vendor/sqlite3.c:111203:        if( onError==OE_Replace ) onError = OE_Abort; /* IMP: R-15569-63625 */
vendor/sqlite3.c:111370:        sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);
vendor/sqlite3.c:111756:      if( sqlite3ExprCompare(0, pSrc->aColExpr->a[i].pExpr,
vendor/sqlite3.c:111757:                             pDest->aColExpr->a[i].pExpr, -1)!=0 ){
vendor/sqlite3.c:111879:  if( pEList->a[0].pExpr->op!=TK_ASTERISK ){
vendor/sqlite3.c:112218:          /* EVIDENCE-OF: R-38229-40159 If the callback function to
vendor/sqlite3.c:114681:  ** IMPLEMENTATION-OF: R-12238-55120 Whenever a PRAGMA statement is parsed,
vendor/sqlite3.c:114686:  ** IMPLEMENTATION-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA
vendor/sqlite3.c:114999:      ** incr-vacuum flags. This is required in case this connection
vendor/sqlite3.c:115781:    sqlite3VdbeAddOp2(v, OP_Integer, mxErr-1, 1); /* reg[1] holds errors left */
vendor/sqlite3.c:115889:            for(k=pCheck->nExpr-1; k>0; k--){
vendor/sqlite3.c:116089:  ** the value of the schema-version and user-version, respectively. Both
vendor/sqlite3.c:116090:  ** the schema-version and the user-version are 32-bit signed integers
vendor/sqlite3.c:116103:  ** The user-version is not used internally by SQLite. It may be used by
vendor/sqlite3.c:116209:  ** IMPLEMENTATION-OF: R-23445-46109 This pragma causes the database
vendor/sqlite3.c:116353:  ** IMPLEMENTATION-OF: R-26343-45930 This pragma invokes the
vendor/sqlite3.c:116356:  ** IMPLEMENTATION-OF: R-64451-07163 The soft_heap_limit pragma always
vendor/sqlite3.c:116616:  pCsr->base.pVtab = pVtab;
vendor/sqlite3.c:116617:  *ppCursor = &pCsr->base;
vendor/sqlite3.c:116624:  sqlite3_finalize(pCsr->pPragma);
vendor/sqlite3.c:116625:  pCsr->pPragma = 0;
vendor/sqlite3.c:116626:  for(i=0; i<ArraySize(pCsr->azArg); i++){
vendor/sqlite3.c:116627:    sqlite3_free(pCsr->azArg[i]);
vendor/sqlite3.c:116628:    pCsr->azArg[i] = 0;
vendor/sqlite3.c:116646:  pCsr->iRowid++;
vendor/sqlite3.c:116647:  assert( pCsr->pPragma );
vendor/sqlite3.c:116648:  if( SQLITE_ROW!=sqlite3_step(pCsr->pPragma) ){
vendor/sqlite3.c:116649:    rc = sqlite3_finalize(pCsr->pPragma);
vendor/sqlite3.c:116650:    pCsr->pPragma = 0;
vendor/sqlite3.c:116665:  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);
vendor/sqlite3.c:116677:    assert( j<ArraySize(pCsr->azArg) );
vendor/sqlite3.c:116678:    assert( pCsr->azArg[j]==0 );
vendor/sqlite3.c:116680:      pCsr->azArg[j] = sqlite3_mprintf("%s", zText);
vendor/sqlite3.c:116681:      if( pCsr->azArg[j]==0 ){
vendor/sqlite3.c:116688:  if( pCsr->azArg[1] ){
vendor/sqlite3.c:116689:    sqlite3XPrintf(&acc, "%Q.", pCsr->azArg[1]);
vendor/sqlite3.c:116692:  if( pCsr->azArg[0] ){
vendor/sqlite3.c:116693:    sqlite3XPrintf(&acc, "=%Q", pCsr->azArg[0]);
vendor/sqlite3.c:116697:  rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pPragma, 0);
vendor/sqlite3.c:116711:  return (pCsr->pPragma==0);
vendor/sqlite3.c:116723:  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);
vendor/sqlite3.c:116725:    sqlite3_result_value(ctx, sqlite3_column_value(pCsr->pPragma, i));
vendor/sqlite3.c:116727:    sqlite3_result_text(ctx, pCsr->azArg[i-pTab->iHidden],-1,SQLITE_TRANSIENT);
vendor/sqlite3.c:116737:  *p = pCsr->iRowid;
vendor/sqlite3.c:117548:  /* EVIDENCE-OF: R-37923-12173 The sqlite3_prepare_v2() interface works
vendor/sqlite3.c:117567:  /* EVIDENCE-OF: R-56861-42673 sqlite3_prepare_v3() differs from
vendor/sqlite3.c:118698:    ** user-defined functions that have side effects.  We do not care
vendor/sqlite3.c:118797:  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);
vendor/sqlite3.c:119076:  switch( pExpr->op ){
vendor/sqlite3.c:119085:      int iCol = pExpr->iColumn;  /* Index of column in pTab */
vendor/sqlite3.c:119086:      testcase( pExpr->op==TK_AGG_COLUMN );
vendor/sqlite3.c:119087:      testcase( pExpr->op==TK_COLUMN );
vendor/sqlite3.c:119090:        for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);
vendor/sqlite3.c:119120:      assert( pTab && pExpr->pTab==pTab );
vendor/sqlite3.c:119174:      Select *pS = pExpr->x.pSelect;
vendor/sqlite3.c:119394:      while( pColExpr->op==TK_DOT ){
vendor/sqlite3.c:119395:        pColExpr = pColExpr->pRight;
vendor/sqlite3.c:119398:      if( (pColExpr->op==TK_COLUMN || pColExpr->op==TK_AGG_COLUMN)
vendor/sqlite3.c:119399:       && pColExpr->pTab!=0 
vendor/sqlite3.c:119402:        int iCol = pColExpr->iColumn;
vendor/sqlite3.c:119403:        Table *pTab = pColExpr->pTab;
vendor/sqlite3.c:119406:      }else if( pColExpr->op==TK_ID ){
vendor/sqlite3.c:119408:        zName = pColExpr->u.zToken;
vendor/sqlite3.c:119897:    assert( p->pPrior->pNext==p );
vendor/sqlite3.c:119968:  if( pPrior->pOrderBy || pPrior->pLimit ){
vendor/sqlite3.c:119970:      pPrior->pOrderBy!=0 ? "ORDER BY" : "LIMIT", selectOpName(p->op));
vendor/sqlite3.c:119996:  assert( p->pEList && pPrior->pEList );
vendor/sqlite3.c:119997:  assert( p->pEList->nExpr==pPrior->pEList->nExpr );
vendor/sqlite3.c:120017:      assert( !pPrior->pLimit );
vendor/sqlite3.c:120018:      pPrior->iLimit = p->iLimit;
vendor/sqlite3.c:120019:      pPrior->iOffset = p->iOffset;
vendor/sqlite3.c:120020:      pPrior->pLimit = p->pLimit;
vendor/sqlite3.c:120021:      pPrior->pOffset = p->pOffset;
vendor/sqlite3.c:120030:      p->iLimit = pPrior->iLimit;
vendor/sqlite3.c:120031:      p->iOffset = pPrior->iOffset;
vendor/sqlite3.c:120045:      p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
vendor/sqlite3.c:120046:      if( pPrior->pLimit
vendor/sqlite3.c:120047:       && sqlite3ExprIsInteger(pPrior->pLimit, &nLimit)
vendor/sqlite3.c:120091:      assert( !pPrior->pOrderBy );
vendor/sqlite3.c:120123:        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
vendor/sqlite3.c:120199:      if( p->nSelectRow>pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;
vendor/sqlite3.c:120584:  assert( pPrior->pOrderBy==0 );
vendor/sqlite3.c:120635:  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);
vendor/sqlite3.c:120662:  pPrior->pNext = 0;
vendor/sqlite3.c:120664:  if( pPrior->pPrior==0 ){
vendor/sqlite3.c:120665:    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");
vendor/sqlite3.c:120697:  pPrior->iLimit = regLimitA;
vendor/sqlite3.c:120749:    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
vendor/sqlite3.c:120757:    if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;
vendor/sqlite3.c:120821:  pPrior->pNext = p;
vendor/sqlite3.c:120869:   && pExpr->iRightJoinTable==pSubst->iTable
vendor/sqlite3.c:120871:    pExpr->iRightJoinTable = pSubst->iNewTable;
vendor/sqlite3.c:120873:  if( pExpr->op==TK_COLUMN && pExpr->iTable==pSubst->iTable ){
vendor/sqlite3.c:120874:    if( pExpr->iColumn<0 ){
vendor/sqlite3.c:120875:      pExpr->op = TK_NULL;
vendor/sqlite3.c:120878:      Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;
vendor/sqlite3.c:120880:      assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );
vendor/sqlite3.c:120881:      assert( pExpr->pLeft==0 && pExpr->pRight==0 );
vendor/sqlite3.c:120898:          pNew->iRightJoinTable = pExpr->iRightJoinTable;
vendor/sqlite3.c:120906:    if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){
vendor/sqlite3.c:120907:      pExpr->iTable = pSubst->iNewTable;
vendor/sqlite3.c:120909:    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);
vendor/sqlite3.c:120910:    pExpr->pRight = substExpr(pSubst, pExpr->pRight);
vendor/sqlite3.c:120912:      substSelect(pSubst, pExpr->x.pSelect, 1);
vendor/sqlite3.c:120914:      substExprList(pSubst, pExpr->x.pList);
vendor/sqlite3.c:121268:  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> 
vendor/sqlite3.c:121319:      if( pPrior ) pPrior->pNext = pNew;
vendor/sqlite3.c:121628:    ExprList *pEList = pExpr->x.pList;      /* Arguments to agg function */
vendor/sqlite3.c:121630:    assert( pExpr->op==TK_AGG_FUNCTION );
vendor/sqlite3.c:121631:    if( pEList && pEList->nExpr==1 && pEList->a[0].pExpr->op==TK_AGG_COLUMN ){
vendor/sqlite3.c:121632:      const char *zFunc = pExpr->u.zToken;
vendor/sqlite3.c:121674:  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;
vendor/sqlite3.c:121677:  if( pExpr->flags&EP_Distinct ) return 0;
vendor/sqlite3.c:121743:  for(i=p->pOrderBy->nExpr-1; i>=0; i--){
vendor/sqlite3.c:121744:    if( a[i].pExpr->flags & EP_Collate ) break;
vendor/sqlite3.c:121750:  pParse = pWalker->pParse;
vendor/sqlite3.c:121772:  pNew->pPrior->pNext = pNew;
vendor/sqlite3.c:121824:** with the inner-most WITH clause being at the top of the stack.
vendor/sqlite3.c:121862:  Parse *pParse = pWalker->pParse;
vendor/sqlite3.c:121935:      assert( pPrior->pWith==0 );
vendor/sqlite3.c:121936:      pPrior->pWith = pSel->pWith;
vendor/sqlite3.c:121938:      pPrior->pWith = 0;
vendor/sqlite3.c:121984:  Parse *pParse = pWalker->pParse;
vendor/sqlite3.c:122022:  Parse *pParse = pWalker->pParse;
vendor/sqlite3.c:122166:          pNew->a[pNew->nExpr-1].zName = a[k].zName;
vendor/sqlite3.c:122167:          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;
vendor/sqlite3.c:122260:              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];
vendor/sqlite3.c:122379:  pParse = pWalker->pParse;
vendor/sqlite3.c:122497:    ExprList *pList = pF->pExpr->x.pList;
vendor/sqlite3.c:122521:    ExprList *pList = pF->pExpr->x.pList;
vendor/sqlite3.c:122632:  if( pExpr->op!=TK_AND ){
vendor/sqlite3.c:122633:    struct HavingToWhereCtx *p = pWalker->u.pHavingCtx;
vendor/sqlite3.c:122634:    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, p->pGroupBy) ){
vendor/sqlite3.c:122635:      sqlite3 *db = pWalker->pParse->db;
vendor/sqlite3.c:122737:  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;        /* Result is an aggregate */
vendor/sqlite3.c:122738:  if( sqlite3_stricmp(pExpr->u.zToken,"count") ) return 0;  /* Is count() */
vendor/sqlite3.c:122739:  if( pExpr->x.pList!=0 ) return 0;                 /* Must be count(*) */
vendor/sqlite3.c:123095:        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);
vendor/sqlite3.c:123096:        explainSetInteger(pItem->iSelectId, pPrior->iSelectId);
vendor/sqlite3.c:123097:        assert( pPrior->pSelect!=0 );
vendor/sqlite3.c:123098:        pSub->nSelectRow = pPrior->pSelect->nSelectRow;
vendor/sqlite3.c:123345:      sqlite3ExprAnalyzeAggList(&sNC, sAggInfo.aFunc[i].pExpr->x.pList);
vendor/sqlite3.c:123392:      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);
vendor/sqlite3.c:123682:            pMinMax->a[0].pExpr->op = TK_COLUMN;
vendor/sqlite3.c:124195:  pTrigger->zName = zName;
vendor/sqlite3.c:124197:  pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);
vendor/sqlite3.c:124198:  pTrigger->pSchema = db->aDb[iDb].pSchema;
vendor/sqlite3.c:124199:  pTrigger->pTabSchema = pTab->pSchema;
vendor/sqlite3.c:124200:  pTrigger->op = (u8)op;
vendor/sqlite3.c:124201:  pTrigger->tr_tm = tr_tm==TK_BEFORE ? TRIGGER_BEFORE : TRIGGER_AFTER;
vendor/sqlite3.c:124202:  pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);
vendor/sqlite3.c:124203:  pTrigger->pColumns = sqlite3IdListDup(db, pColumns);
vendor/sqlite3.c:124422:  sqlite3DeleteTriggerStep(db, pTrigger->step_list);
vendor/sqlite3.c:124423:  sqlite3DbFree(db, pTrigger->zName);
vendor/sqlite3.c:124424:  sqlite3DbFree(db, pTrigger->table);
vendor/sqlite3.c:124425:  sqlite3ExprDelete(db, pTrigger->pWhen);
vendor/sqlite3.c:124426:  sqlite3IdListDelete(db, pTrigger->pColumns);
vendor/sqlite3.c:124481:  return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table);
vendor/sqlite3.c:124494:  iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
vendor/sqlite3.c:124498:  assert( pTable->pSchema==pTrigger->pSchema || iDb==1 );
vendor/sqlite3.c:124505:    if( sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||
vendor/sqlite3.c:124518:       db->aDb[iDb].zDbSName, MASTER_NAME, pTrigger->zName
vendor/sqlite3.c:124521:    sqlite3VdbeAddOp4(v, OP_DropTrigger, iDb, 0, 0, pTrigger->zName, 0);
vendor/sqlite3.c:124536:    if( pTrigger->pSchema==pTrigger->pTabSchema ){
vendor/sqlite3.c:124761:  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );
vendor/sqlite3.c:124788:  pSubParse->zAuthContext = pTrigger->zName;
vendor/sqlite3.c:124789:  pSubParse->eTriggerOp = pTrigger->op;
vendor/sqlite3.c:124795:      pTrigger->zName, onErrorText(orconf),
vendor/sqlite3.c:124796:      (pTrigger->tr_tm==TRIGGER_BEFORE ? "BEFORE" : "AFTER"),
vendor/sqlite3.c:124797:        (pTrigger->op==TK_UPDATE ? "UPDATE" : ""),
vendor/sqlite3.c:124798:        (pTrigger->op==TK_INSERT ? "INSERT" : ""),
vendor/sqlite3.c:124799:        (pTrigger->op==TK_DELETE ? "DELETE" : ""),
vendor/sqlite3.c:124804:      sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), P4_DYNAMIC
vendor/sqlite3.c:124811:    if( pTrigger->pWhen ){
vendor/sqlite3.c:124812:      pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);
vendor/sqlite3.c:124823:    codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);
vendor/sqlite3.c:124830:    VdbeComment((v, "End: %s.%s", pTrigger->zName, onErrorText(orconf)));
vendor/sqlite3.c:124867:  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );
vendor/sqlite3.c:125473:    if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){
vendor/sqlite3.c:127371:  if( pExpr->op!=TK_COLUMN ) return pDef;
vendor/sqlite3.c:127372:  pTab = pExpr->pTab;
vendor/sqlite3.c:127741:** correspond to the subquery(s) of OR-clause processing.  Only the
vendor/sqlite3.c:127845:  Bitmask prereqRight;    /* Bitmask of tables used by pExpr->pRight */
vendor/sqlite3.c:127858:#define TERM_OR_OK      0x40   /* Used during OR-clause processing */
vendor/sqlite3.c:128017:  u8 bOrderedInnerLoop;     /* True if only the inner-most loop is ordered */
vendor/sqlite3.c:128090:** OR-ed combination of these values can be used when searching for
vendor/sqlite3.c:128109:#define WO_OR     0x0200       /* Two or more OR-connected terms */
vendor/sqlite3.c:128801:      if( pTerm->pExpr->flags & EP_xIsSelect ){
vendor/sqlite3.c:128809:      Expr *pRight = pTerm->pExpr->pRight;
vendor/sqlite3.c:128882:** accessed through the index.  If it cannot, then set pWalker->eCode to 1.
vendor/sqlite3.c:128885:  struct CCurHint *pHint = pWalker->u.pCCurHint;
vendor/sqlite3.c:128887:  if( pExpr->op==TK_COLUMN
vendor/sqlite3.c:128888:   && pExpr->iTable==pHint->iTabCur
vendor/sqlite3.c:128889:   && sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn)<0
vendor/sqlite3.c:128891:    pWalker->eCode = 1;
vendor/sqlite3.c:128898:** should be included in the cursor-hint for a table that is on the rhs
vendor/sqlite3.c:128912:  if( pExpr->op==TK_IS 
vendor/sqlite3.c:128913:   || pExpr->op==TK_ISNULL || pExpr->op==TK_ISNOT 
vendor/sqlite3.c:128914:   || pExpr->op==TK_NOTNULL || pExpr->op==TK_CASE 
vendor/sqlite3.c:128916:    pWalker->eCode = 1;
vendor/sqlite3.c:128917:  }else if( pExpr->op==TK_FUNCTION ){
vendor/sqlite3.c:128920:    if( 0==sqlite3IsLikeFunction(pWalker->pParse->db, pExpr, &d1, d2) ){
vendor/sqlite3.c:128921:      pWalker->eCode = 1;
vendor/sqlite3.c:128948:  struct CCurHint *pHint = pWalker->u.pCCurHint;
vendor/sqlite3.c:128949:  if( pExpr->op==TK_COLUMN ){
vendor/sqlite3.c:128950:    if( pExpr->iTable!=pHint->iTabCur ){
vendor/sqlite3.c:128951:      Vdbe *v = pWalker->pParse->pVdbe;
vendor/sqlite3.c:128952:      int reg = ++pWalker->pParse->nMem;   /* Register for column value */
vendor/sqlite3.c:128954:          v, pExpr->pTab, pExpr->iTable, pExpr->iColumn, reg
vendor/sqlite3.c:128956:      pExpr->op = TK_REGISTER;
vendor/sqlite3.c:128957:      pExpr->iTable = reg;
vendor/sqlite3.c:128959:      pExpr->iTable = pHint->iIdxCur;
vendor/sqlite3.c:128960:      pExpr->iColumn = sqlite3ColumnOfIndex(pHint->pIdx, pExpr->iColumn);
vendor/sqlite3.c:128961:      assert( pExpr->iColumn>=0 );
vendor/sqlite3.c:128963:  }else if( pExpr->op==TK_AGG_FUNCTION ){
vendor/sqlite3.c:129014:    ** from the cursor-hint. 
vendor/sqlite3.c:129037:       || pExpr->iRightJoinTable!=pTabItem->iCursor
vendor/sqlite3.c:129093:** However, if the scan currently being coded is a branch of an OR-loop and
vendor/sqlite3.c:129184:    pExpr->op = TK_COLUMN;
vendor/sqlite3.c:129185:    pExpr->iTable = pX->iIdxCur;
vendor/sqlite3.c:129186:    pExpr->iColumn = pX->iIdxCol;
vendor/sqlite3.c:129187:    pExpr->pTab = 0;
vendor/sqlite3.c:129216:  for(iIdxCol=0; iIdxCol<aColExpr->nExpr; iIdxCol++){
vendor/sqlite3.c:129218:    assert( aColExpr->a[iIdxCol].pExpr!=0 );
vendor/sqlite3.c:129220:    x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;
vendor/sqlite3.c:129330:        Expr *pRight = pTerm->pExpr->pRight;
vendor/sqlite3.c:129374:          pCompare->pLeft = pTerm->pExpr->pLeft;
vendor/sqlite3.c:129688:      Expr *pRight = pRangeStart->pExpr->pRight;
vendor/sqlite3.c:129737:      Expr *pRight = pRangeEnd->pExpr->pRight;
vendor/sqlite3.c:129879:    WhereClause *pOrWc;    /* The OR-clause broken out into subterms */
vendor/sqlite3.c:129880:    SrcList *pOrTab;       /* Shortened table list or OR-clause generation */
vendor/sqlite3.c:129992:        WhereInfo *pSubWInfo;           /* Info for single OR-term scan */
vendor/sqlite3.c:129996:          pAndExpr->pLeft = pOrExpr;
vendor/sqlite3.c:130000:        WHERETRACE(0xffff, ("Subplan for OR-clause:\n"));
vendor/sqlite3.c:130077:          /* If all of the OR-connected terms are optimized using the same
vendor/sqlite3.c:130083:          ** uses an index, and this is either the first OR-connected term
vendor/sqlite3.c:130109:      pAndExpr->pLeft = 0;
vendor/sqlite3.c:130324:** the db->mallocFailed flag so that higher-level functions can detect it.
vendor/sqlite3.c:130399:  u16 expRight = (pExpr->pRight->flags & EP_Collate);
vendor/sqlite3.c:130400:  u16 expLeft = (pExpr->pLeft->flags & EP_Collate);
vendor/sqlite3.c:130401:  assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN );
vendor/sqlite3.c:130407:      pExpr->pRight->flags &= ~EP_Collate;
vendor/sqlite3.c:130408:    }else if( sqlite3ExprCollSeq(pParse, pExpr->pLeft)!=0 ){
vendor/sqlite3.c:130412:      pExpr->pLeft->flags |= EP_Collate;
vendor/sqlite3.c:130415:  SWAP(Expr*,pExpr->pRight,pExpr->pLeft);
vendor/sqlite3.c:130416:  if( pExpr->op>=TK_GT ){
vendor/sqlite3.c:130421:    assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );
vendor/sqlite3.c:130422:    pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;
vendor/sqlite3.c:130491:  pList = pExpr->x.pList;
vendor/sqlite3.c:130623:  if( pExpr->op==TK_FUNCTION ){
vendor/sqlite3.c:130637:    pList = pExpr->x.pList;
vendor/sqlite3.c:130646:      if( sqlite3StrICmp(pExpr->u.zToken, aOp[i].zOp)==0 ){
vendor/sqlite3.c:130653:  }else if( pExpr->op==TK_NE || pExpr->op==TK_ISNOT || pExpr->op==TK_NOTNULL ){
vendor/sqlite3.c:130655:    Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:130656:    Expr *pRight = pExpr->pRight;
vendor/sqlite3.c:130666:    if( pExpr->op==TK_NE ) *peOp2 = SQLITE_INDEX_CONSTRAINT_NE;
vendor/sqlite3.c:130667:    if( pExpr->op==TK_ISNOT ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOT;
vendor/sqlite3.c:130668:    if( pExpr->op==TK_NOTNULL ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOTNULL;
vendor/sqlite3.c:130712:** two subterms are in disjunction - they are OR-ed together.
vendor/sqlite3.c:130746:  assert( pOne->pExpr->pLeft!=0 && pOne->pExpr->pRight!=0 );
vendor/sqlite3.c:130747:  assert( pTwo->pExpr->pLeft!=0 && pTwo->pExpr->pRight!=0 );
vendor/sqlite3.c:130748:  if( sqlite3ExprCompare(0,pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;
vendor/sqlite3.c:130749:  if( sqlite3ExprCompare(0,pOne->pExpr->pRight, pTwo->pExpr->pRight,-1) )return;
vendor/sqlite3.c:130770:** Analyze a term that consists of two or more OR-connected
vendor/sqlite3.c:130783:** The term being analyzed must have two or more of OR-connected subterms.
vendor/sqlite3.c:130859:  int idxTerm               /* Index of the OR-term to be analyzed */
vendor/sqlite3.c:130879:  assert( pExpr->op==TK_OR );
vendor/sqlite3.c:130919:            if( allowedOp(pAndTerm->pExpr->op) 
vendor/sqlite3.c:130936:        b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pOther->leftCursor);
vendor/sqlite3.c:131052:          affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);
vendor/sqlite3.c:131053:          affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);
vendor/sqlite3.c:131078:        pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);
vendor/sqlite3.c:131080:        pLeft = pOrTerm->pExpr->pLeft;
vendor/sqlite3.c:131123:  if( pExpr->op!=TK_EQ && pExpr->op!=TK_IS ) return 0;
vendor/sqlite3.c:131125:  aff1 = sqlite3ExprAffinity(pExpr->pLeft);
vendor/sqlite3.c:131126:  aff2 = sqlite3ExprAffinity(pExpr->pRight);
vendor/sqlite3.c:131132:  pColl = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight);
vendor/sqlite3.c:131134:  return sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight);
vendor/sqlite3.c:131191:      if( sqlite3ExprCompareSkip(pExpr, pIdx->aColExpr->a[i].pExpr, iCur)==0 ){
vendor/sqlite3.c:131213:  if( pExpr->op==TK_VECTOR && (op>=TK_GT && ALWAYS(op<=TK_GE)) ){
vendor/sqlite3.c:131214:    pExpr = pExpr->x.pList->a[0].pExpr;
vendor/sqlite3.c:131217:  if( pExpr->op==TK_COLUMN ){
vendor/sqlite3.c:131218:    aiCurCol[0] = pExpr->iTable;
vendor/sqlite3.c:131219:    aiCurCol[1] = pExpr->iColumn;
vendor/sqlite3.c:131254:  Bitmask prereqLeft;              /* Prerequesites of the pExpr->pLeft */
vendor/sqlite3.c:131260:  int op;                          /* Top-level operator.  pExpr->op */
vendor/sqlite3.c:131272:  assert( pExpr->op!=TK_AS && pExpr->op!=TK_COLLATE );
vendor/sqlite3.c:131273:  prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);
vendor/sqlite3.c:131274:  op = pExpr->op;
vendor/sqlite3.c:131276:    assert( pExpr->pRight==0 );
vendor/sqlite3.c:131279:      pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);
vendor/sqlite3.c:131281:      pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);
vendor/sqlite3.c:131286:    pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);
vendor/sqlite3.c:131292:    Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->iRightJoinTable);
vendor/sqlite3.c:131307:    Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);
vendor/sqlite3.c:131308:    Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);
vendor/sqlite3.c:131379:  else if( pExpr->op==TK_BETWEEN && pWC->op==TK_AND ){
vendor/sqlite3.c:131380:    ExprList *pList = pExpr->x.pList;
vendor/sqlite3.c:131389:                             sqlite3ExprDup(db, pExpr->pLeft, 0),
vendor/sqlite3.c:131405:  else if( pExpr->op==TK_OR ){
vendor/sqlite3.c:131422:  ** for LIKE) then the lower-bound is made all uppercase and the upper-
vendor/sqlite3.c:131438:    pLeft = pExpr->x.pList->a[1].pExpr;
vendor/sqlite3.c:131441:    /* Convert the lower bound to upper-case and the upper bound to
vendor/sqlite3.c:131442:    ** lower-case (upper-case is less than lower-case in ASCII) so that
vendor/sqlite3.c:131549:  && (pExpr->op==TK_EQ || pExpr->op==TK_IS)
vendor/sqlite3.c:131550:  && (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1
vendor/sqlite3.c:131551:  && sqlite3ExprVectorSize(pExpr->pRight)==nLeft
vendor/sqlite3.c:131552:  && ( (pExpr->pLeft->flags & EP_xIsSelect)==0 
vendor/sqlite3.c:131553:    || (pExpr->pRight->flags & EP_xIsSelect)==0)
vendor/sqlite3.c:131559:      Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i);
vendor/sqlite3.c:131560:      Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i);
vendor/sqlite3.c:131562:      pNew = sqlite3PExpr(pParse, pExpr->op, pLeft, pRight);
vendor/sqlite3.c:131580:  if( pWC->op==TK_AND && pExpr->op==TK_IN && pTerm->iField==0
vendor/sqlite3.c:131581:   && pExpr->pLeft->op==TK_VECTOR
vendor/sqlite3.c:131582:   && pExpr->x.pSelect->pPrior==0
vendor/sqlite3.c:131585:    for(i=0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++){
vendor/sqlite3.c:131602:  if( pExpr->op==TK_NOTNULL
vendor/sqlite3.c:131603:   && pExpr->pLeft->op==TK_COLUMN
vendor/sqlite3.c:131604:   && pExpr->pLeft->iColumn>=0
vendor/sqlite3.c:131608:    Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:132021:             || sqlite3ExprCompareSkip(pTerm->pExpr->pLeft,
vendor/sqlite3.c:132027:           && (pX = sqlite3ExprSkipCollate(pTerm->pExpr->pRight))->op==TK_COLUMN
vendor/sqlite3.c:132060:             && (pX = pTerm->pExpr->pRight)->op==TK_COLUMN
vendor/sqlite3.c:132120:      pScan->pIdxExpr = pIdx->aColExpr->a[j].pExpr;
vendor/sqlite3.c:132433:  testcase( pTerm->pExpr->op==TK_IS );
vendor/sqlite3.c:132492:         || pExpr->iRightJoinTable!=pSrc->iCursor   /*   for the right-hand   */
vendor/sqlite3.c:132695:      if( pExpr->op!=TK_COLUMN || pExpr->iTable!=pSrc->iCursor ) break;
vendor/sqlite3.c:132764:       && sqlite3ExprIsVector(pTerm->pExpr->pRight) 
vendor/sqlite3.c:132776:    pIdxOrderBy[i].iColumn = pExpr->iColumn;
vendor/sqlite3.c:133124:    rc = sqlite3Stat4ValueFromExpr(pParse, pLower->pExpr->pRight, aff, &p1);
vendor/sqlite3.c:133128:    rc = sqlite3Stat4ValueFromExpr(pParse, pUpper->pExpr->pRight, aff, &p2);
vendor/sqlite3.c:133189:** The value in (pBuilder->pNew->u.btree.nEq) is the number of the index
vendor/sqlite3.c:133230:    if( nEq==pBuilder->nRecValid ){
vendor/sqlite3.c:133231:      UnpackedRecord *pRec = pBuilder->pRec;
vendor/sqlite3.c:133253:      ** The number of rows between the two bounds is then just iUpper-iLower.
vendor/sqlite3.c:133261:        testcase( pRec->nField!=pBuilder->nRecValid );
vendor/sqlite3.c:133262:        pRec->nField = pBuilder->nRecValid;
vendor/sqlite3.c:133276:      assert( pLower==0 || (pLower->eOperator & (WO_GT|WO_GE))!=0 );
vendor/sqlite3.c:133277:      assert( pUpper==0 || (pUpper->eOperator & (WO_LT|WO_LE))!=0 );
vendor/sqlite3.c:133288:        Expr *pExpr = pLower->pExpr->pRight;
vendor/sqlite3.c:133295:          iNew = a[0] + ((pLower->eOperator & mask) ? a[1] : 0);
vendor/sqlite3.c:133305:        Expr *pExpr = pUpper->pExpr->pRight;
vendor/sqlite3.c:133312:          iNew = a[0] + ((pUpper->eOperator & mask) ? a[1] : 0);
vendor/sqlite3.c:133319:      pBuilder->pRec = pRec;
vendor/sqlite3.c:133348:  assert( pUpper==0 || (pUpper->wtFlags & TERM_VNULL)==0 );
vendor/sqlite3.c:133358:  if( pLower && pLower->truthProb>0 && pUpper && pUpper->truthProb>0 ){
vendor/sqlite3.c:133399:  Index *p = pBuilder->pNew->u.btree.pIndex;
vendor/sqlite3.c:133400:  int nEq = pBuilder->pNew->u.btree.nEq;
vendor/sqlite3.c:133401:  UnpackedRecord *pRec = pBuilder->pRec;
vendor/sqlite3.c:133410:  assert( pBuilder->nRecValid<nEq );
vendor/sqlite3.c:133414:  if( pBuilder->nRecValid<(nEq-1) ){
vendor/sqlite3.c:133426:  pBuilder->pRec = pRec;
vendor/sqlite3.c:133429:  pBuilder->nRecValid = nEq;
vendor/sqlite3.c:133463:  Index *p = pBuilder->pNew->u.btree.pIndex;
vendor/sqlite3.c:133465:  int nRecValid = pBuilder->nRecValid;
vendor/sqlite3.c:133476:    pBuilder->nRecValid = nRecValid;
vendor/sqlite3.c:133484:  assert( pBuilder->nRecValid==nRecValid );
vendor/sqlite3.c:133857:** If pBuilder->pOrSet is not NULL then we care about only the
vendor/sqlite3.c:133859:** information is gathered in the pBuilder->pOrSet object.  This special
vendor/sqlite3.c:133862:** When accumulating multiple loops (when pBuilder->pOrSet is NULL) we
vendor/sqlite3.c:133874:  WhereInfo *pWInfo = pBuilder->pWInfo;
vendor/sqlite3.c:133878:  /* If pBuilder->pOrSet is defined, then only keep track of the costs
vendor/sqlite3.c:133881:  if( pBuilder->pOrSet!=0 ){
vendor/sqlite3.c:133884:      u16 n = pBuilder->pOrSet->n;
vendor/sqlite3.c:133887:      whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,
vendor/sqlite3.c:133891:        sqlite3DebugPrintf(x?"   or-%d:  ":"   or-X:  ", n);
vendor/sqlite3.c:133892:        whereLoopPrint(pTemplate, pBuilder->pWC);
vendor/sqlite3.c:133910:      whereLoopPrint(pTemplate, pBuilder->pWC);
vendor/sqlite3.c:133926:      whereLoopPrint(p, pBuilder->pWC);
vendor/sqlite3.c:133931:    whereLoopPrint(pTemplate, pBuilder->pWC);
vendor/sqlite3.c:133955:        whereLoopPrint(pToDel, pBuilder->pWC);
vendor/sqlite3.c:134031:          Expr *pRight = pTerm->pExpr->pRight;
vendor/sqlite3.c:134032:          testcase( pTerm->pExpr->op==TK_IS );
vendor/sqlite3.c:134070:  int nCmp = sqlite3ExprVectorSize(pTerm->pExpr->pLeft);
vendor/sqlite3.c:134080:    Expr *pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;
vendor/sqlite3.c:134081:    Expr *pRhs = pTerm->pExpr->pRight;
vendor/sqlite3.c:134123:** We have so far matched pBuilder->pNew->u.btree.nEq terms of the 
vendor/sqlite3.c:134126:** When this function is called, pBuilder->pNew->nOut contains the 
vendor/sqlite3.c:134140:  WhereInfo *pWInfo = pBuilder->pWInfo;  /* WHERE analyse context */
vendor/sqlite3.c:134160:  pNew = pBuilder->pNew;
vendor/sqlite3.c:134185:  pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, saved_nEq,
vendor/sqlite3.c:134196:    int nRecValid = pBuilder->nRecValid;
vendor/sqlite3.c:134222:      pBuilder->bldFlags |= SQLITE_BLDF_UNIQUE;
vendor/sqlite3.c:134224:      pBuilder->bldFlags |= SQLITE_BLDF_INDEXED;
vendor/sqlite3.c:134257:      }else if( ALWAYS(pExpr->x.pList && pExpr->x.pList->nExpr) ){
vendor/sqlite3.c:134259:        nIn = sqlite3LogEst(pExpr->x.pList->nExpr);
vendor/sqlite3.c:134345:            rc = whereEqualScanEst(pParse, pBuilder, pExpr->pRight, &nOut);
vendor/sqlite3.c:134347:            rc = whereInScanEst(pParse, pBuilder, pExpr->x.pList, &nOut);
vendor/sqlite3.c:134385:    whereLoopOutputAdjust(pBuilder->pWC, pNew, rSize);
vendor/sqlite3.c:134401:    pBuilder->nRecValid = nRecValid;
vendor/sqlite3.c:134470:  if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;
vendor/sqlite3.c:134473:    if( pExpr->op==TK_COLUMN && pExpr->iTable==iCursor ){
vendor/sqlite3.c:134474:      if( pExpr->iColumn<0 ) return 1;
vendor/sqlite3.c:134476:        if( pExpr->iColumn==pIndex->aiColumn[jj] ) return 1;
vendor/sqlite3.c:134481:        if( sqlite3ExprCompareSkip(pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){
vendor/sqlite3.c:134522:    if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)
vendor/sqlite3.c:134533:** is identified by pBuilder->pNew->iTab.  That table is guaranteed to be
vendor/sqlite3.c:134587:  pNew = pBuilder->pNew;
vendor/sqlite3.c:134588:  pWInfo = pBuilder->pWInfo;
vendor/sqlite3.c:134592:  pWC = pBuilder->pWC;
vendor/sqlite3.c:134629:  if( !pBuilder->pOrSet      /* Not part of an OR optimization */
vendor/sqlite3.c:134775:    pBuilder->bldFlags = 0;
vendor/sqlite3.c:134777:    if( pBuilder->bldFlags==SQLITE_BLDF_INDEXED ){
vendor/sqlite3.c:134785:    sqlite3Stat4ProbeFree(pBuilder->pRec);
vendor/sqlite3.c:134786:    pBuilder->nRecValid = 0;
vendor/sqlite3.c:134787:    pBuilder->pRec = 0;
vendor/sqlite3.c:134801:** be used by the virtual table identified by pBuilder->pNew->iTab. This
vendor/sqlite3.c:134828:  WhereClause *pWC = pBuilder->pWC;
vendor/sqlite3.c:134834:  WhereLoop *pNew = pBuilder->pNew;
vendor/sqlite3.c:134835:  Parse *pParse = pBuilder->pWInfo->pParse;
vendor/sqlite3.c:134836:  struct SrcList_item *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];
vendor/sqlite3.c:134950:** pBuilder->pNew->iTab.  That table is guaranteed to be a virtual table.
vendor/sqlite3.c:134991:  pWInfo = pBuilder->pWInfo;
vendor/sqlite3.c:134993:  pWC = pBuilder->pWC;
vendor/sqlite3.c:134994:  pNew = pBuilder->pNew;
vendor/sqlite3.c:134997:  p = allocateIndexInfo(pParse, pWC, mUnusable, pSrc, pBuilder->pOrderBy, 
vendor/sqlite3.c:135099:  WhereInfo *pWInfo = pBuilder->pWInfo;
vendor/sqlite3.c:135110:  pWC = pBuilder->pWC;
vendor/sqlite3.c:135112:  pNew = pBuilder->pNew;
vendor/sqlite3.c:135131:      WHERETRACE(0x200, ("Begin processing OR-clause %p\n", pTerm));
vendor/sqlite3.c:135147:        WHERETRACE(0x200, ("OR-term %d of %p has %d subterms:\n", 
vendor/sqlite3.c:135192:        ** of all sub-scans required by the OR-scan. However, due to rounding
vendor/sqlite3.c:135193:        ** errors, it may be that the cost of the OR-scan is equal to its
vendor/sqlite3.c:135208:      WHERETRACE(0x200, ("End processing OR-clause %p\n", pTerm));
vendor/sqlite3.c:135218:  WhereInfo *pWInfo = pBuilder->pWInfo;
vendor/sqlite3.c:135231:  pNew = pBuilder->pNew;
vendor/sqlite3.c:135297:  u8 isOrderDistinct;   /* All prior WhereLoops are order-distinct */
vendor/sqlite3.c:135327:  ** We say the WhereLoop is "order-distinct" if the set of columns from
vendor/sqlite3.c:135330:  ** order-distinct.   A WhereLoop that has no columns in the ORDER BY clause
vendor/sqlite3.c:135331:  ** is not order-distinct. To be order-distinct is not quite the same as being
vendor/sqlite3.c:135333:  ** are NULL and NULL values are equivalent for the purpose of order-distinct.
vendor/sqlite3.c:135334:  ** To be order-distinct, the columns must be UNIQUE and NOT NULL.
vendor/sqlite3.c:135338:  ** automatically order-distinct.
vendor/sqlite3.c:135377:      if( pOBExpr->op!=TK_COLUMN ) continue;
vendor/sqlite3.c:135378:      if( pOBExpr->iTable!=iCur ) continue;
vendor/sqlite3.c:135379:      pTerm = sqlite3WhereFindTerm(&pWInfo->sWC, iCur, pOBExpr->iColumn,
vendor/sqlite3.c:135390:      if( (pTerm->eOperator&(WO_EQ|WO_IS))!=0 && pOBExpr->iColumn>=0 ){
vendor/sqlite3.c:135395:        testcase( pTerm->pExpr->op==TK_IS );
vendor/sqlite3.c:135494:            if( pOBExpr->op!=TK_COLUMN ) continue;
vendor/sqlite3.c:135495:            if( pOBExpr->iTable!=iCur ) continue;
vendor/sqlite3.c:135496:            if( pOBExpr->iColumn!=iColumn ) continue;
vendor/sqlite3.c:135498:            Expr *pIdxExpr = pIndex->aColExpr->a[j].pExpr;
vendor/sqlite3.c:135558:  } /* End the loop over all WhereLoops from outer-most down to inner-most */
vendor/sqlite3.c:135628:  ** Or, if the order-by clause has X terms but only the last Y 
vendor/sqlite3.c:136052:  pWInfo = pBuilder->pWInfo;
vendor/sqlite3.c:136061:  pLoop = pBuilder->pNew;
vendor/sqlite3.c:136124:  if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_ConstFunc)==0 ){
vendor/sqlite3.c:136125:    pWalker->eCode = 0;
vendor/sqlite3.c:136199:** inner loops (or around the "..." if the test occurs within the inner-
vendor/sqlite3.c:136610:        /* This is one term of an OR-optimization using the PRIMARY KEY of a
vendor/sqlite3.c:136918:** at each "%%" line.  Also, any "P-a-r-s-e" identifer prefix (without the
vendor/sqlite3.c:136999:  ** For a compound SELECT statement, make sure p->pPrior->pNext==p for
vendor/sqlite3.c:137069:  /* If doNot is true, then add a TK_NOT Expr-node wrapper around the
vendor/sqlite3.c:137222:#define sqlite3ParserARG_FETCH Parse *pParse = yypParser->pParse
vendor/sqlite3.c:137223:#define sqlite3ParserARG_STORE yypParser->pParse = pParse
vendor/sqlite3.c:137888:  YYMINORTYPE minor;     /* The user-supplied minor token value.  This
vendor/sqlite3.c:138401:  pParser->yyhwm = 0;
vendor/sqlite3.c:138404:  pParser->yytos = NULL;
vendor/sqlite3.c:138405:  pParser->yystack = NULL;
vendor/sqlite3.c:138406:  pParser->yystksz = 0;
vendor/sqlite3.c:138408:    pParser->yystack = &pParser->yystk0;
vendor/sqlite3.c:138409:    pParser->yystksz = 1;
vendor/sqlite3.c:138413:  pParser->yyerrcnt = -1;
vendor/sqlite3.c:138415:  pParser->yytos = pParser->yystack;
vendor/sqlite3.c:138416:  pParser->yystack[0].stateno = 0;
vendor/sqlite3.c:138417:  pParser->yystack[0].major = 0;
vendor/sqlite3.c:138419:  pParser->yystackEnd = &pParser->yystack[YYSTACKDEPTH-1];
vendor/sqlite3.c:138475:sqlite3SelectDelete(pParse->db, (yypminor->yy243));
vendor/sqlite3.c:138481:sqlite3ExprDelete(pParse->db, (yypminor->yy190).pExpr);
vendor/sqlite3.c:138497:sqlite3ExprListDelete(pParse->db, (yypminor->yy148));
vendor/sqlite3.c:138505:sqlite3SrcListDelete(pParse->db, (yypminor->yy185));
vendor/sqlite3.c:138511:sqlite3WithDelete(pParse->db, (yypminor->yy285));
vendor/sqlite3.c:138522:sqlite3ExprDelete(pParse->db, (yypminor->yy72));
vendor/sqlite3.c:138529:sqlite3IdListDelete(pParse->db, (yypminor->yy254));
vendor/sqlite3.c:138535:sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy145));
vendor/sqlite3.c:138540:sqlite3IdListDelete(pParse->db, (yypminor->yy332).b);
vendor/sqlite3.c:138556:  assert( pParser->yytos!=0 );
vendor/sqlite3.c:138557:  assert( pParser->yytos > pParser->yystack );
vendor/sqlite3.c:138558:  yytos = pParser->yytos--;
vendor/sqlite3.c:138574:  while( pParser->yytos>pParser->yystack ) yy_pop_parser_stack(pParser);
vendor/sqlite3.c:138576:  if( pParser->yystack!=&pParser->yystk0 ) free(pParser->yystack);
vendor/sqlite3.c:138607:  return pParser->yyhwm;
vendor/sqlite3.c:138620:  int stateno = pParser->yytos->stateno;
vendor/sqlite3.c:138715:   while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
vendor/sqlite3.c:138733:         yyTracePrompt,yyTokenName[yypParser->yytos->major],
vendor/sqlite3.c:138737:         yyTracePrompt,yyTokenName[yypParser->yytos->major]);
vendor/sqlite3.c:138755:  yypParser->yytos++;
vendor/sqlite3.c:138757:  if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
vendor/sqlite3.c:138758:    yypParser->yyhwm++;
vendor/sqlite3.c:138759:    assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack) );
vendor/sqlite3.c:138763:  if( yypParser->yytos>yypParser->yystackEnd ){
vendor/sqlite3.c:138764:    yypParser->yytos--;
vendor/sqlite3.c:138769:  if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz] ){
vendor/sqlite3.c:138771:      yypParser->yytos--;
vendor/sqlite3.c:138780:  yytos = yypParser->yytos;
vendor/sqlite3.c:139140:  yymsp = yypParser->yytos;
vendor/sqlite3.c:139154:    if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
vendor/sqlite3.c:139155:      yypParser->yyhwm++;
vendor/sqlite3.c:139156:      assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack));
vendor/sqlite3.c:139160:    if( yypParser->yytos>=yypParser->yystackEnd ){
vendor/sqlite3.c:139165:    if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz-1] ){
vendor/sqlite3.c:139170:      yymsp = yypParser->yytos;
vendor/sqlite3.c:139343:{ yymsp[1].minor.yy194 = OE_None*0x0101; /* EV: R-19803-45884 */}
vendor/sqlite3.c:139361:{ yymsp[-1].minor.yy194 = OE_SetNull;  /* EV: R-33326-45252 */}
vendor/sqlite3.c:139364:{ yymsp[-1].minor.yy194 = OE_SetDflt;  /* EV: R-33326-45252 */}
vendor/sqlite3.c:139367:{ yymsp[0].minor.yy194 = OE_Cascade;  /* EV: R-33326-45252 */}
vendor/sqlite3.c:139370:{ yymsp[0].minor.yy194 = OE_Restrict; /* EV: R-33326-45252 */}
vendor/sqlite3.c:139373:{ yymsp[-1].minor.yy194 = OE_None;     /* EV: R-33326-45252 */}
vendor/sqlite3.c:139837:      if( yymsp[0].minor.yy190.pExpr ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy190.pExpr->iTable);
vendor/sqlite3.c:139863:    yylhsminor.yy190.pExpr->flags |= EP_Distinct;
vendor/sqlite3.c:139887:    yylhsminor.yy190.pExpr->x.pList = pList;
vendor/sqlite3.c:139918:  if( yymsp[-2].minor.yy190.pExpr ) yymsp[-2].minor.yy190.pExpr->flags |= EP_InfixFunc;
vendor/sqlite3.c:139932:  if( yymsp[-4].minor.yy190.pExpr ) yymsp[-4].minor.yy190.pExpr->flags |= EP_InfixFunc;
vendor/sqlite3.c:139973:    yymsp[-4].minor.yy190.pExpr->x.pList = pList;
vendor/sqlite3.c:140024:        yymsp[-4].minor.yy190.pExpr->x.pList = yymsp[-1].minor.yy148;
vendor/sqlite3.c:140073:    yymsp[-4].minor.yy190.pExpr->x.pList = yymsp[-1].minor.yy72 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy148,yymsp[-1].minor.yy72) : yymsp[-2].minor.yy148;
vendor/sqlite3.c:140244:    yymsp[-3].minor.yy190.pExpr->affinity = OE_Ignore;
vendor/sqlite3.c:140253:    yymsp[-5].minor.yy190.pExpr->affinity = (char)yymsp[-3].minor.yy194;
vendor/sqlite3.c:140419:    yypParser->yytos += yysize;
vendor/sqlite3.c:140423:    yypParser->yytos = yymsp;
vendor/sqlite3.c:140443:  while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
vendor/sqlite3.c:140484:  yypParser->yyerrcnt = -1;
vendor/sqlite3.c:140486:  assert( yypParser->yytos==yypParser->yystack );
vendor/sqlite3.c:140507:** <li> An option argument of a grammar-specified type.
vendor/sqlite3.c:140530:  assert( yypParser->yytos!=0 );
vendor/sqlite3.c:140547:      yypParser->yyerrcnt--;
vendor/sqlite3.c:140583:      if( yypParser->yyerrcnt<0 ){
vendor/sqlite3.c:140586:      yymx = yypParser->yytos->major;
vendor/sqlite3.c:140597:        while( yypParser->yytos >= yypParser->yystack
vendor/sqlite3.c:140600:                        yypParser->yytos->stateno,
vendor/sqlite3.c:140605:        if( yypParser->yytos < yypParser->yystack || yymajor==0 ){
vendor/sqlite3.c:140609:          yypParser->yyerrcnt = -1;
vendor/sqlite3.c:140616:      yypParser->yyerrcnt = 3;
vendor/sqlite3.c:140640:      if( yypParser->yyerrcnt<=0 ){
vendor/sqlite3.c:140643:      yypParser->yyerrcnt = 3;
vendor/sqlite3.c:140648:        yypParser->yyerrcnt = -1;
vendor/sqlite3.c:140654:  }while( yymajor!=YYNOCODE && yypParser->yytos>yypParser->yystack );
vendor/sqlite3.c:140660:    for(i=&yypParser->yystack[1]; i<=yypParser->yytos; i++){
vendor/sqlite3.c:140772:** lower-case ASCII equivalent.  On ASCII machines, this is just
vendor/sqlite3.c:140773:** an upper-to-lower case map.  On EBCDIC machines we also need
vendor/sqlite3.c:141169:  switch( aiClass[*z] ){  /* Switch on the character-class of the first byte
vendor/sqlite3.c:141185:        *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */
vendor/sqlite3.c:141218:      *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */
vendor/sqlite3.c:142013:/* IMPLEMENTATION-OF: R-46656-45156 The sqlite3_version[] string constant
vendor/sqlite3.c:142019:/* IMPLEMENTATION-OF: R-53536-42575 The sqlite3_libversion() function returns
vendor/sqlite3.c:142024:/* IMPLEMENTATION-OF: R-25063-23286 The sqlite3_sourceid() function returns a
vendor/sqlite3.c:142032:/* IMPLEMENTATION-OF: R-35210-63508 The sqlite3_libversion_number() function
vendor/sqlite3.c:142037:/* IMPLEMENTATION-OF: R-20790-14025 The sqlite3_threadsafe() function returns
vendor/sqlite3.c:142108:**    *  Calls to this routine from Y must block until the outer-most
vendor/sqlite3.c:142191:  ** IMPLEMENTATION-OF: R-00140-37445 SQLite automatically serializes calls
vendor/sqlite3.c:142348:#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0  /* IMP: R-54466-46756 */
vendor/sqlite3.c:142350:      /* EVIDENCE-OF: R-02748-19096 This option sets the threading mode to
vendor/sqlite3.c:142357:#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-20520-54086 */
vendor/sqlite3.c:142359:      /* EVIDENCE-OF: R-14374-42468 This option sets the threading mode to
vendor/sqlite3.c:142366:#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-59593-21810 */
vendor/sqlite3.c:142368:      /* EVIDENCE-OF: R-41220-51800 This option sets the threading mode to
vendor/sqlite3.c:142375:#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-63666-48755 */
vendor/sqlite3.c:142382:#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-14450-37597 */
vendor/sqlite3.c:142391:      /* EVIDENCE-OF: R-55594-21030 The SQLITE_CONFIG_MALLOC option takes a
vendor/sqlite3.c:142400:      /* EVIDENCE-OF: R-51213-46414 The SQLITE_CONFIG_GETMALLOC option takes a
vendor/sqlite3.c:142409:      /* EVIDENCE-OF: R-61275-35157 The SQLITE_CONFIG_MEMSTATUS option takes
vendor/sqlite3.c:142420:      /* EVIDENCE-OF: R-18761-36601 There are three arguments to
vendor/sqlite3.c:142430:      /* EVIDENCE-OF: R-39100-27317 The SQLITE_CONFIG_PCACHE_HDRSZ option takes
vendor/sqlite3.c:142452:      /* EVIDENCE-OF: R-63325-48378 The SQLITE_CONFIG_PCACHE2 option takes a
vendor/sqlite3.c:142460:      /* EVIDENCE-OF: R-22035-46182 The SQLITE_CONFIG_GETPCACHE2 option takes a
vendor/sqlite3.c:142471:/* EVIDENCE-OF: R-06626-12911 The SQLITE_CONFIG_HEAP option is only
vendor/sqlite3.c:142476:      /* EVIDENCE-OF: R-19854-42126 There are three arguments to
vendor/sqlite3.c:142492:        /* EVIDENCE-OF: R-49920-60189 If the first pointer (the memory pointer)
vendor/sqlite3.c:142502:        /* EVIDENCE-OF: R-61006-08918 If the memory pointer is not NULL then the
vendor/sqlite3.c:142537:    /* EVIDENCE-OF: R-55548-33817 The compile-time setting for URI filenames
vendor/sqlite3.c:142543:      /* EVIDENCE-OF: R-25451-61125 The SQLITE_CONFIG_URI option takes a single
vendor/sqlite3.c:142552:      /* EVIDENCE-OF: R-36592-02772 The SQLITE_CONFIG_COVERING_INDEX_SCAN
vendor/sqlite3.c:142570:      /* EVIDENCE-OF: R-58063-38258 SQLITE_CONFIG_MMAP_SIZE takes two 64-bit
vendor/sqlite3.c:142576:      /* EVIDENCE-OF: R-53367-43190 If either argument to this option is
vendor/sqlite3.c:142579:      ** EVIDENCE-OF: R-34993-45031 The maximum allowed mmap size will be
vendor/sqlite3.c:142594:#if SQLITE_OS_WIN && defined(SQLITE_WIN32_MALLOC) /* IMP: R-04780-55815 */
vendor/sqlite3.c:142596:      /* EVIDENCE-OF: R-34926-03360 SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit
vendor/sqlite3.c:142651:  sz = ROUNDDOWN8(sz);  /* IMP: R-33038-09382 */
vendor/sqlite3.c:142659:    pStart = sqlite3Malloc( sz*cnt );  /* IMP: R-61949-35727 */
vendor/sqlite3.c:142732:** Flush any dirty pages in the pager-cache for any attached database
vendor/sqlite3.c:142770:      /* IMP: R-06824-28531 */
vendor/sqlite3.c:142771:      /* IMP: R-36257-52125 */
vendor/sqlite3.c:142777:      void *pBuf = va_arg(ap, void*); /* IMP: R-26835-10964 */
vendor/sqlite3.c:142778:      int sz = va_arg(ap, int);       /* IMP: R-47871-25994 */
vendor/sqlite3.c:142779:      int cnt = va_arg(ap, int);      /* IMP: R-04460-53386 */
vendor/sqlite3.c:142796:      rc = SQLITE_ERROR; /* IMP: R-42790-23372 */
vendor/sqlite3.c:142847:  /* EVIDENCE-OF: R-65033-28449 The built-in BINARY collation compares
vendor/sqlite3.c:142857:      /* EVIDENCE-OF: R-31624-24737 RTRIM is like BINARY except that extra
vendor/sqlite3.c:142971:    pDestructor->nRef--;
vendor/sqlite3.c:142972:    if( pDestructor->nRef==0 ){
vendor/sqlite3.c:142973:      pDestructor->xDestroy(pDestructor->pUserData);
vendor/sqlite3.c:143030:    /* EVIDENCE-OF: R-63257-11740 Calling sqlite3_close() or
vendor/sqlite3.c:143651:        "unable to delete/modify user-function due to active statements");
vendor/sqlite3.c:143670:    pDestructor->nRef++;
vendor/sqlite3.c:144092:    /* EVIDENCE-OF: R-03996-12088 The M parameter must be a valid checkpoint
vendor/sqlite3.c:144129:  /* EVIDENCE-OF: R-41613-20553 The sqlite3_wal_checkpoint(D,X) is equivalent to
vendor/sqlite3.c:144412:  SQLITE_MAX_VARIABLE_NUMBER,      /* IMP: R-38091-32352 */
vendor/sqlite3.c:144475:  /* EVIDENCE-OF: R-30189-54097 For each limit category SQLITE_LIMIT_NAME
vendor/sqlite3.c:144500:  if( newLimit>=0 ){                   /* IMP: R-52476-28732 */
vendor/sqlite3.c:144502:      newLimit = aHardLimit[limitId];  /* IMP: R-51463-25634 */
vendor/sqlite3.c:144506:  return oldLimit;                     /* IMP: R-53341-35419 */
vendor/sqlite3.c:144550:  if( ((flags & SQLITE_OPEN_URI)             /* IMP: R-48725-32206 */
vendor/sqlite3.c:144551:            || sqlite3GlobalConfig.bOpenUri) /* IMP: R-51689-46548 */
vendor/sqlite3.c:144552:   && nUri>=5 && memcmp(zUri, "file:", 5)==0 /* IMP: R-57884-37496 */
vendor/sqlite3.c:144894:  ** EVIDENCE-OF: R-52786-44878 SQLite defines three built-in collating
vendor/sqlite3.c:144905:  /* EVIDENCE-OF: R-08308-17224 The default collating function for all
vendor/sqlite3.c:144931:    rc = SQLITE_MISUSE_BKPT;  /* IMP: R-65497-44594 */
vendor/sqlite3.c:146873:  **   CREATE .. USING fts3( ... , tokenizer <tokenizer-name> arg1 arg2)
vendor/sqlite3.c:147331:  ** by special insert command 'test-no-incr-doclist'.  */
vendor/sqlite3.c:147883:  p->pTokenizer->pModule->xDestroy(p->pTokenizer);
vendor/sqlite3.c:148129:  *pnKey = (int)(zCsr-z);
vendor/sqlite3.c:148203:** table has the three user-defined columns "a", "b", and "c", the following
vendor/sqlite3.c:148256:** user-defined text column).
vendor/sqlite3.c:148261:** user-defined text columns, the following string is returned:
vendor/sqlite3.c:148854:      pTokenizer->pModule->xDestroy(pTokenizer);
vendor/sqlite3.c:149030:    if( pOrder->iColumn<0 || pOrder->iColumn==p->nColumn+1 ){
vendor/sqlite3.c:149031:      if( pOrder->desc ){
vendor/sqlite3.c:149065:** Finalize the statement handle at pCsr->pStmt.
vendor/sqlite3.c:149072:  if( pCsr->bSeekStmt ){
vendor/sqlite3.c:149073:    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:149075:      p->pSeekStmt = pCsr->pStmt;
vendor/sqlite3.c:149076:      sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:149077:      pCsr->pStmt = 0;
vendor/sqlite3.c:149079:    pCsr->bSeekStmt = 0;
vendor/sqlite3.c:149081:  sqlite3_finalize(pCsr->pStmt);
vendor/sqlite3.c:149091:  sqlite3_free(pCsr->aDoclist);
vendor/sqlite3.c:149092:  sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
vendor/sqlite3.c:149093:  sqlite3Fts3ExprFree(pCsr->pExpr);
vendor/sqlite3.c:149094:  memset(&(&pCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));
vendor/sqlite3.c:149103:  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
vendor/sqlite3.c:149105:  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
vendor/sqlite3.c:149111:** If pCsr->pStmt has not been prepared (i.e. if pCsr->pStmt==0), then
vendor/sqlite3.c:149116:** (or the equivalent for a content=xxx table) and set pCsr->pStmt to
vendor/sqlite3.c:149121:  if( pCsr->pStmt==0 ){
vendor/sqlite3.c:149122:    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:149125:      pCsr->pStmt = p->pSeekStmt;
vendor/sqlite3.c:149130:      rc = sqlite3_prepare_v3(p->db, zSql,-1,SQLITE_PREPARE_PERSISTENT,&pCsr->pStmt,0);
vendor/sqlite3.c:149133:    if( rc==SQLITE_OK ) pCsr->bSeekStmt = 1;
vendor/sqlite3.c:149139:** Position the pCsr->pStmt statement so that it is on the row
vendor/sqlite3.c:149145:  if( pCsr->isRequireSeek ){
vendor/sqlite3.c:149148:      sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);
vendor/sqlite3.c:149149:      pCsr->isRequireSeek = 0;
vendor/sqlite3.c:149150:      if( SQLITE_ROW==sqlite3_step(pCsr->pStmt) ){
vendor/sqlite3.c:149153:        rc = sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:149154:        if( rc==SQLITE_OK && ((Fts3Table *)pCsr->base.pVtab)->zContentTbl==0 ){
vendor/sqlite3.c:149159:          pCsr->isEof = 1;
vendor/sqlite3.c:150126:** doclists to merge, the merging is done pair-wise using the TermSelect
vendor/sqlite3.c:150202:** Append SegReader object pNew to the end of the pCsr->apSegment[] array.
vendor/sqlite3.c:150208:  if( (pCsr->nSegment%16)==0 ){
vendor/sqlite3.c:150210:    int nByte = (pCsr->nSegment + 16)*sizeof(Fts3SegReader*);
vendor/sqlite3.c:150211:    apNew = (Fts3SegReader **)sqlite3_realloc(pCsr->apSegment, nByte);
vendor/sqlite3.c:150216:    pCsr->apSegment = apNew;
vendor/sqlite3.c:150218:  pCsr->apSegment[pCsr->nSegment++] = pNew;
vendor/sqlite3.c:150282:      rc = sqlite3Fts3SegReaderNew(pCsr->nSegment+1, 
vendor/sqlite3.c:150374:    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:150380:          rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid, 
vendor/sqlite3.c:150383:          pSegcsr->bLookup = 1;
vendor/sqlite3.c:150390:          rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid, 
vendor/sqlite3.c:150395:                p, pCsr->iLangid, zTerm, nTerm, pSegcsr
vendor/sqlite3.c:150403:      rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid, 
vendor/sqlite3.c:150406:      pSegcsr->bLookup = !isPrefix;
vendor/sqlite3.c:150435:  TermSelect tsc;                 /* Object for pair-wise doclist merging */
vendor/sqlite3.c:150453:    rc = fts3TermSelectMerge(p, &tsc, pSegcsr->aDoclist, pSegcsr->nDoclist);
vendor/sqlite3.c:150512:  if( pCsr->eSearch==FTS3_DOCID_SEARCH || pCsr->eSearch==FTS3_FULLSCAN_SEARCH ){
vendor/sqlite3.c:150513:    if( SQLITE_ROW!=sqlite3_step(pCsr->pStmt) ){
vendor/sqlite3.c:150514:      pCsr->isEof = 1;
vendor/sqlite3.c:150515:      rc = sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:150517:      pCsr->iPrevId = sqlite3_column_int64(pCsr->pStmt, 0);
vendor/sqlite3.c:150523:  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
vendor/sqlite3.c:150580:  Fts3Table *p = (Fts3Table *)pCursor->pVtab;
vendor/sqlite3.c:150608:  pCsr->iMinDocid = fts3DocidRange(pDocidGe, SMALLEST_INT64);
vendor/sqlite3.c:150609:  pCsr->iMaxDocid = fts3DocidRange(pDocidLe, LARGEST_INT64);
vendor/sqlite3.c:150612:    pCsr->bDesc = (idxStr[0]=='D');
vendor/sqlite3.c:150614:    pCsr->bDesc = p->bDescIdx;
vendor/sqlite3.c:150616:  pCsr->eSearch = (i16)eSearch;
vendor/sqlite3.c:150626:    pCsr->iLangid = 0;
vendor/sqlite3.c:150627:    if( pLangid ) pCsr->iLangid = sqlite3_value_int(pLangid);
vendor/sqlite3.c:150630:    rc = sqlite3Fts3ExprParse(p->pTokenizer, pCsr->iLangid,
vendor/sqlite3.c:150631:        p->azColumn, p->bFts4, p->nColumn, iCol, zQuery, -1, &pCsr->pExpr, 
vendor/sqlite3.c:150641:    pCsr->pNextId = pCsr->aDoclist;
vendor/sqlite3.c:150642:    pCsr->iPrevId = 0;
vendor/sqlite3.c:150654:          p->zReadExprlist, pCsr->iMinDocid, pCsr->iMaxDocid,
vendor/sqlite3.c:150655:          (pCsr->bDesc ? "DESC" : "ASC")
vendor/sqlite3.c:150659:          p->zReadExprlist, (pCsr->bDesc ? "DESC" : "ASC")
vendor/sqlite3.c:150663:      rc = sqlite3_prepare_v3(p->db,zSql,-1,SQLITE_PREPARE_PERSISTENT,&pCsr->pStmt,0);
vendor/sqlite3.c:150671:      rc = sqlite3_bind_value(pCsr->pStmt, 1, pCons);
vendor/sqlite3.c:150685:  if( pCsr->isEof ){
vendor/sqlite3.c:150687:    pCsr->isEof = 1;
vendor/sqlite3.c:150689:  return pCsr->isEof;
vendor/sqlite3.c:150700:  *pRowid = pCsr->iPrevId;
vendor/sqlite3.c:150722:  Fts3Table *p = (Fts3Table *)pCursor->pVtab;
vendor/sqlite3.c:150735:      sqlite3_result_int64(pCtx, pCsr->iPrevId);
vendor/sqlite3.c:150739:      if( pCsr->pExpr ){
vendor/sqlite3.c:150740:        sqlite3_result_int64(pCtx, pCsr->iLangid);
vendor/sqlite3.c:150754:      if( rc==SQLITE_OK && sqlite3_data_count(pCsr->pStmt)-1>iCol ){
vendor/sqlite3.c:150755:        sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol+1));
vendor/sqlite3.c:150760:  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
vendor/sqlite3.c:150803:  const u32 nMinMerge = 64;       /* Minimum amount of incr-merge work to do */
vendor/sqlite3.c:150815:    int A;                        /* Incr-merge parameter A */
vendor/sqlite3.c:151046:  p = (Fts3Table *)pCursor->base.pVtab;
vendor/sqlite3.c:151403:    if( pExpr->eType==FTSQUERY_PHRASE ){
vendor/sqlite3.c:151405:      int nToken = pExpr->pPhrase->nToken;
vendor/sqlite3.c:151408:        Fts3PhraseToken *pToken = &pExpr->pPhrase->aToken[i];
vendor/sqlite3.c:151417:      assert( pExpr->pPhrase->iDoclistToken==0 );
vendor/sqlite3.c:151418:      pExpr->pPhrase->iDoclistToken = -1;
vendor/sqlite3.c:151420:      *pnOr += (pExpr->eType==FTSQUERY_OR);
vendor/sqlite3.c:151421:      fts3EvalAllocateReaders(pCsr, pExpr->pLeft, pnToken, pnOr, pRc);
vendor/sqlite3.c:151422:      fts3EvalAllocateReaders(pCsr, pExpr->pRight, pnToken, pnOr, pRc);
vendor/sqlite3.c:151505:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:151591:      pPhrase->doclist.iDocid = pCsr->iPrevId;
vendor/sqlite3.c:151650:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:151661:   && pCsr->bDesc==pTab->bDescIdx 
vendor/sqlite3.c:151669:    if( pToken->bFirst || (pToken->pSegcsr!=0 && !pToken->pSegcsr->bLookup) ){
vendor/sqlite3.c:151921:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:151934:    int bDescDoclist = pCsr->bDesc;
vendor/sqlite3.c:152021:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:152025:  }else if( pCsr->bDesc!=pTab->bDescIdx && pDL->nAll ){
vendor/sqlite3.c:152059:    if( pExpr->eType==FTSQUERY_PHRASE ){
vendor/sqlite3.c:152060:      int nToken = pExpr->pPhrase->nToken;
vendor/sqlite3.c:152064:          if( pExpr->pPhrase->aToken[i].pDeferred==0 ) break;
vendor/sqlite3.c:152066:        pExpr->bDeferred = (i==nToken);
vendor/sqlite3.c:152068:      *pRc = fts3EvalPhraseStart(pCsr, 1, pExpr->pPhrase);
vendor/sqlite3.c:152070:      fts3EvalStartReaders(pCsr, pExpr->pLeft, pRc);
vendor/sqlite3.c:152071:      fts3EvalStartReaders(pCsr, pExpr->pRight, pRc);
vendor/sqlite3.c:152072:      pExpr->bDeferred = (pExpr->pLeft->bDeferred && pExpr->pRight->bDeferred);
vendor/sqlite3.c:152115:    if( pExpr->eType==FTSQUERY_PHRASE ){
vendor/sqlite3.c:152116:      Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:152127:    }else if( pExpr->eType!=FTSQUERY_NOT ){
vendor/sqlite3.c:152128:      assert( pExpr->eType==FTSQUERY_OR
vendor/sqlite3.c:152129:           || pExpr->eType==FTSQUERY_AND
vendor/sqlite3.c:152130:           || pExpr->eType==FTSQUERY_NEAR
vendor/sqlite3.c:152132:      assert( pExpr->pLeft && pExpr->pRight );
vendor/sqlite3.c:152133:      if( pExpr->eType==FTSQUERY_OR ){
vendor/sqlite3.c:152134:        pRoot = pExpr->pLeft;
vendor/sqlite3.c:152138:      fts3EvalTokenCosts(pCsr, pRoot, pExpr->pLeft, ppTC, ppOr, pRc);
vendor/sqlite3.c:152139:      if( pExpr->eType==FTSQUERY_OR ){
vendor/sqlite3.c:152140:        pRoot = pExpr->pRight;
vendor/sqlite3.c:152144:      fts3EvalTokenCosts(pCsr, pRoot, pExpr->pRight, ppTC, ppOr, pRc);
vendor/sqlite3.c:152162:  if( pCsr->nRowAvg==0 ){
vendor/sqlite3.c:152174:    Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;
vendor/sqlite3.c:152196:    pCsr->nDoc = nDoc;
vendor/sqlite3.c:152197:    pCsr->nRowAvg = (int)(((nByte / nDoc) + p->nPgsz) / p->nPgsz);
vendor/sqlite3.c:152198:    assert( pCsr->nRowAvg>0 ); 
vendor/sqlite3.c:152202:  *pnPage = pCsr->nRowAvg;
vendor/sqlite3.c:152226:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:152308:      ** for-loop. Except, limit the value to 2^24 to prevent it from 
vendor/sqlite3.c:152343:** the full-text query currently stored in pCsr->pExpr. To iterate through
vendor/sqlite3.c:152349:**      if( pCsr->bEof ) break;
vendor/sqlite3.c:152350:**      ... return row pCsr->iPrevId to the caller ...
vendor/sqlite3.c:152354:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:152360:  fts3EvalAllocateReaders(pCsr, pCsr->pExpr, &nToken, &nOr, &rc);
vendor/sqlite3.c:152380:      fts3EvalTokenCosts(pCsr, 0, pCsr->pExpr, &pTC, &ppOr, &rc);
vendor/sqlite3.c:152382:      nOr = (int)(ppOr-apOr);
vendor/sqlite3.c:152396:  fts3EvalStartReaders(pCsr, pCsr->pExpr, &rc);
vendor/sqlite3.c:152514:    int bDescDoclist = pCsr->bDesc;         /* Used by DOCID_CMP() macro */
vendor/sqlite3.c:152515:    assert( pExpr->bEof==0 );
vendor/sqlite3.c:152516:    pExpr->bStart = 1;
vendor/sqlite3.c:152518:    switch( pExpr->eType ){
vendor/sqlite3.c:152521:        Fts3Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:152522:        Fts3Expr *pRight = pExpr->pRight;
vendor/sqlite3.c:152529:          pExpr->iDocid = pRight->iDocid;
vendor/sqlite3.c:152530:          pExpr->bEof = pRight->bEof;
vendor/sqlite3.c:152535:          pExpr->iDocid = pLeft->iDocid;
vendor/sqlite3.c:152536:          pExpr->bEof = pLeft->bEof;
vendor/sqlite3.c:152550:          pExpr->iDocid = pLeft->iDocid;
vendor/sqlite3.c:152551:          pExpr->bEof = (pLeft->bEof || pRight->bEof);
vendor/sqlite3.c:152552:          if( pExpr->eType==FTSQUERY_NEAR && pExpr->bEof ){
vendor/sqlite3.c:152574:        Fts3Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:152575:        Fts3Expr *pRight = pExpr->pRight;
vendor/sqlite3.c:152590:        pExpr->bEof = (pLeft->bEof && pRight->bEof);
vendor/sqlite3.c:152593:          pExpr->iDocid = pLeft->iDocid;
vendor/sqlite3.c:152595:          pExpr->iDocid = pRight->iDocid;
vendor/sqlite3.c:152602:        Fts3Expr *pLeft = pExpr->pLeft;
vendor/sqlite3.c:152603:        Fts3Expr *pRight = pExpr->pRight;
vendor/sqlite3.c:152619:        pExpr->iDocid = pLeft->iDocid;
vendor/sqlite3.c:152620:        pExpr->bEof = pLeft->bEof;
vendor/sqlite3.c:152625:        Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:152627:        *pRc = fts3EvalPhraseNext(pCsr, pPhrase, &pExpr->bEof);
vendor/sqlite3.c:152628:        pExpr->iDocid = pPhrase->doclist.iDocid;
vendor/sqlite3.c:152641:** (Fts3Expr->pPhrase.doclist.pList/nList) for each phrase in the expression. 
vendor/sqlite3.c:152661:  **                          +--NEAR--+      <-- root of NEAR query
vendor/sqlite3.c:152663:  **                     +--NEAR--+   "z"
vendor/sqlite3.c:152665:  **                +--NEAR--+   "y"
vendor/sqlite3.c:152674:   && pExpr->eType==FTSQUERY_NEAR 
vendor/sqlite3.c:152675:   && (pExpr->pParent==0 || pExpr->pParent->eType!=FTSQUERY_NEAR)
vendor/sqlite3.c:152701:      aPoslist = pExpr->pRight->pPhrase->doclist.pList;
vendor/sqlite3.c:152702:      nToken = pExpr->pRight->pPhrase->nToken;
vendor/sqlite3.c:152703:      for(p=pExpr->pLeft; p && res; p=p->pLeft){
vendor/sqlite3.c:152739:    switch( pExpr->eType ){
vendor/sqlite3.c:152743:            fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc)
vendor/sqlite3.c:152744:         && fts3EvalTestExpr(pCsr, pExpr->pRight, pRc)
vendor/sqlite3.c:152764:         && pExpr->eType==FTSQUERY_NEAR 
vendor/sqlite3.c:152765:         && (pExpr->pParent==0 || pExpr->pParent->eType!=FTSQUERY_NEAR)
vendor/sqlite3.c:152769:            if( p->pRight->iDocid==pCsr->iPrevId ){
vendor/sqlite3.c:152773:          if( p->iDocid==pCsr->iPrevId ){
vendor/sqlite3.c:152781:        int bHit1 = fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc);
vendor/sqlite3.c:152782:        int bHit2 = fts3EvalTestExpr(pCsr, pExpr->pRight, pRc);
vendor/sqlite3.c:152789:            fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc)
vendor/sqlite3.c:152790:         && !fts3EvalTestExpr(pCsr, pExpr->pRight, pRc)
vendor/sqlite3.c:152796:        if( pCsr->pDeferred 
vendor/sqlite3.c:152797:         && (pExpr->iDocid==pCsr->iPrevId || pExpr->bDeferred)
vendor/sqlite3.c:152799:          Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:152800:          assert( pExpr->bDeferred || pPhrase->doclist.bFreeList==0 );
vendor/sqlite3.c:152801:          if( pExpr->bDeferred ){
vendor/sqlite3.c:152806:          pExpr->iDocid = pCsr->iPrevId;
vendor/sqlite3.c:152810:          bHit = (pExpr->bEof==0 && pExpr->iDocid==pCsr->iPrevId);
vendor/sqlite3.c:152854:    if( pCsr->pDeferred ){
vendor/sqlite3.c:152860:    bMiss = (0==fts3EvalTestExpr(pCsr, pCsr->pExpr, &rc));
vendor/sqlite3.c:152875:  Fts3Expr *pExpr = pCsr->pExpr;
vendor/sqlite3.c:152876:  assert( pCsr->isEof==0 );
vendor/sqlite3.c:152878:    pCsr->isEof = 1;
vendor/sqlite3.c:152881:      if( pCsr->isRequireSeek==0 ){
vendor/sqlite3.c:152882:        sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:152884:      assert( sqlite3_data_count(pCsr->pStmt)==0 );
vendor/sqlite3.c:152886:      pCsr->isEof = pExpr->bEof;
vendor/sqlite3.c:152887:      pCsr->isRequireSeek = 1;
vendor/sqlite3.c:152888:      pCsr->isMatchinfoNeeded = 1;
vendor/sqlite3.c:152889:      pCsr->iPrevId = pExpr->iDocid;
vendor/sqlite3.c:152890:    }while( pCsr->isEof==0 && sqlite3Fts3EvalTestDeferred(pCsr, &rc) );
vendor/sqlite3.c:152896:        (pCsr->bDesc==0 && pCsr->iPrevId>pCsr->iMaxDocid)
vendor/sqlite3.c:152897:     || (pCsr->bDesc!=0 && pCsr->iPrevId<pCsr->iMinDocid)
vendor/sqlite3.c:152899:    pCsr->isEof = 1;
vendor/sqlite3.c:152920:    Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:152940:    pExpr->iDocid = 0;
vendor/sqlite3.c:152941:    pExpr->bEof = 0;
vendor/sqlite3.c:152942:    pExpr->bStart = 0;
vendor/sqlite3.c:152944:    fts3EvalRestart(pCsr, pExpr->pLeft, pRc);
vendor/sqlite3.c:152945:    fts3EvalRestart(pCsr, pExpr->pRight, pRc);
vendor/sqlite3.c:152959:    Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:152976:        pExpr->aMI[iCol*3 + 1] += iCnt;
vendor/sqlite3.c:152977:        pExpr->aMI[iCol*3 + 2] += (iCnt>0);
vendor/sqlite3.c:152984:    fts3EvalUpdateCounts(pExpr->pLeft);
vendor/sqlite3.c:152985:    fts3EvalUpdateCounts(pExpr->pRight);
vendor/sqlite3.c:153006:  assert( pExpr->eType==FTSQUERY_PHRASE );
vendor/sqlite3.c:153007:  if( pExpr->aMI==0 ){
vendor/sqlite3.c:153008:    Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:153012:    sqlite3_int64 iPrevId = pCsr->iPrevId;
vendor/sqlite3.c:153036:    while( pCsr->isEof==0 && rc==SQLITE_OK ){
vendor/sqlite3.c:153040:        if( pCsr->isRequireSeek==0 ) sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:153041:        assert( sqlite3_data_count(pCsr->pStmt)==0 );
vendor/sqlite3.c:153045:        pCsr->isEof = pRoot->bEof;
vendor/sqlite3.c:153046:        pCsr->isRequireSeek = 1;
vendor/sqlite3.c:153047:        pCsr->isMatchinfoNeeded = 1;
vendor/sqlite3.c:153048:        pCsr->iPrevId = pRoot->iDocid;
vendor/sqlite3.c:153049:      }while( pCsr->isEof==0 
vendor/sqlite3.c:153054:      if( rc==SQLITE_OK && pCsr->isEof==0 ){
vendor/sqlite3.c:153059:    pCsr->isEof = 0;
vendor/sqlite3.c:153060:    pCsr->iPrevId = iPrevId;
vendor/sqlite3.c:153116:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:153120:  if( pExpr->bDeferred && pExpr->pParent->eType!=FTSQUERY_NEAR ){
vendor/sqlite3.c:153121:    assert( pCsr->nDoc>0 );
vendor/sqlite3.c:153123:      aiOut[iCol*3 + 1] = (u32)pCsr->nDoc;
vendor/sqlite3.c:153124:      aiOut[iCol*3 + 2] = (u32)pCsr->nDoc;
vendor/sqlite3.c:153129:      assert( pExpr->aMI );
vendor/sqlite3.c:153131:        aiOut[iCol*3 + 1] = pExpr->aMI[iCol*3 + 1];
vendor/sqlite3.c:153132:        aiOut[iCol*3 + 2] = pExpr->aMI[iCol*3 + 2];
vendor/sqlite3.c:153165:  Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:153166:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:153179:  iDocid = pExpr->iDocid;
vendor/sqlite3.c:153181:  if( iDocid!=pCsr->iPrevId || pExpr->bEof ){
vendor/sqlite3.c:153192:    ** pCsr->iPrevId may lie earlier in the doclist buffer. Or, if the
vendor/sqlite3.c:153196:    for(p=pExpr->pParent; p; p=p->pParent){
vendor/sqlite3.c:153207:      int bEofSave = pNear->bEof;
vendor/sqlite3.c:153209:      while( rc==SQLITE_OK && !pNear->bEof ){
vendor/sqlite3.c:153211:        if( bEofSave==0 && pNear->iDocid==iDocid ) break;
vendor/sqlite3.c:153216:      while( rc==SQLITE_OK && !pNear->bEof ){
vendor/sqlite3.c:153234:      if( pCsr->bDesc==bDescDoclist ){
vendor/sqlite3.c:153237:        while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)<0 ) && bEof==0 ){
vendor/sqlite3.c:153245:        while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)>0 ) && bEof==0 ){
vendor/sqlite3.c:153255:      if( bEof || iDocid!=pCsr->iPrevId ) bMatch = 0;
vendor/sqlite3.c:153572:  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
vendor/sqlite3.c:153576:  sqlite3Fts3SegReaderFinish(&pCsr->csr);
vendor/sqlite3.c:153577:  sqlite3_free((void *)pCsr->filter.zTerm);
vendor/sqlite3.c:153578:  sqlite3_free(pCsr->zStop);
vendor/sqlite3.c:153579:  sqlite3_free(pCsr->aStat);
vendor/sqlite3.c:153585:  if( nSize>pCsr->nStat ){
vendor/sqlite3.c:153587:    aNew = (struct Fts3auxColstats *)sqlite3_realloc(pCsr->aStat, 
vendor/sqlite3.c:153591:    memset(&aNew[pCsr->nStat], 0, 
vendor/sqlite3.c:153592:        sizeof(struct Fts3auxColstats) * (nSize - pCsr->nStat)
vendor/sqlite3.c:153594:    pCsr->aStat = aNew;
vendor/sqlite3.c:153595:    pCsr->nStat = nSize;
vendor/sqlite3.c:153605:  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
vendor/sqlite3.c:153609:  pCsr->iRowid++;
vendor/sqlite3.c:153611:  for(pCsr->iCol++; pCsr->iCol<pCsr->nStat; pCsr->iCol++){
vendor/sqlite3.c:153612:    if( pCsr->aStat[pCsr->iCol].nDoc>0 ) return SQLITE_OK;
vendor/sqlite3.c:153615:  rc = sqlite3Fts3SegReaderStep(pFts3, &pCsr->csr);
vendor/sqlite3.c:153618:    int nDoclist = pCsr->csr.nDoclist;
vendor/sqlite3.c:153619:    char *aDoclist = pCsr->csr.aDoclist;
vendor/sqlite3.c:153624:    if( pCsr->zStop ){
vendor/sqlite3.c:153625:      int n = (pCsr->nStop<pCsr->csr.nTerm) ? pCsr->nStop : pCsr->csr.nTerm;
vendor/sqlite3.c:153626:      int mc = memcmp(pCsr->zStop, pCsr->csr.zTerm, n);
vendor/sqlite3.c:153627:      if( mc<0 || (mc==0 && pCsr->csr.nTerm>pCsr->nStop) ){
vendor/sqlite3.c:153628:        pCsr->isEof = 1;
vendor/sqlite3.c:153634:    memset(pCsr->aStat, 0, sizeof(struct Fts3auxColstats) * pCsr->nStat);
vendor/sqlite3.c:153644:          pCsr->aStat[0].nDoc++;
vendor/sqlite3.c:153660:            pCsr->aStat[1].nDoc++;
vendor/sqlite3.c:153671:            pCsr->aStat[iCol+1].nOcc++;
vendor/sqlite3.c:153672:            pCsr->aStat[0].nOcc++;
vendor/sqlite3.c:153680:          pCsr->aStat[iCol+1].nDoc++;
vendor/sqlite3.c:153686:    pCsr->iCol = 0;
vendor/sqlite3.c:153689:    pCsr->isEof = 1;
vendor/sqlite3.c:153705:  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
vendor/sqlite3.c:153741:  testcase(pCsr->filter.zTerm);
vendor/sqlite3.c:153742:  sqlite3Fts3SegReaderFinish(&pCsr->csr);
vendor/sqlite3.c:153743:  sqlite3_free((void *)pCsr->filter.zTerm);
vendor/sqlite3.c:153744:  sqlite3_free(pCsr->aStat);
vendor/sqlite3.c:153745:  memset(&pCsr->csr, 0, ((u8*)&pCsr[1]) - (u8*)&pCsr->csr);
vendor/sqlite3.c:153747:  pCsr->filter.flags = FTS3_SEGMENT_REQUIRE_POS|FTS3_SEGMENT_IGNORE_EMPTY;
vendor/sqlite3.c:153748:  if( isScan ) pCsr->filter.flags |= FTS3_SEGMENT_SCAN;
vendor/sqlite3.c:153754:      pCsr->filter.zTerm = sqlite3_mprintf("%s", zStr);
vendor/sqlite3.c:153755:      pCsr->filter.nTerm = sqlite3_value_bytes(apVal[0]);
vendor/sqlite3.c:153756:      if( pCsr->filter.zTerm==0 ) return SQLITE_NOMEM;
vendor/sqlite3.c:153761:    pCsr->zStop = sqlite3_mprintf("%s", sqlite3_value_text(apVal[iLe]));
vendor/sqlite3.c:153762:    pCsr->nStop = sqlite3_value_bytes(apVal[iLe]);
vendor/sqlite3.c:153763:    if( pCsr->zStop==0 ) return SQLITE_NOMEM;
vendor/sqlite3.c:153776:  pCsr->iLangid = iLangVal;
vendor/sqlite3.c:153779:      pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
vendor/sqlite3.c:153782:    rc = sqlite3Fts3SegReaderStart(pFts3, &pCsr->csr, &pCsr->filter);
vendor/sqlite3.c:153794:  return pCsr->isEof;
vendor/sqlite3.c:153846:  *pRowid = pCsr->iRowid;
vendor/sqlite3.c:154027:  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
vendor/sqlite3.c:154034:    pCsr->pTokenizer = pTokenizer;
vendor/sqlite3.c:154073:  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
vendor/sqlite3.c:154170:  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
vendor/sqlite3.c:154624:        while( pIter->pLeft ){
vendor/sqlite3.c:154625:          pIter = pIter->pLeft;
vendor/sqlite3.c:154627:        pIter->pLeft = pRet;
vendor/sqlite3.c:155042:  switch( pExpr->eType ){
vendor/sqlite3.c:155044:      Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:155058:      zBuf = sqlite3_mprintf("%zNEAR/%d ", zBuf, pExpr->nNear);
vendor/sqlite3.c:155072:  if( zBuf ) zBuf = exprToString(pExpr->pLeft, zBuf);
vendor/sqlite3.c:155075:  if( zBuf ) zBuf = exprToString(pExpr->pRight, zBuf);
vendor/sqlite3.c:155135:  pTokenizer->pModule = pModule;
vendor/sqlite3.c:155910:** Any upper-case characters in the US-ASCII character set ([A-Z])
vendor/sqlite3.c:155911:** are converted to lower case.  Upper-case UTF characters are
vendor/sqlite3.c:156227:** The set of routines that implement the porter-stemmer tokenizer
vendor/sqlite3.c:156570:  pTokenizer->pModule = p;
vendor/sqlite3.c:156937:  simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer;
vendor/sqlite3.c:157025:**       <tokenizer-name>, <arg-1>, ...
vendor/sqlite3.c:157289:  if( pCsr->pCsr ){
vendor/sqlite3.c:157290:    Fts3tokTable *pTab = (Fts3tokTable *)(pCsr->base.pVtab);
vendor/sqlite3.c:157291:    pTab->pMod->xClose(pCsr->pCsr);
vendor/sqlite3.c:157292:    pCsr->pCsr = 0;
vendor/sqlite3.c:157294:  sqlite3_free(pCsr->zInput);
vendor/sqlite3.c:157295:  pCsr->zInput = 0;
vendor/sqlite3.c:157296:  pCsr->zToken = 0;
vendor/sqlite3.c:157297:  pCsr->nToken = 0;
vendor/sqlite3.c:157298:  pCsr->iStart = 0;
vendor/sqlite3.c:157299:  pCsr->iEnd = 0;
vendor/sqlite3.c:157300:  pCsr->iPos = 0;
vendor/sqlite3.c:157301:  pCsr->iRowid = 0;
vendor/sqlite3.c:157320:  Fts3tokTable *pTab = (Fts3tokTable *)(pCursor->pVtab);
vendor/sqlite3.c:157323:  pCsr->iRowid++;
vendor/sqlite3.c:157324:  rc = pTab->pMod->xNext(pCsr->pCsr,
vendor/sqlite3.c:157325:      &pCsr->zToken, &pCsr->nToken,
vendor/sqlite3.c:157326:      &pCsr->iStart, &pCsr->iEnd, &pCsr->iPos
vendor/sqlite3.c:157349:  Fts3tokTable *pTab = (Fts3tokTable *)(pCursor->pVtab);
vendor/sqlite3.c:157357:    pCsr->zInput = sqlite3_malloc(nByte+1);
vendor/sqlite3.c:157358:    if( pCsr->zInput==0 ){
vendor/sqlite3.c:157361:      memcpy(pCsr->zInput, zByte, nByte);
vendor/sqlite3.c:157362:      pCsr->zInput[nByte] = 0;
vendor/sqlite3.c:157363:      rc = pTab->pMod->xOpen(pTab->pTok, pCsr->zInput, nByte, &pCsr->pCsr);
vendor/sqlite3.c:157365:        pCsr->pCsr->pTokenizer = pTab->pTok;
vendor/sqlite3.c:157379:  return (pCsr->zToken==0);
vendor/sqlite3.c:157395:      sqlite3_result_text(pCtx, pCsr->zInput, -1, SQLITE_TRANSIENT);
vendor/sqlite3.c:157398:      sqlite3_result_text(pCtx, pCsr->zToken, pCsr->nToken, SQLITE_TRANSIENT);
vendor/sqlite3.c:157401:      sqlite3_result_int(pCtx, pCsr->iStart);
vendor/sqlite3.c:157404:      sqlite3_result_int(pCtx, pCsr->iEnd);
vendor/sqlite3.c:157408:      sqlite3_result_int(pCtx, pCsr->iPos);
vendor/sqlite3.c:157422:  *pRowid = (sqlite3_int64)pCsr->iRowid;
vendor/sqlite3.c:157516:** The code is written so that the hard lower-limit for each of these values 
vendor/sqlite3.c:158267:  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
vendor/sqlite3.c:158410:**   apVal[2]                Left-most user-defined column
vendor/sqlite3.c:158412:**   apVal[p->nColumn+1]     Right-most user-defined column
vendor/sqlite3.c:158722:  nRead = MIN(pReader->nNode - pReader->nPopulate, FTS3_NODE_CHUNKSIZE);
vendor/sqlite3.c:158724:      pReader->pBlob, 
vendor/sqlite3.c:158725:      &pReader->aNode[pReader->nPopulate],
vendor/sqlite3.c:158727:      pReader->nPopulate
vendor/sqlite3.c:158731:    pReader->nPopulate += nRead;
vendor/sqlite3.c:158732:    memset(&pReader->aNode[pReader->nPopulate], 0, FTS3_NODE_PADDING);
vendor/sqlite3.c:158733:    if( pReader->nPopulate==pReader->nNode ){
vendor/sqlite3.c:158734:      sqlite3_blob_close(pReader->pBlob);
vendor/sqlite3.c:158735:      pReader->pBlob = 0;
vendor/sqlite3.c:158736:      pReader->nPopulate = 0;
vendor/sqlite3.c:158744:  assert( !pReader->pBlob 
vendor/sqlite3.c:158745:       || (pFrom>=pReader->aNode && pFrom<&pReader->aNode[pReader->nNode])
vendor/sqlite3.c:158747:  while( pReader->pBlob && rc==SQLITE_OK 
vendor/sqlite3.c:158748:     &&  (pFrom - pReader->aNode + nByte)>pReader->nPopulate
vendor/sqlite3.c:158782:  if( !pReader->aDoclist ){
vendor/sqlite3.c:158783:    pNext = pReader->aNode;
vendor/sqlite3.c:158785:    pNext = &pReader->aDoclist[pReader->nDoclist];
vendor/sqlite3.c:158788:  if( !pNext || pNext>=&pReader->aNode[pReader->nNode] ){
vendor/sqlite3.c:158791:      Fts3HashElem *pElem = *(pReader->ppNextElem);
vendor/sqlite3.c:158792:      sqlite3_free(pReader->aNode);
vendor/sqlite3.c:158793:      pReader->aNode = 0;
vendor/sqlite3.c:158798:        pReader->zTerm = (char *)fts3HashKey(pElem);
vendor/sqlite3.c:158799:        pReader->nTerm = fts3HashKeysize(pElem);
vendor/sqlite3.c:158803:        pReader->nNode = pReader->nDoclist = nCopy;
vendor/sqlite3.c:158804:        pReader->aNode = pReader->aDoclist = aCopy;
vendor/sqlite3.c:158805:        pReader->ppNextElem++;
vendor/sqlite3.c:158806:        assert( pReader->aNode );
vendor/sqlite3.c:158815:    assert( pReader->iCurrentBlock<=pReader->iLeafEndBlock );
vendor/sqlite3.c:158816:    if( pReader->iCurrentBlock>=pReader->iLeafEndBlock ){
vendor/sqlite3.c:158821:        p, ++pReader->iCurrentBlock, &pReader->aNode, &pReader->nNode, 
vendor/sqlite3.c:158822:        (bIncr ? &pReader->nPopulate : 0)
vendor/sqlite3.c:158825:    assert( pReader->pBlob==0 );
vendor/sqlite3.c:158826:    if( bIncr && pReader->nPopulate<pReader->nNode ){
vendor/sqlite3.c:158827:      pReader->pBlob = p->pSegments;
vendor/sqlite3.c:158830:    pNext = pReader->aNode;
vendor/sqlite3.c:158843:   || &pNext[nSuffix]>&pReader->aNode[pReader->nNode] 
vendor/sqlite3.c:158848:  if( nPrefix+nSuffix>pReader->nTermAlloc ){
vendor/sqlite3.c:158850:    char *zNew = sqlite3_realloc(pReader->zTerm, nNew);
vendor/sqlite3.c:158854:    pReader->zTerm = zNew;
vendor/sqlite3.c:158855:    pReader->nTermAlloc = nNew;
vendor/sqlite3.c:158861:  memcpy(&pReader->zTerm[nPrefix], pNext, nSuffix);
vendor/sqlite3.c:158862:  pReader->nTerm = nPrefix+nSuffix;
vendor/sqlite3.c:158864:  pNext += fts3GetVarint32(pNext, &pReader->nDoclist);
vendor/sqlite3.c:158865:  pReader->aDoclist = pNext;
vendor/sqlite3.c:158866:  pReader->pOffsetList = 0;
vendor/sqlite3.c:158872:  if( &pReader->aDoclist[pReader->nDoclist]>&pReader->aNode[pReader->nNode] 
vendor/sqlite3.c:158873:   || (pReader->nPopulate==0 && pReader->aDoclist[pReader->nDoclist-1])
vendor/sqlite3.c:158886:  assert( pReader->aDoclist );
vendor/sqlite3.c:158887:  assert( !pReader->pOffsetList );
vendor/sqlite3.c:158890:    pReader->iDocid = 0;
vendor/sqlite3.c:158891:    pReader->nOffsetList = 0;
vendor/sqlite3.c:158893:        pReader->aDoclist, pReader->nDoclist, &pReader->pOffsetList, 
vendor/sqlite3.c:158894:        &pReader->iDocid, &pReader->nOffsetList, &bEof
vendor/sqlite3.c:158897:    rc = fts3SegReaderRequire(pReader, pReader->aDoclist, FTS3_VARINT_MAX);
vendor/sqlite3.c:158899:      int n = sqlite3Fts3GetVarint(pReader->aDoclist, &pReader->iDocid);
vendor/sqlite3.c:158900:      pReader->pOffsetList = &pReader->aDoclist[n];
vendor/sqlite3.c:158923:  char *p = pReader->pOffsetList;
vendor/sqlite3.c:158934:      *ppOffsetList = pReader->pOffsetList;
vendor/sqlite3.c:158935:      *pnOffsetList = pReader->nOffsetList - 1;
vendor/sqlite3.c:158938:        pReader->aDoclist, pReader->nDoclist, &p, &pReader->iDocid,
vendor/sqlite3.c:158939:        &pReader->nOffsetList, &bEof
vendor/sqlite3.c:158942:      pReader->pOffsetList = 0;
vendor/sqlite3.c:158944:      pReader->pOffsetList = p;
vendor/sqlite3.c:158947:    char *pEnd = &pReader->aDoclist[pReader->nDoclist];
vendor/sqlite3.c:158958:      ** the populated part of pReader->aNode[].
vendor/sqlite3.c:158963:      if( pReader->pBlob==0 || p<&pReader->aNode[pReader->nPopulate] ) break;
vendor/sqlite3.c:158973:      *ppOffsetList = pReader->pOffsetList;
vendor/sqlite3.c:158974:      *pnOffsetList = (int)(p - pReader->pOffsetList - 1);
vendor/sqlite3.c:158986:      pReader->pOffsetList = 0;
vendor/sqlite3.c:158991:        pReader->pOffsetList = p + sqlite3Fts3GetVarint(p, &iDelta);
vendor/sqlite3.c:158993:          pReader->iDocid -= iDelta;
vendor/sqlite3.c:158995:          pReader->iDocid += iDelta;
vendor/sqlite3.c:159010:  Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;
vendor/sqlite3.c:159019:  for(ii=0; rc==SQLITE_OK && ii<pMsr->nSegment; ii++){
vendor/sqlite3.c:159020:    Fts3SegReader *pReader = pMsr->apSegment[ii];
vendor/sqlite3.c:159025:      for(jj=pReader->iStartBlock; jj<=pReader->iLeafEndBlock; jj++){
vendor/sqlite3.c:159046:      sqlite3_free(pReader->zTerm);
vendor/sqlite3.c:159049:      sqlite3_free(pReader->aNode);
vendor/sqlite3.c:159051:    sqlite3_blob_close(pReader->pBlob);
vendor/sqlite3.c:159082:  pReader->iIdx = iAge;
vendor/sqlite3.c:159083:  pReader->bLookup = bLookup!=0;
vendor/sqlite3.c:159084:  pReader->iStartBlock = iStartLeaf;
vendor/sqlite3.c:159085:  pReader->iLeafEndBlock = iEndLeaf;
vendor/sqlite3.c:159086:  pReader->iEndBlock = iEndBlock;
vendor/sqlite3.c:159090:    pReader->aNode = (char *)&pReader[1];
vendor/sqlite3.c:159091:    pReader->rootOnly = 1;
vendor/sqlite3.c:159092:    pReader->nNode = nRoot;
vendor/sqlite3.c:159093:    memcpy(pReader->aNode, zRoot, nRoot);
vendor/sqlite3.c:159094:    memset(&pReader->aNode[nRoot], 0, FTS3_NODE_PADDING);
vendor/sqlite3.c:159096:    pReader->iCurrentBlock = iStartLeaf-1;
vendor/sqlite3.c:159214:      pReader->iIdx = 0x7FFFFFFF;
vendor/sqlite3.c:159215:      pReader->ppNextElem = (Fts3HashElem **)&pReader[1];
vendor/sqlite3.c:159216:      memcpy(pReader->ppNextElem, aElem, nElem*sizeof(Fts3HashElem *));
vendor/sqlite3.c:159619:    for(pIter=pTree->pLeftmost; pIter && rc==SQLITE_OK; pIter=pIter->pRight){
vendor/sqlite3.c:159621:      int nWrite = pIter->nData - nStart;
vendor/sqlite3.c:159623:      rc = fts3WriteSegment(p, iNextFree, &pIter->aData[nStart], nWrite);
vendor/sqlite3.c:159625:      iNextLeaf += (pIter->nEntry+1);
vendor/sqlite3.c:159692:    pWriter->aData = (char *)sqlite3_malloc(p->nNodeSize);
vendor/sqlite3.c:159693:    if( !pWriter->aData ) return SQLITE_NOMEM;
vendor/sqlite3.c:159694:    pWriter->nSize = p->nNodeSize;
vendor/sqlite3.c:159700:      pWriter->iFree = sqlite3_column_int64(pStmt, 0);
vendor/sqlite3.c:159701:      pWriter->iFirst = pWriter->iFree;
vendor/sqlite3.c:159706:  nData = pWriter->nData;
vendor/sqlite3.c:159708:  nPrefix = fts3PrefixCompress(pWriter->zTerm, pWriter->nTerm, zTerm, nTerm);
vendor/sqlite3.c:159722:    rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, nData);
vendor/sqlite3.c:159730:    **      to the database (still available in pWriter->zTerm), and
vendor/sqlite3.c:159736:    ** the common prefix (if any) of zTerm and pWriter->zTerm.
vendor/sqlite3.c:159739:    rc = fts3NodeAddTerm(p, &pWriter->pTree, isCopyTerm, zTerm, nPrefix+1);
vendor/sqlite3.c:159743:    pWriter->nTerm = 0;
vendor/sqlite3.c:159755:  pWriter->nLeafData += nReq;
vendor/sqlite3.c:159760:  if( nReq>pWriter->nSize ){
vendor/sqlite3.c:159761:    char *aNew = sqlite3_realloc(pWriter->aData, nReq);
vendor/sqlite3.c:159763:    pWriter->aData = aNew;
vendor/sqlite3.c:159764:    pWriter->nSize = nReq;
vendor/sqlite3.c:159766:  assert( nData+nReq<=pWriter->nSize );
vendor/sqlite3.c:159769:  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nPrefix);
vendor/sqlite3.c:159770:  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nSuffix);
vendor/sqlite3.c:159771:  memcpy(&pWriter->aData[nData], &zTerm[nPrefix], nSuffix);
vendor/sqlite3.c:159773:  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nDoclist);
vendor/sqlite3.c:159774:  memcpy(&pWriter->aData[nData], aDoclist, nDoclist);
vendor/sqlite3.c:159775:  pWriter->nData = nData + nDoclist;
vendor/sqlite3.c:159783:    if( nTerm>pWriter->nMalloc ){
vendor/sqlite3.c:159784:      char *zNew = sqlite3_realloc(pWriter->zMalloc, nTerm*2);
vendor/sqlite3.c:159788:      pWriter->nMalloc = nTerm*2;
vendor/sqlite3.c:159789:      pWriter->zMalloc = zNew;
vendor/sqlite3.c:159790:      pWriter->zTerm = zNew;
vendor/sqlite3.c:159792:    assert( pWriter->zTerm==pWriter->zMalloc );
vendor/sqlite3.c:159793:    memcpy(pWriter->zTerm, zTerm, nTerm);
vendor/sqlite3.c:159795:    pWriter->zTerm = (char *)zTerm;
vendor/sqlite3.c:159797:  pWriter->nTerm = nTerm;
vendor/sqlite3.c:159815:  if( pWriter->pTree ){
vendor/sqlite3.c:159821:    iLastLeaf = pWriter->iFree;
vendor/sqlite3.c:159822:    rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, pWriter->nData);
vendor/sqlite3.c:159824:      rc = fts3NodeWrite(p, pWriter->pTree, 1,
vendor/sqlite3.c:159825:          pWriter->iFirst, pWriter->iFree, &iLast, &zRoot, &nRoot);
vendor/sqlite3.c:159829:          pWriter->iFirst, iLastLeaf, iLast, pWriter->nLeafData, zRoot, nRoot);
vendor/sqlite3.c:159834:        0, 0, 0, pWriter->nLeafData, pWriter->aData, pWriter->nData);
vendor/sqlite3.c:159846:    sqlite3_free(pWriter->aData);
vendor/sqlite3.c:159847:    sqlite3_free(pWriter->zMalloc);
vendor/sqlite3.c:159848:    fts3NodeFree(pWriter->pTree);
vendor/sqlite3.c:160093:  if( nList>pMsr->nBuffer ){
vendor/sqlite3.c:160095:    pMsr->nBuffer = nList*2;
vendor/sqlite3.c:160096:    pNew = (char *)sqlite3_realloc(pMsr->aBuffer, pMsr->nBuffer);
vendor/sqlite3.c:160098:    pMsr->aBuffer = pNew;
vendor/sqlite3.c:160101:  memcpy(pMsr->aBuffer, pList, nList);
vendor/sqlite3.c:160112:  int nMerge = pMsr->nAdvance;
vendor/sqlite3.c:160113:  Fts3SegReader **apSegment = pMsr->apSegment;
vendor/sqlite3.c:160125:    pSeg = pMsr->apSegment[0];
vendor/sqlite3.c:160148:      fts3SegReaderSort(pMsr->apSegment, nMerge, j, xCmp);
vendor/sqlite3.c:160153:        assert( (pMsr->aBuffer[nList] & 0xFE)==0x00 );
vendor/sqlite3.c:160154:        pList = pMsr->aBuffer;
vendor/sqlite3.c:160157:      if( pMsr->iColFilter>=0 ){
vendor/sqlite3.c:160158:        fts3ColumnFilter(pMsr->iColFilter, 1, &pList, &nList);
vendor/sqlite3.c:160180:  int nSeg = pCsr->nSegment;
vendor/sqlite3.c:160188:  for(i=0; pCsr->bRestart==0 && i<pCsr->nSegment; i++){
vendor/sqlite3.c:160190:    Fts3SegReader *pSeg = pCsr->apSegment[i];
vendor/sqlite3.c:160200:  fts3SegReaderSort(pCsr->apSegment, nSeg, nSeg, fts3SegReaderCmp);
vendor/sqlite3.c:160210:  pCsr->pFilter = pFilter;
vendor/sqlite3.c:160211:  return fts3SegReaderStart(p, pCsr, pFilter->zTerm, pFilter->nTerm);
vendor/sqlite3.c:160223:  int nSegment = pCsr->nSegment;
vendor/sqlite3.c:160228:  assert( pCsr->pFilter==0 );
vendor/sqlite3.c:160237:    Fts3SegReader *pSeg = pCsr->apSegment[i];
vendor/sqlite3.c:160242:  pCsr->nAdvance = i;
vendor/sqlite3.c:160245:  for(i=0; i<pCsr->nAdvance; i++){
vendor/sqlite3.c:160246:    rc = fts3SegReaderFirstDocid(p, pCsr->apSegment[i]);
vendor/sqlite3.c:160249:  fts3SegReaderSort(pCsr->apSegment, i, i, xCmp);
vendor/sqlite3.c:160252:  pCsr->iColFilter = iCol;
vendor/sqlite3.c:160272:  assert( pCsr->zTerm==0 );
vendor/sqlite3.c:160273:  assert( pCsr->nTerm==0 );
vendor/sqlite3.c:160274:  assert( pCsr->aDoclist==0 );
vendor/sqlite3.c:160275:  assert( pCsr->nDoclist==0 );
vendor/sqlite3.c:160277:  pCsr->nAdvance = 0;
vendor/sqlite3.c:160278:  pCsr->bRestart = 1;
vendor/sqlite3.c:160279:  for(i=0; i<pCsr->nSegment; i++){
vendor/sqlite3.c:160280:    pCsr->apSegment[i]->pOffsetList = 0;
vendor/sqlite3.c:160281:    pCsr->apSegment[i]->nOffsetList = 0;
vendor/sqlite3.c:160282:    pCsr->apSegment[i]->iDocid = 0;
vendor/sqlite3.c:160295:  int isIgnoreEmpty =  (pCsr->pFilter->flags & FTS3_SEGMENT_IGNORE_EMPTY);
vendor/sqlite3.c:160296:  int isRequirePos =   (pCsr->pFilter->flags & FTS3_SEGMENT_REQUIRE_POS);
vendor/sqlite3.c:160297:  int isColFilter =    (pCsr->pFilter->flags & FTS3_SEGMENT_COLUMN_FILTER);
vendor/sqlite3.c:160298:  int isPrefix =       (pCsr->pFilter->flags & FTS3_SEGMENT_PREFIX);
vendor/sqlite3.c:160299:  int isScan =         (pCsr->pFilter->flags & FTS3_SEGMENT_SCAN);
vendor/sqlite3.c:160300:  int isFirst =        (pCsr->pFilter->flags & FTS3_SEGMENT_FIRST);
vendor/sqlite3.c:160302:  Fts3SegReader **apSegment = pCsr->apSegment;
vendor/sqlite3.c:160303:  int nSegment = pCsr->nSegment;
vendor/sqlite3.c:160304:  Fts3SegFilter *pFilter = pCsr->pFilter;
vendor/sqlite3.c:160309:  if( pCsr->nSegment==0 ) return SQLITE_OK;
vendor/sqlite3.c:160315:    /* Advance the first pCsr->nAdvance entries in the apSegment[] array
vendor/sqlite3.c:160318:    for(i=0; i<pCsr->nAdvance; i++){
vendor/sqlite3.c:160327:    fts3SegReaderSort(apSegment, nSegment, pCsr->nAdvance, fts3SegReaderCmp);
vendor/sqlite3.c:160328:    pCsr->nAdvance = 0;
vendor/sqlite3.c:160334:    pCsr->nTerm = apSegment[0]->nTerm;
vendor/sqlite3.c:160335:    pCsr->zTerm = apSegment[0]->zTerm;
vendor/sqlite3.c:160338:    ** to does not share a suffix with pFilter->zTerm/nTerm, then all 
vendor/sqlite3.c:160344:    if( pFilter->zTerm && !isScan ){
vendor/sqlite3.c:160345:      if( pCsr->nTerm<pFilter->nTerm 
vendor/sqlite3.c:160346:       || (!isPrefix && pCsr->nTerm>pFilter->nTerm)
vendor/sqlite3.c:160347:       || memcmp(pCsr->zTerm, pFilter->zTerm, pFilter->nTerm) 
vendor/sqlite3.c:160356:        && apSegment[nMerge]->nTerm==pCsr->nTerm 
vendor/sqlite3.c:160357:        && 0==memcmp(pCsr->zTerm, apSegment[nMerge]->zTerm, pCsr->nTerm)
vendor/sqlite3.c:160368:      pCsr->nDoclist = apSegment[0]->nDoclist;
vendor/sqlite3.c:160370:        rc = fts3MsrBufferData(pCsr, apSegment[0]->aDoclist, pCsr->nDoclist);
vendor/sqlite3.c:160371:        pCsr->aDoclist = pCsr->aBuffer;
vendor/sqlite3.c:160373:        pCsr->aDoclist = apSegment[0]->aDoclist;
vendor/sqlite3.c:160405:          fts3ColumnFilter(pFilter->iCol, 0, &pList, &nList);
vendor/sqlite3.c:160422:          if( nDoclist+nByte>pCsr->nBuffer ){
vendor/sqlite3.c:160424:            pCsr->nBuffer = (nDoclist+nByte)*2;
vendor/sqlite3.c:160425:            aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer);
vendor/sqlite3.c:160429:            pCsr->aBuffer = aNew;
vendor/sqlite3.c:160433:            char *a = &pCsr->aBuffer[nDoclist];
vendor/sqlite3.c:160442:            nDoclist += sqlite3Fts3PutVarint(&pCsr->aBuffer[nDoclist], iDelta);
vendor/sqlite3.c:160445:              memcpy(&pCsr->aBuffer[nDoclist], pList, nList);
vendor/sqlite3.c:160447:              pCsr->aBuffer[nDoclist++] = '\0';
vendor/sqlite3.c:160455:        pCsr->aDoclist = pCsr->aBuffer;
vendor/sqlite3.c:160456:        pCsr->nDoclist = nDoclist;
vendor/sqlite3.c:160460:    pCsr->nAdvance = nMerge;
vendor/sqlite3.c:160472:    for(i=0; i<pCsr->nSegment; i++){
vendor/sqlite3.c:160473:      sqlite3Fts3SegReaderFree(pCsr->apSegment[i]);
vendor/sqlite3.c:160475:    sqlite3_free(pCsr->apSegment);
vendor/sqlite3.c:160476:    sqlite3_free(pCsr->aBuffer);
vendor/sqlite3.c:160478:    pCsr->nSegment = 0;
vendor/sqlite3.c:160479:    pCsr->apSegment = 0;
vendor/sqlite3.c:160480:    pCsr->aBuffer = 0;
vendor/sqlite3.c:160711:        rc = fts3PromoteSegments(p, iNewLevel, pWriter->nLeafData);
vendor/sqlite3.c:160736:  /* Determine the auto-incr-merge setting if unknown.  If enabled,
vendor/sqlite3.c:161047:  int nByte;                      /* Bytes allocated at pCsr->apSegment[] */
vendor/sqlite3.c:161052:  pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc(nByte);
vendor/sqlite3.c:161054:  if( pCsr->apSegment==0 ){
vendor/sqlite3.c:161057:    memset(pCsr->apSegment, 0, nByte);
vendor/sqlite3.c:161064:    assert( pCsr->nSegment==0 );
vendor/sqlite3.c:161072:          &pCsr->apSegment[i]
vendor/sqlite3.c:161074:      pCsr->nSegment++;
vendor/sqlite3.c:161174:** (e.g. because the current entry is the last) set NodeReader->aNode to
vendor/sqlite3.c:161251:** (pWriter->aNodeWriter[0].iBlock) when this function is called.
vendor/sqlite3.c:161259:  sqlite3_int64 iPtr = pWriter->aNodeWriter[0].iBlock;
vendor/sqlite3.c:161265:    NodeWriter *pNode = &pWriter->aNodeWriter[iLayer];
vendor/sqlite3.c:161409:  const char *zTerm = pCsr->zTerm;
vendor/sqlite3.c:161410:  int nTerm = pCsr->nTerm;
vendor/sqlite3.c:161411:  const char *aDoclist = pCsr->aDoclist;
vendor/sqlite3.c:161412:  int nDoclist = pCsr->nDoclist;
vendor/sqlite3.c:161419:  pLeaf = &pWriter->aNodeWriter[0];
vendor/sqlite3.c:161432:    pWriter->nWork++;
vendor/sqlite3.c:161444:    ** the common prefix (if any) of zTerm and pWriter->zTerm.
vendor/sqlite3.c:161461:  pWriter->nLeafData += nSpace;
vendor/sqlite3.c:161495:  int iRoot;                      /* Index of root in pWriter->aNodeWriter */
vendor/sqlite3.c:161499:  /* Set iRoot to the index in pWriter->aNodeWriter[] of the output segment 
vendor/sqlite3.c:161504:    NodeWriter *pNode = &pWriter->aNodeWriter[iRoot];
vendor/sqlite3.c:161531:    Blob *pBlock = &pWriter->aNodeWriter[1].block;
vendor/sqlite3.c:161536:          &pBlock->a[1], pWriter->aNodeWriter[0].iBlock
vendor/sqlite3.c:161541:  pRoot = &pWriter->aNodeWriter[iRoot];
vendor/sqlite3.c:161545:    NodeWriter *pNode = &pWriter->aNodeWriter[i];
vendor/sqlite3.c:161556:        pWriter->iAbsLevel+1,               /* level */
vendor/sqlite3.c:161557:        pWriter->iIdx,                      /* idx */
vendor/sqlite3.c:161558:        pWriter->iStart,                    /* start_block */
vendor/sqlite3.c:161559:        pWriter->aNodeWriter[0].iBlock,     /* leaves_end_block */
vendor/sqlite3.c:161560:        pWriter->iEnd,                      /* end_block */
vendor/sqlite3.c:161561:        (pWriter->bNoLeafData==0 ? pWriter->nLeafData : 0),   /* end_block */
vendor/sqlite3.c:161663:      fts3ReadEndBlockField(pSelect, 3, &iEnd, &pWriter->nLeafData);
vendor/sqlite3.c:161664:      if( pWriter->nLeafData<0 ){
vendor/sqlite3.c:161665:        pWriter->nLeafData = pWriter->nLeafData * -1;
vendor/sqlite3.c:161667:      pWriter->bNoLeafData = (pWriter->nLeafData==0);
vendor/sqlite3.c:161706:      pWriter->nLeafEst = (int)((iEnd - iStart) + 1)/FTS_MAX_APPENDABLE_HEIGHT;
vendor/sqlite3.c:161707:      pWriter->iStart = iStart;
vendor/sqlite3.c:161708:      pWriter->iEnd = iEnd;
vendor/sqlite3.c:161709:      pWriter->iAbsLevel = iAbsLevel;
vendor/sqlite3.c:161710:      pWriter->iIdx = iIdx;
vendor/sqlite3.c:161713:        pWriter->aNodeWriter[i].iBlock = pWriter->iStart + i*pWriter->nLeafEst;
vendor/sqlite3.c:161716:      pNode = &pWriter->aNodeWriter[nHeight];
vendor/sqlite3.c:161717:      pNode->iBlock = pWriter->iStart + pWriter->nLeafEst*nHeight;
vendor/sqlite3.c:161726:        pNode = &pWriter->aNodeWriter[i];
vendor/sqlite3.c:161737:            pNode = &pWriter->aNodeWriter[i-1];
vendor/sqlite3.c:161830:    sqlite3_bind_int64(pLeafEst, 2, pCsr->nSegment);
vendor/sqlite3.c:161842:      pWriter->iStart = sqlite3_column_int64(pFirstBlock, 0);
vendor/sqlite3.c:161843:      pWriter->iEnd = pWriter->iStart - 1;
vendor/sqlite3.c:161844:      pWriter->iEnd += nLeafEst * FTS_MAX_APPENDABLE_HEIGHT;
vendor/sqlite3.c:161853:  rc = fts3WriteSegment(p, pWriter->iEnd, 0, 0);
vendor/sqlite3.c:161856:  pWriter->iAbsLevel = iAbsLevel;
vendor/sqlite3.c:161857:  pWriter->nLeafEst = nLeafEst;
vendor/sqlite3.c:161858:  pWriter->iIdx = iIdx;
vendor/sqlite3.c:161862:    pWriter->aNodeWriter[i].iBlock = pWriter->iStart + i*pWriter->nLeafEst;
vendor/sqlite3.c:162127:  for(i=pCsr->nSegment-1; i>=0 && rc==SQLITE_OK; i--){
vendor/sqlite3.c:162132:    ** somewhere in the pCsr->apSegment[] array.  */
vendor/sqlite3.c:162133:    for(j=0; ALWAYS(j<pCsr->nSegment); j++){
vendor/sqlite3.c:162134:      pSeg = pCsr->apSegment[j];
vendor/sqlite3.c:162137:    assert( j<pCsr->nSegment && pSeg->iIdx==i );
vendor/sqlite3.c:162157:  if( rc==SQLITE_OK && nRem!=pCsr->nSegment ){
vendor/sqlite3.c:162166:** Store an incr-merge hint in the database.
vendor/sqlite3.c:162184:** Load an incr-merge hint from the database. The incr-merge hint, if one 
vendor/sqlite3.c:162351:    pFilter->flags = FTS3_SEGMENT_REQUIRE_POS;
vendor/sqlite3.c:162360:          pFilter->flags |= FTS3_SEGMENT_IGNORE_EMPTY;
vendor/sqlite3.c:162368:    if( SQLITE_OK==rc && pCsr->nSegment==nSeg
vendor/sqlite3.c:162373:        const char *zKey = pCsr->zTerm;
vendor/sqlite3.c:162374:        int nKey = pCsr->nTerm;
vendor/sqlite3.c:162380:      if( rc==SQLITE_OK && pWriter->nLeafEst ){
vendor/sqlite3.c:162385:          if( pWriter->nWork>=nRem && rc==SQLITE_ROW ) rc = SQLITE_OK;
vendor/sqlite3.c:162390:          nRem -= (1 + pWriter->nWork);
vendor/sqlite3.c:162400:        pWriter->nLeafData = pWriter->nLeafData * -1;
vendor/sqlite3.c:162403:      if( nSeg==0 && pWriter->bNoLeafData==0 ){
vendor/sqlite3.c:162404:        fts3PromoteSegments(p, iAbsLevel+1, pWriter->nLeafData);
vendor/sqlite3.c:162411:  /* Write the hint values into the %_stat table for the next incr-merger */
vendor/sqlite3.c:162646:    sqlite3_tokenizer_module const *pModule = p->pTokenizer->pModule;
vendor/sqlite3.c:162777:  }else if( nVal>21 && 0==sqlite3_strnicmp(zVal, "test-no-incr-doclist=", 21) ){
vendor/sqlite3.c:162795:  for(pDef=pCsr->pDeferred; pDef; pDef=pDef->pNext){
vendor/sqlite3.c:162802:** Free all entries in the pCsr->pDeffered list. Entries are added to 
vendor/sqlite3.c:162808:  for(pDef=pCsr->pDeferred; pDef; pDef=pNext){
vendor/sqlite3.c:162813:  pCsr->pDeferred = 0;
vendor/sqlite3.c:162817:** Generate deferred-doclists for all tokens in the pCsr->pDeferred list
vendor/sqlite3.c:162826:  if( pCsr->pDeferred ){
vendor/sqlite3.c:162831:    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:162835:    assert( pCsr->isRequireSeek==0 );
vendor/sqlite3.c:162836:    iDocid = sqlite3_column_int64(pCsr->pStmt, 0);
vendor/sqlite3.c:162840:        const char *zText = (const char *)sqlite3_column_text(pCsr->pStmt, i+1);
vendor/sqlite3.c:162843:        rc = sqlite3Fts3OpenTokenizer(pT, pCsr->iLangid, zText, -1, &pTC);
vendor/sqlite3.c:162851:          for(pDef=pCsr->pDeferred; pDef && rc==SQLITE_OK; pDef=pDef->pNext){
vendor/sqlite3.c:162867:    for(pDef=pCsr->pDeferred; pDef && rc==SQLITE_OK; pDef=pDef->pNext){
vendor/sqlite3.c:162905:** Add an entry for token pToken to the pCsr->pDeferred list.
vendor/sqlite3.c:162919:  pDeferred->pNext = pCsr->pDeferred; 
vendor/sqlite3.c:162921:  pCsr->pDeferred = pDeferred;
vendor/sqlite3.c:163401:  int eType = pExpr->eType;     /* Type of expression node pExpr */
vendor/sqlite3.c:163404:    assert( pExpr->pLeft && pExpr->pRight );
vendor/sqlite3.c:163405:    rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx);
vendor/sqlite3.c:163407:      rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx);
vendor/sqlite3.c:163443:  Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:163472:  rc = fts3ExprIterate(pCsr->pExpr, fts3ExprLoadDoclistsCb, (void *)&sCtx);
vendor/sqlite3.c:163480:  pExpr->iPhrase = iPhrase;
vendor/sqlite3.c:163519:  if( pIter->iCurrent<0 ){
vendor/sqlite3.c:163524:    pIter->iCurrent = 0;
vendor/sqlite3.c:163529:    for(i=0; i<pIter->nPhrase; i++){
vendor/sqlite3.c:163530:      SnippetPhrase *pPhrase = &pIter->aPhrase[i];
vendor/sqlite3.c:163531:      fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, pIter->nSnippet);
vendor/sqlite3.c:163537:    for(i=0; i<pIter->nPhrase; i++){
vendor/sqlite3.c:163538:      SnippetPhrase *pPhrase = &pIter->aPhrase[i];
vendor/sqlite3.c:163547:    pIter->iCurrent = iStart = iEnd - pIter->nSnippet + 1;
vendor/sqlite3.c:163548:    for(i=0; i<pIter->nPhrase; i++){
vendor/sqlite3.c:163549:      SnippetPhrase *pPhrase = &pIter->aPhrase[i];
vendor/sqlite3.c:163570:  int iStart = pIter->iCurrent;   /* First token of snippet */
vendor/sqlite3.c:163576:  for(i=0; i<pIter->nPhrase; i++){
vendor/sqlite3.c:163577:    SnippetPhrase *pPhrase = &pIter->aPhrase[i];
vendor/sqlite3.c:163582:      while( iCsr<(iStart+pIter->nSnippet) ){
vendor/sqlite3.c:163621:  pPhrase->nToken = pExpr->pPhrase->nToken;
vendor/sqlite3.c:163701:  rc = fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void*)&sIter);
vendor/sqlite3.c:163756:  if( pStr->n+nAppend+1>=pStr->nAlloc ){
vendor/sqlite3.c:163757:    int nAlloc = pStr->nAlloc+nAppend+100;
vendor/sqlite3.c:163758:    char *zNew = sqlite3_realloc(pStr->z, nAlloc);
vendor/sqlite3.c:163762:    pStr->z = zNew;
vendor/sqlite3.c:163763:    pStr->nAlloc = nAlloc;
vendor/sqlite3.c:163765:  assert( pStr->z!=0 && (pStr->nAlloc >= pStr->n+nAppend+1) );
vendor/sqlite3.c:163768:  memcpy(&pStr->z[pStr->n], zAppend, nAppend);
vendor/sqlite3.c:163769:  pStr->n += nAppend;
vendor/sqlite3.c:163770:  pStr->z[pStr->n] = '\0';
vendor/sqlite3.c:163828:      pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;
vendor/sqlite3.c:163870:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:163883:  zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol);
vendor/sqlite3.c:163885:    if( sqlite3_column_type(pCsr->pStmt, iCol)!=SQLITE_NULL ){
vendor/sqlite3.c:163890:  nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol);
vendor/sqlite3.c:163893:  pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;
vendor/sqlite3.c:163894:  rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid, zDoc,nDoc,&pC);
vendor/sqlite3.c:163933:          pTab, pCsr->iLangid, nSnippet, &zDoc[iBegin], n, &iPos, &hlmask
vendor/sqlite3.c:164009:  Fts3Table *pTab = (Fts3Table *)p->pCursor->base.pVtab;
vendor/sqlite3.c:164011:  Fts3Phrase *pPhrase = pExpr->pPhrase;
vendor/sqlite3.c:164017:    iStart = pExpr->iPhrase * p->nCol;
vendor/sqlite3.c:164019:    iStart = pExpr->iPhrase * ((p->nCol + 31) / 32);
vendor/sqlite3.c:164045:  assert( (pExpr->pLeft==0)==(pExpr->pRight==0) );
vendor/sqlite3.c:164046:  if( pExpr->bEof==0 && pExpr->iDocid==p->pCursor->iPrevId ){
vendor/sqlite3.c:164047:    if( pExpr->pLeft ){
vendor/sqlite3.c:164048:      fts3ExprLHitGather(pExpr->pLeft, p);
vendor/sqlite3.c:164049:      fts3ExprLHitGather(pExpr->pRight, p);
vendor/sqlite3.c:164238:  char *pRead = pIter->pRead;
vendor/sqlite3.c:164247:    pIter->iPos += (int)(iRead-2);
vendor/sqlite3.c:164250:  pIter->pRead = pRead;
vendor/sqlite3.c:164274:  aIter = sqlite3_malloc(sizeof(LcsIterator) * pCsr->nPhrase);
vendor/sqlite3.c:164276:  memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);
vendor/sqlite3.c:164277:  (void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);
vendor/sqlite3.c:164281:    nToken -= pIter->pExpr->pPhrase->nToken;
vendor/sqlite3.c:164282:    pIter->iPosOffset = nToken;
vendor/sqlite3.c:164307:        if( pIter->pRead==0 ){
vendor/sqlite3.c:164311:          if( pAdv==0 || pIter->iPos<pAdv->iPos ){
vendor/sqlite3.c:164314:          if( nThisLcs==0 || pIter->iPos==pIter[-1].iPos ){
vendor/sqlite3.c:164357:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:164400:        rc = sqlite3Fts3SelectDocsize(pTab, pCsr->iPrevId, &pSelectDocsize);
vendor/sqlite3.c:164425:        fts3ExprLHitGather(pCsr->pExpr, pInfo);
vendor/sqlite3.c:164432:        pExpr = pCsr->pExpr;
vendor/sqlite3.c:164436:          if( pCsr->pDeferred ){
vendor/sqlite3.c:164458:** Populate pCsr->aMatchinfo[] with data for the current row. The 
vendor/sqlite3.c:164467:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:164481:  if( pCsr->pMIBuffer && strcmp(pCsr->pMIBuffer->zMatchinfo, zArg) ){
vendor/sqlite3.c:164482:    sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
vendor/sqlite3.c:164483:    pCsr->pMIBuffer = 0;
vendor/sqlite3.c:164491:  if( pCsr->pMIBuffer==0 ){
vendor/sqlite3.c:164496:    pCsr->nPhrase = fts3ExprPhraseCount(pCsr->pExpr);
vendor/sqlite3.c:164497:    sInfo.nPhrase = pCsr->nPhrase;
vendor/sqlite3.c:164511:    pCsr->pMIBuffer = fts3MIBufferNew(nMatchinfo, zArg);
vendor/sqlite3.c:164512:    if( !pCsr->pMIBuffer ) rc = SQLITE_NOMEM;
vendor/sqlite3.c:164514:    pCsr->isMatchinfoNeeded = 1;
vendor/sqlite3.c:164519:    xDestroyOut = fts3MIBufferAlloc(pCsr->pMIBuffer, &aOut);
vendor/sqlite3.c:164527:    sInfo.nPhrase = pCsr->nPhrase;
vendor/sqlite3.c:164530:      fts3MIBufferSetGlobal(pCsr->pMIBuffer);
vendor/sqlite3.c:164538:    int n = pCsr->pMIBuffer->nElem * sizeof(u32);
vendor/sqlite3.c:164555:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:164572:  if( !pCsr->pExpr ){
vendor/sqlite3.c:164675:  nTerm = pExpr->pPhrase->nToken;
vendor/sqlite3.c:164698:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:164699:  sqlite3_tokenizer_module const *pMod = pTab->pTokenizer->pModule;
vendor/sqlite3.c:164706:  if( !pCsr->pExpr ){
vendor/sqlite3.c:164712:  assert( pCsr->isRequireSeek==0 );
vendor/sqlite3.c:164724:  sCtx.iDocid = pCsr->iPrevId;
vendor/sqlite3.c:164746:    (void)fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void*)&sCtx);
vendor/sqlite3.c:164754:    zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol+1);
vendor/sqlite3.c:164755:    nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol+1);
vendor/sqlite3.c:164757:      if( sqlite3_column_type(pCsr->pStmt, iCol+1)==SQLITE_NULL ){
vendor/sqlite3.c:164765:    rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid,
vendor/sqlite3.c:164837:  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
vendor/sqlite3.c:164846:  if( !pCsr->pExpr ){
vendor/sqlite3.c:165141:  pCsr->aInput = (const unsigned char *)aInput;
vendor/sqlite3.c:165143:    pCsr->nInput = 0;
vendor/sqlite3.c:165145:    pCsr->nInput = (int)strlen(aInput);
vendor/sqlite3.c:165147:    pCsr->nInput = nInput;
vendor/sqlite3.c:165150:  *pp = &pCsr->base;
vendor/sqlite3.c:165161:  sqlite3_free(pCsr->zToken);
vendor/sqlite3.c:165179:  unicode_tokenizer *p = ((unicode_tokenizer *)pCsr->base.pTokenizer);
vendor/sqlite3.c:165182:  const unsigned char *z = &pCsr->aInput[pCsr->iOff];
vendor/sqlite3.c:165185:  const unsigned char *zTerm = &pCsr->aInput[pCsr->nInput];
vendor/sqlite3.c:165197:  zOut = pCsr->zToken;
vendor/sqlite3.c:165202:    if( (zOut-pCsr->zToken)>=(pCsr->nAlloc-4) ){
vendor/sqlite3.c:165203:      char *zNew = sqlite3_realloc(pCsr->zToken, pCsr->nAlloc+64);
vendor/sqlite3.c:165205:      zOut = &zNew[zOut - pCsr->zToken];
vendor/sqlite3.c:165206:      pCsr->zToken = zNew;
vendor/sqlite3.c:165207:      pCsr->nAlloc += 64;
vendor/sqlite3.c:165225:  pCsr->iOff = (int)(z - pCsr->aInput);
vendor/sqlite3.c:165226:  *paToken = pCsr->zToken;
vendor/sqlite3.c:165227:  *pnToken = (int)(zOut - pCsr->zToken);
vendor/sqlite3.c:165228:  *piStart = (int)(zStart - pCsr->aInput);
vendor/sqlite3.c:165229:  *piEnd = (int)(zEnd - pCsr->aInput);
vendor/sqlite3.c:165230:  *piPos = pCsr->iToken++;
vendor/sqlite3.c:165634:** This file contains code for implementations of the r-tree and r*-tree
vendor/sqlite3.c:165639:** Database Format of R-Tree Tables
vendor/sqlite3.c:165642:** The data structure for a single virtual r-tree table is stored in three 
vendor/sqlite3.c:165644:** in the table name is replaced with the user-supplied name of the r-tree
vendor/sqlite3.c:165651:** The data for each node of the r-tree structure is stored in the %_node
vendor/sqlite3.c:165652:** table. For each node that is not the root node of the r-tree, there is
vendor/sqlite3.c:165658:** The root node of an r-tree always exists, even if the r-tree table is
vendor/sqlite3.c:165746:  int iDepth;                 /* Current depth of the r-tree structure */
vendor/sqlite3.c:165747:  char *zDb;                  /* Name of database containing r-tree table */
vendor/sqlite3.c:165748:  char *zName;                /* Name of r-tree table */ 
vendor/sqlite3.c:165801:** When doing a search of an r-tree, instances of the following structure
vendor/sqlite3.c:165834:** 2^40 is greater than 2^64, an r-tree structure always has a depth of
vendor/sqlite3.c:165871:** coordinates within a single R-Tree are always of the same time.
vendor/sqlite3.c:165968:** operand to the MATCH operator of an R-Tree.
vendor/sqlite3.c:166202:** Allocate and return new r-tree node. Initially, (RtreeNode.iNode==0),
vendor/sqlite3.c:166233:** Obtain a reference to an r-tree node.
vendor/sqlite3.c:166236:  Rtree *pRtree,             /* R-tree structure */
vendor/sqlite3.c:166299:  ** of the r-tree structure. A height of zero means all data is stored on
vendor/sqlite3.c:166302:  ** is greater than RTREE_MAX_DEPTH, the r-tree structure must be corrupt.
vendor/sqlite3.c:166340:  Rtree *pRtree,             /* The overall R-Tree */
vendor/sqlite3.c:166373:  Rtree *pRtree,                /* The overall R-Tree */
vendor/sqlite3.c:166449:  Rtree *pRtree,       /* The overall R-Tree */
vendor/sqlite3.c:166461:  Rtree *pRtree,               /* The overall R-Tree */
vendor/sqlite3.c:166475:  Rtree *pRtree,               /* The overall R-Tree */
vendor/sqlite3.c:166529:** Increment the r-tree reference count.
vendor/sqlite3.c:166536:** Decrement the r-tree reference count. When the reference count reaches
vendor/sqlite3.c:166604:    pCsr->base.pVtab = pVTab;
vendor/sqlite3.c:166618:  if( pCsr->aConstraint ){
vendor/sqlite3.c:166620:    for(i=0; i<pCsr->nConstraint; i++){
vendor/sqlite3.c:166621:      sqlite3_rtree_query_info *pInfo = pCsr->aConstraint[i].pInfo;
vendor/sqlite3.c:166627:    sqlite3_free(pCsr->aConstraint);
vendor/sqlite3.c:166628:    pCsr->aConstraint = 0;
vendor/sqlite3.c:166636:  Rtree *pRtree = (Rtree *)(cur->pVtab);
vendor/sqlite3.c:166641:  sqlite3_free(pCsr->aPoint);
vendor/sqlite3.c:166642:  for(ii=0; ii<RTREE_CACHE_SZ; ii++) nodeRelease(pRtree, pCsr->aNode[ii]);
vendor/sqlite3.c:166644:  pRtree->nCursor--;
vendor/sqlite3.c:166657:  return pCsr->atEOF;
vendor/sqlite3.c:166935:  return pCur->bPoint ? &pCur->sPoint : pCur->nPoint ? pCur->aPoint : 0;
vendor/sqlite3.c:166943:  int ii = 1 - pCur->bPoint;
vendor/sqlite3.c:166945:  assert( pCur->bPoint || pCur->nPoint );
vendor/sqlite3.c:166946:  if( pCur->aNode[ii]==0 ){
vendor/sqlite3.c:166948:    id = ii ? pCur->aPoint[0].id : pCur->sPoint.id;
vendor/sqlite3.c:166949:    *pRC = nodeAcquire(RTREE_OF_CURSOR(pCur), id, 0, &pCur->aNode[ii]);
vendor/sqlite3.c:166951:  return pCur->aNode[ii];
vendor/sqlite3.c:166964:  if( pCur->nPoint>=pCur->nPointAlloc ){
vendor/sqlite3.c:166965:    int nNew = pCur->nPointAlloc*2 + 8;
vendor/sqlite3.c:166966:    pNew = sqlite3_realloc(pCur->aPoint, nNew*sizeof(pCur->aPoint[0]));
vendor/sqlite3.c:166968:    pCur->aPoint = pNew;
vendor/sqlite3.c:166969:    pCur->nPointAlloc = nNew;
vendor/sqlite3.c:166971:  i = pCur->nPoint++;
vendor/sqlite3.c:166972:  pNew = pCur->aPoint + i;
vendor/sqlite3.c:166979:    pParent = pCur->aPoint + j;
vendor/sqlite3.c:166999:  pCur->anQueue[iLevel]++;
vendor/sqlite3.c:167004:    if( pCur->bPoint ){
vendor/sqlite3.c:167008:      ii = (int)(pNew - pCur->aPoint) + 1;
vendor/sqlite3.c:167010:        assert( pCur->aNode[ii]==0 );
vendor/sqlite3.c:167011:        pCur->aNode[ii] = pCur->aNode[0];
vendor/sqlite3.c:167013:        nodeRelease(RTREE_OF_CURSOR(pCur), pCur->aNode[0]);
vendor/sqlite3.c:167015:      pCur->aNode[0] = 0;
vendor/sqlite3.c:167016:      *pNew = pCur->sPoint;
vendor/sqlite3.c:167018:    pCur->sPoint.rScore = rScore;
vendor/sqlite3.c:167019:    pCur->sPoint.iLevel = iLevel;
vendor/sqlite3.c:167020:    pCur->bPoint = 1;
vendor/sqlite3.c:167021:    return &pCur->sPoint;
vendor/sqlite3.c:167036:    printf(" %p\n", pCur->aNode[idx]);
vendor/sqlite3.c:167044:  if( pCur->bPoint ){
vendor/sqlite3.c:167045:    tracePoint(&pCur->sPoint, -1, pCur);
vendor/sqlite3.c:167047:  for(ii=0; ii<pCur->nPoint; ii++){
vendor/sqlite3.c:167048:    if( ii>0 || pCur->bPoint ) printf("              ");
vendor/sqlite3.c:167049:    tracePoint(&pCur->aPoint[ii], ii, pCur);
vendor/sqlite3.c:167114:  int nConstraint = pCur->nConstraint;
vendor/sqlite3.c:167130:        RtreeConstraint *pConstraint = pCur->aConstraint + ii;
vendor/sqlite3.c:167170:  pCur->atEOF = p==0;
vendor/sqlite3.c:167206:  Rtree *pRtree = (Rtree *)cur->pVtab;
vendor/sqlite3.c:167300:  Rtree *pRtree = (Rtree *)pVtabCursor->pVtab;
vendor/sqlite3.c:167311:  sqlite3_free(pCsr->aPoint);
vendor/sqlite3.c:167313:  pCsr->base.pVtab = (sqlite3_vtab*)pRtree;
vendor/sqlite3.c:167315:  pCsr->iStrategy = idxNum;
vendor/sqlite3.c:167325:      assert( p!=0 );  /* Always returns pCsr->sPoint */
vendor/sqlite3.c:167326:      pCsr->aNode[0] = pLeaf;
vendor/sqlite3.c:167333:      pCsr->atEOF = 1;
vendor/sqlite3.c:167336:    /* Normal case - r-tree scan. Set up the RtreeCursor.aConstraint array 
vendor/sqlite3.c:167341:      pCsr->aConstraint = sqlite3_malloc(sizeof(RtreeConstraint)*argc);
vendor/sqlite3.c:167342:      pCsr->nConstraint = argc;
vendor/sqlite3.c:167343:      if( !pCsr->aConstraint ){
vendor/sqlite3.c:167346:        memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*argc);
vendor/sqlite3.c:167347:        memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));
vendor/sqlite3.c:167351:          RtreeConstraint *p = &pCsr->aConstraint[ii];
vendor/sqlite3.c:167364:            p->pInfo->anQueue = pCsr->anQueue;
vendor/sqlite3.c:167383:      assert( pCsr->bPoint==1 );
vendor/sqlite3.c:167384:      pCsr->aNode[0] = pRoot;
vendor/sqlite3.c:167404:**     2        See below     R-tree query or full-table scan.
vendor/sqlite3.c:167469:      ** and then a linear search of an R-Tree node. This should be 
vendor/sqlite3.c:168143:** If node pLeaf is not the root of the r-tree and its pParent pointer is 
vendor/sqlite3.c:168259:** cell, adjust the r-tree data structure if required.
vendor/sqlite3.c:168459:** Select a currently unused rowid for a new r-tree record.
vendor/sqlite3.c:168472:** Remove the entry with rowid=iDelete from the r-tree structure.
vendor/sqlite3.c:168651:  /* Constraint handling. A write operation on an r-tree table may return
vendor/sqlite3.c:168723:  ** record to delete from the r-tree table. The following block does
vendor/sqlite3.c:168732:  ** the r-tree structure.
vendor/sqlite3.c:168735:    /* Insert the new record into the r-tree */
vendor/sqlite3.c:169051:** methods of the r-tree virtual table.
vendor/sqlite3.c:169111:  ** the r-tree table schema.
vendor/sqlite3.c:169151:** Implementation of a scalar function that decodes r-tree nodes to
vendor/sqlite3.c:169156:** an r-tree node.  For a two-dimensional r-tree structure called "rt", to
vendor/sqlite3.c:169162:** entry for each cell in the r-tree node. Each entry is itself a
vendor/sqlite3.c:169213:** from the front of a blob that is an r-tree node.  For example:
vendor/sqlite3.c:169234:** Register the r-tree module with database handle db. This creates the
vendor/sqlite3.c:169297:** The R-Tree MATCH operator will read the returned BLOB, deserialize
vendor/sqlite3.c:169299:** out which elements of the R-Tree should be returned by the query.
vendor/sqlite3.c:169337:** Register a new geometry function for use with the r-tree MATCH operator.
vendor/sqlite3.c:169345:  RtreeGeomCallback *pGeomCtx;      /* Context object for new user-function */
vendor/sqlite3.c:169361:** r-tree MATCH operator.
vendor/sqlite3.c:169370:  RtreeGeomCallback *pGeomCtx;      /* Context object for new user-function */
vendor/sqlite3.c:169733:** lower(). Function upper() converts its input to upper-case (ABC).
vendor/sqlite3.c:169734:** Function lower() converts to lower-case (abc).
vendor/sqlite3.c:170079:  pCsr->aChar = (UChar *)&pCsr[1];
vendor/sqlite3.c:170080:  pCsr->aOffset = (int *)&pCsr->aChar[(nChar+3)&~3];
vendor/sqlite3.c:170082:  pCsr->aOffset[iOut] = iInput;
vendor/sqlite3.c:170087:    U16_APPEND(pCsr->aChar, iOut, nChar, c, isError);
vendor/sqlite3.c:170092:    pCsr->aOffset[iOut] = iInput;
vendor/sqlite3.c:170101:  pCsr->pIter = ubrk_open(UBRK_WORD, p->zLocale, pCsr->aChar, iOut, &status);
vendor/sqlite3.c:170106:  pCsr->nChar = iOut;
vendor/sqlite3.c:170108:  ubrk_first(pCsr->pIter);
vendor/sqlite3.c:170118:  ubrk_close(pCsr->pIter);
vendor/sqlite3.c:170119:  sqlite3_free(pCsr->zBuffer);
vendor/sqlite3.c:170144:    iStart = ubrk_current(pCsr->pIter);
vendor/sqlite3.c:170145:    iEnd = ubrk_next(pCsr->pIter);
vendor/sqlite3.c:170152:      U16_NEXT(pCsr->aChar, iWhite, pCsr->nChar, c);
vendor/sqlite3.c:170165:      char *zNew = sqlite3_realloc(pCsr->zBuffer, nByte);
vendor/sqlite3.c:170169:      pCsr->zBuffer = zNew;
vendor/sqlite3.c:170170:      pCsr->nBuffer = nByte;
vendor/sqlite3.c:170174:        pCsr->zBuffer, pCsr->nBuffer, &nByte,    /* Output vars */
vendor/sqlite3.c:170175:        &pCsr->aChar[iStart], iEnd-iStart,       /* Input vars */
vendor/sqlite3.c:170178:  } while( nByte>pCsr->nBuffer );
vendor/sqlite3.c:170180:  *ppToken = pCsr->zBuffer;
vendor/sqlite3.c:170182:  *piStartOffset = pCsr->aOffset[iStart];
vendor/sqlite3.c:170183:  *piEndOffset = pCsr->aOffset[iEnd];
vendor/sqlite3.c:170184:  *piPosition = pCsr->iToken++;
vendor/sqlite3.c:170485:** user-defined SQL function "rbu_delta()" is invoked and the result stored in
vendor/sqlite3.c:171586:  for(i=0; i<pIter->nTblCol; i++){
vendor/sqlite3.c:171587:    sqlite3_free(pIter->azTblCol[i]);
vendor/sqlite3.c:171588:    sqlite3_free(pIter->azTblType[i]);
vendor/sqlite3.c:171590:  sqlite3_free(pIter->azTblCol);
vendor/sqlite3.c:171591:  pIter->azTblCol = 0;
vendor/sqlite3.c:171592:  pIter->azTblType = 0;
vendor/sqlite3.c:171593:  pIter->aiSrcOrder = 0;
vendor/sqlite3.c:171594:  pIter->abTblPk = 0;
vendor/sqlite3.c:171595:  pIter->abNotNull = 0;
vendor/sqlite3.c:171596:  pIter->nTblCol = 0;
vendor/sqlite3.c:171597:  pIter->eType = 0;               /* Invalid value */
vendor/sqlite3.c:171607:  sqlite3_finalize(pIter->pSelect);
vendor/sqlite3.c:171608:  sqlite3_finalize(pIter->pInsert);
vendor/sqlite3.c:171609:  sqlite3_finalize(pIter->pDelete);
vendor/sqlite3.c:171610:  sqlite3_finalize(pIter->pTmpInsert);
vendor/sqlite3.c:171611:  pUp = pIter->pRbuUpdate;
vendor/sqlite3.c:171619:  pIter->pSelect = 0;
vendor/sqlite3.c:171620:  pIter->pInsert = 0;
vendor/sqlite3.c:171621:  pIter->pDelete = 0;
vendor/sqlite3.c:171622:  pIter->pRbuUpdate = 0;
vendor/sqlite3.c:171623:  pIter->pTmpInsert = 0;
vendor/sqlite3.c:171624:  pIter->nCol = 0;
vendor/sqlite3.c:171633:  sqlite3_finalize(pIter->pTblIter);
vendor/sqlite3.c:171634:  sqlite3_finalize(pIter->pIdxIter);
vendor/sqlite3.c:171653:    if( pIter->zIdx==0 ){
vendor/sqlite3.c:171664:      if( pIter->bCleanup ){
vendor/sqlite3.c:171666:        pIter->bCleanup = 0;
vendor/sqlite3.c:171667:        rc = sqlite3_step(pIter->pTblIter);
vendor/sqlite3.c:171669:          rc = resetAndCollectError(pIter->pTblIter, &p->zErrmsg);
vendor/sqlite3.c:171670:          pIter->zTbl = 0;
vendor/sqlite3.c:171672:          pIter->zTbl = (const char*)sqlite3_column_text(pIter->pTblIter, 0);
vendor/sqlite3.c:171673:          pIter->zDataTbl = (const char*)sqlite3_column_text(pIter->pTblIter,1);
vendor/sqlite3.c:171674:          rc = (pIter->zDataTbl && pIter->zTbl) ? SQLITE_OK : SQLITE_NOMEM;
vendor/sqlite3.c:171677:        if( pIter->zIdx==0 ){
vendor/sqlite3.c:171678:          sqlite3_stmt *pIdx = pIter->pIdxIter;
vendor/sqlite3.c:171679:          rc = sqlite3_bind_text(pIdx, 1, pIter->zTbl, -1, SQLITE_STATIC);
vendor/sqlite3.c:171682:          rc = sqlite3_step(pIter->pIdxIter);
vendor/sqlite3.c:171684:            rc = resetAndCollectError(pIter->pIdxIter, &p->zErrmsg);
vendor/sqlite3.c:171685:            pIter->bCleanup = 1;
vendor/sqlite3.c:171686:            pIter->zIdx = 0;
vendor/sqlite3.c:171688:            pIter->zIdx = (const char*)sqlite3_column_text(pIter->pIdxIter, 0);
vendor/sqlite3.c:171689:            pIter->iTnum = sqlite3_column_int(pIter->pIdxIter, 1);
vendor/sqlite3.c:171690:            pIter->bUnique = sqlite3_column_int(pIter->pIdxIter, 2);
vendor/sqlite3.c:171691:            rc = pIter->zIdx ? SQLITE_OK : SQLITE_NOMEM;
vendor/sqlite3.c:171766:  rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pTblIter, &p->zErrmsg, 
vendor/sqlite3.c:171776:    rc = prepareAndCollectError(p->dbMain, &pIter->pIdxIter, &p->zErrmsg,
vendor/sqlite3.c:171783:  pIter->bCleanup = 1;
vendor/sqlite3.c:171865:** Allocate and zero the pIter->azTblCol[] and abTblPk[] arrays so that
vendor/sqlite3.c:171875:    pIter->azTblCol = azNew;
vendor/sqlite3.c:171876:    pIter->azTblType = &azNew[nCol];
vendor/sqlite3.c:171877:    pIter->aiSrcOrder = (int*)&pIter->azTblType[nCol];
vendor/sqlite3.c:171878:    pIter->abTblPk = (u8*)&pIter->aiSrcOrder[nCol];
vendor/sqlite3.c:171879:    pIter->abNotNull = (u8*)&pIter->abTblPk[nCol];
vendor/sqlite3.c:171880:    pIter->abIndexed = (u8*)&pIter->abNotNull[nCol];
vendor/sqlite3.c:172048:** the pIter->abIndexed[] array.
vendor/sqlite3.c:172055:    memcpy(pIter->abIndexed, pIter->abTblPk, sizeof(u8)*pIter->nTblCol);
vendor/sqlite3.c:172057:        sqlite3_mprintf("PRAGMA main.index_list = %Q", pIter->zTbl)
vendor/sqlite3.c:172061:  pIter->nIndex = 0;
vendor/sqlite3.c:172071:      if( iCid>=0 ) pIter->abIndexed[iCid] = 1;
vendor/sqlite3.c:172075:    pIter->nIndex++;
vendor/sqlite3.c:172078:  if( pIter->eType==RBU_PK_WITHOUT_ROWID ){
vendor/sqlite3.c:172080:    pIter->nIndex--;
vendor/sqlite3.c:172084:  if( bIndex==0 ) pIter->abIndexed = 0;
vendor/sqlite3.c:172089:** If they are not already populated, populate the pIter->azTblCol[],
vendor/sqlite3.c:172090:** pIter->abTblPk[], pIter->nTblCol and pIter->bRowid variables according to
vendor/sqlite3.c:172098:  if( pIter->azTblCol==0 ){
vendor/sqlite3.c:172107:    assert( pIter->eType==0 );
vendor/sqlite3.c:172108:    rbuTableType(p, pIter->zTbl, &pIter->eType, &iTnum, &pIter->iPkTnum);
vendor/sqlite3.c:172109:    if( p->rc==SQLITE_OK && pIter->eType==RBU_PK_NOTABLE ){
vendor/sqlite3.c:172111:      p->zErrmsg = sqlite3_mprintf("no such table: %s", pIter->zTbl);
vendor/sqlite3.c:172114:    if( pIter->zIdx==0 ) pIter->iTnum = iTnum;
vendor/sqlite3.c:172116:    assert( pIter->eType==RBU_PK_NONE || pIter->eType==RBU_PK_IPK 
vendor/sqlite3.c:172117:         || pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_WITHOUT_ROWID
vendor/sqlite3.c:172118:         || pIter->eType==RBU_PK_VTAB
vendor/sqlite3.c:172125:        sqlite3_mprintf("SELECT * FROM '%q'", pIter->zDataTbl)
vendor/sqlite3.c:172135:        pIter->aiSrcOrder[pIter->nTblCol] = pIter->nTblCol;
vendor/sqlite3.c:172136:        pIter->azTblCol[pIter->nTblCol++] = zCopy;
vendor/sqlite3.c:172147:     && bRbuRowid!=(pIter->eType==RBU_PK_VTAB || pIter->eType==RBU_PK_NONE)
vendor/sqlite3.c:172151:          "table %q %s rbu_rowid column", pIter->zDataTbl,
vendor/sqlite3.c:172161:          sqlite3_mprintf("PRAGMA table_info(%Q)", pIter->zTbl)
vendor/sqlite3.c:172167:      for(i=iOrder; i<pIter->nTblCol; i++){
vendor/sqlite3.c:172168:        if( 0==strcmp(zName, pIter->azTblCol[i]) ) break;
vendor/sqlite3.c:172170:      if( i==pIter->nTblCol ){
vendor/sqlite3.c:172173:            pIter->zDataTbl, zName
vendor/sqlite3.c:172181:          SWAP(int, pIter->aiSrcOrder[i], pIter->aiSrcOrder[iOrder]);
vendor/sqlite3.c:172182:          SWAP(char*, pIter->azTblCol[i], pIter->azTblCol[iOrder]);
vendor/sqlite3.c:172185:        pIter->azTblType[iOrder] = rbuStrndup(zType, &p->rc);
vendor/sqlite3.c:172186:        pIter->abTblPk[iOrder] = (iPk!=0);
vendor/sqlite3.c:172187:        pIter->abNotNull[iOrder] = (u8)bNotNull || (iPk!=0);
vendor/sqlite3.c:172194:    assert( pIter->eType!=RBU_PK_VTAB || pIter->abIndexed==0 );
vendor/sqlite3.c:172195:    assert( pIter->eType!=RBU_PK_VTAB || pIter->nIndex==0 );
vendor/sqlite3.c:172204:** column names currently stored in the pIter->azTblCol[] array.
vendor/sqlite3.c:172213:  for(i=0; i<pIter->nTblCol; i++){
vendor/sqlite3.c:172214:    const char *z = pIter->azTblCol[i];
vendor/sqlite3.c:172267:        sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", pIter->zIdx)
vendor/sqlite3.c:172281:      if( pIter->eType==RBU_PK_IPK ){
vendor/sqlite3.c:172283:        for(i=0; pIter->abTblPk[i]==0; i++);
vendor/sqlite3.c:172284:        assert( i<pIter->nTblCol );
vendor/sqlite3.c:172285:        zCol = pIter->azTblCol[i];
vendor/sqlite3.c:172293:      zCol = pIter->azTblCol[iCid];
vendor/sqlite3.c:172294:      zType = pIter->azTblType[iCid];
vendor/sqlite3.c:172298:    if( pIter->bUnique==0 || sqlite3_column_int(pXInfo, 5) ){
vendor/sqlite3.c:172355:  if( p->rc==SQLITE_OK && pIter->abIndexed ){
vendor/sqlite3.c:172358:    for(i=0; i<pIter->nTblCol; i++){
vendor/sqlite3.c:172359:      if( pIter->abIndexed[i] ){
vendor/sqlite3.c:172360:        const char *zCol = pIter->azTblCol[i];
vendor/sqlite3.c:172373:    if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){
vendor/sqlite3.c:172395:  if( pIter->eType==RBU_PK_VTAB || pIter->eType==RBU_PK_NONE ){
vendor/sqlite3.c:172396:    zList = rbuMPrintf(p, "_rowid_ = ?%d", pIter->nTblCol+1);
vendor/sqlite3.c:172397:  }else if( pIter->eType==RBU_PK_EXTERNAL ){
vendor/sqlite3.c:172400:    for(i=0; i<pIter->nTblCol; i++){
vendor/sqlite3.c:172401:      if( pIter->abTblPk[i] ){
vendor/sqlite3.c:172413:    for(i=0; i<pIter->nTblCol; i++){
vendor/sqlite3.c:172414:      if( pIter->abTblPk[i] ){
vendor/sqlite3.c:172415:        const char *zCol = pIter->azTblCol[i];
vendor/sqlite3.c:172463:    if( (int)strlen(zMask)!=pIter->nTblCol ){
vendor/sqlite3.c:172467:      for(i=0; i<pIter->nTblCol; i++){
vendor/sqlite3.c:172468:        char c = zMask[pIter->aiSrcOrder[i]];
vendor/sqlite3.c:172471:              zList, zSep, pIter->azTblCol[i], i+1
vendor/sqlite3.c:172477:              zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i+1
vendor/sqlite3.c:172483:              zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i+1
vendor/sqlite3.c:172537:  assert( pIter->zIdx==0 );
vendor/sqlite3.c:172540:    sqlite3_stmt *pXList = 0;     /* PRAGMA index_list = (pIter->zTbl) */
vendor/sqlite3.c:172544:        sqlite3_mprintf("PRAGMA main.index_list = %Q", pIter->zTbl)
vendor/sqlite3.c:172595:  if( p->rc==SQLITE_OK && pIter->eType==RBU_PK_EXTERNAL ){
vendor/sqlite3.c:172596:    int tnum = pIter->iPkTnum;    /* Root page of PK index */
vendor/sqlite3.c:172630:            iCid, pIter->azTblType[iCid], zCollate
vendor/sqlite3.c:172669:  if( p->rc==SQLITE_OK && pIter->eType!=RBU_PK_VTAB ){
vendor/sqlite3.c:172670:    int tnum = pIter->iTnum;
vendor/sqlite3.c:172676:    for(iCol=0; p->rc==SQLITE_OK && iCol<pIter->nTblCol; iCol++){
vendor/sqlite3.c:172678:      const char *zCol = pIter->azTblCol[iCol];
vendor/sqlite3.c:172682:          p->dbMain, "main", pIter->zTbl, zCol, 0, &zColl, 0, 0, 0
vendor/sqlite3.c:172685:      if( pIter->eType==RBU_PK_IPK && pIter->abTblPk[iCol] ){
vendor/sqlite3.c:172691:          zSql, zComma, zCol, pIter->azTblType[iCol], zPk, zColl,
vendor/sqlite3.c:172692:          (pIter->abNotNull[iCol] ? " NOT NULL" : "")
vendor/sqlite3.c:172697:    if( pIter->eType==RBU_PK_WITHOUT_ROWID ){
vendor/sqlite3.c:172706:        pIter->zTbl, zSql, 
vendor/sqlite3.c:172707:        (pIter->eType==RBU_PK_WITHOUT_ROWID ? " WITHOUT ROWID" : "")
vendor/sqlite3.c:172730:  int bRbuRowid = (pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE);
vendor/sqlite3.c:172731:  char *zBind = rbuObjIterGetBindlist(p, pIter->nTblCol + 1 + bRbuRowid);
vendor/sqlite3.c:172733:    assert( pIter->pTmpInsert==0 );
vendor/sqlite3.c:172735:        p->dbRbu, &pIter->pTmpInsert, &p->zErrmsg, sqlite3_mprintf(
vendor/sqlite3.c:172737:          p->zStateDb, pIter->zDataTbl, zCollist, zRbuRowid, zBind
vendor/sqlite3.c:172782:  assert( pIter->bCleanup==0 );
vendor/sqlite3.c:172783:  if( pIter->pSelect==0 && rbuObjIterCacheTableInfo(p, pIter)==SQLITE_OK ){
vendor/sqlite3.c:172784:    const int tnum = pIter->iTnum;
vendor/sqlite3.c:172787:    const char *zIdx = pIter->zIdx;
vendor/sqlite3.c:172796:      const char *zTbl = pIter->zTbl;
vendor/sqlite3.c:172803:      assert( pIter->eType!=RBU_PK_VTAB );
vendor/sqlite3.c:172819:      pIter->nCol = nBind;
vendor/sqlite3.c:172822:            p->dbMain, &pIter->pInsert, &p->zErrmsg,
vendor/sqlite3.c:172830:            p->dbMain, &pIter->pDelete, &p->zErrmsg,
vendor/sqlite3.c:172842:              pIter->zDataTbl,
vendor/sqlite3.c:172847:        if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){
vendor/sqlite3.c:172850:              zCollist, p->zStateDb, pIter->zDataTbl,
vendor/sqlite3.c:172860:              zCollist, p->zStateDb, pIter->zDataTbl, 
vendor/sqlite3.c:172861:              zCollist, pIter->zDataTbl, 
vendor/sqlite3.c:172865:        p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz, zSql);
vendor/sqlite3.c:172873:      int bRbuRowid = (pIter->eType==RBU_PK_VTAB)
vendor/sqlite3.c:172874:                    ||(pIter->eType==RBU_PK_NONE)
vendor/sqlite3.c:172875:                    ||(pIter->eType==RBU_PK_EXTERNAL && rbuIsVacuum(p));
vendor/sqlite3.c:172876:      const char *zTbl = pIter->zTbl;       /* Table this step applies to */
vendor/sqlite3.c:172879:      char *zBindings = rbuObjIterGetBindlist(p, pIter->nTblCol + bRbuRowid);
vendor/sqlite3.c:172885:      pIter->nCol = pIter->nTblCol;
vendor/sqlite3.c:172890:      zWrite = (pIter->eType==RBU_PK_VTAB ? "" : "rbu_imp_");
vendor/sqlite3.c:172894:        p->rc = prepareFreeAndCollectError(p->dbMain, &pIter->pInsert, pz,
vendor/sqlite3.c:172906:        p->rc = prepareFreeAndCollectError(p->dbMain, &pIter->pDelete, pz,
vendor/sqlite3.c:172913:      if( rbuIsVacuum(p)==0 && pIter->abIndexed ){
vendor/sqlite3.c:172915:        if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){
vendor/sqlite3.c:172923:            , p->zStateDb, pIter->zDataTbl
vendor/sqlite3.c:172924:            , (pIter->eType==RBU_PK_EXTERNAL ? ", 0 AS rbu_rowid" : "")
vendor/sqlite3.c:172925:            , pIter->zDataTbl
vendor/sqlite3.c:172948:        if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){
vendor/sqlite3.c:172967:        p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,
vendor/sqlite3.c:172973:              pIter->zDataTbl, zLimit
vendor/sqlite3.c:173016:  for(pp=&pIter->pRbuUpdate; *pp; pp=&((*pp)->pNext)){
vendor/sqlite3.c:173020:      pUp->pNext = pIter->pRbuUpdate;
vendor/sqlite3.c:173021:      pIter->pRbuUpdate = pUp;
vendor/sqlite3.c:173030:    for(pp=&pIter->pRbuUpdate; *pp!=pUp; pp=&((*pp)->pNext));
vendor/sqlite3.c:173035:    pUp = (RbuUpdateStmt*)rbuMalloc(p, sizeof(RbuUpdateStmt)+pIter->nTblCol+1);
vendor/sqlite3.c:173044:    memcpy(pUp->zMask, zMask, pIter->nTblCol);
vendor/sqlite3.c:173045:    pUp->pNext = pIter->pRbuUpdate;
vendor/sqlite3.c:173046:    pIter->pRbuUpdate = pUp;
vendor/sqlite3.c:173051:      if( pIter->eType!=RBU_PK_VTAB ) zPrefix = "rbu_imp_";
vendor/sqlite3.c:173053:          zPrefix, pIter->zTbl, zSet, zWhere
vendor/sqlite3.c:173745:  assert( eType!=RBU_DELETE || pIter->zIdx==0 );
vendor/sqlite3.c:173759:    pWriter = pIter->pDelete;
vendor/sqlite3.c:173761:    pWriter = pIter->pInsert;
vendor/sqlite3.c:173764:  for(i=0; i<pIter->nCol; i++){
vendor/sqlite3.c:173769:     && pIter->zIdx==0 && pIter->eType==RBU_PK_IPK && pIter->abTblPk[i] 
vendor/sqlite3.c:173770:     && sqlite3_column_type(pIter->pSelect, i)==SQLITE_NULL
vendor/sqlite3.c:173777:    if( eType==RBU_DELETE && pIter->abTblPk[i]==0 ){
vendor/sqlite3.c:173781:    pVal = sqlite3_column_value(pIter->pSelect, i);
vendor/sqlite3.c:173785:  if( pIter->zIdx==0 ){
vendor/sqlite3.c:173786:    if( pIter->eType==RBU_PK_VTAB 
vendor/sqlite3.c:173787:     || pIter->eType==RBU_PK_NONE 
vendor/sqlite3.c:173788:     || (pIter->eType==RBU_PK_EXTERNAL && rbuIsVacuum(p)) 
vendor/sqlite3.c:173795:      ** Hence column_value(pIter->nCol+1).
vendor/sqlite3.c:173797:      assertColumnName(pIter->pSelect, pIter->nCol+1, 
vendor/sqlite3.c:173800:      pVal = sqlite3_column_value(pIter->pSelect, pIter->nCol+1);
vendor/sqlite3.c:173801:      p->rc = sqlite3_bind_value(pWriter, pIter->nCol+1, pVal);
vendor/sqlite3.c:173831:    assert( eType!=RBU_UPDATE || pIter->zIdx==0 );
vendor/sqlite3.c:173833:    if( pIter->zIdx==0 && (eType==RBU_IDX_DELETE || eType==RBU_IDX_INSERT) ){
vendor/sqlite3.c:173837:      if( pIter->zIdx==0 ){
vendor/sqlite3.c:173854:        for(i=0; p->rc==SQLITE_OK && i<pIter->nCol; i++){
vendor/sqlite3.c:173855:          char c = zMask[pIter->aiSrcOrder[i]];
vendor/sqlite3.c:173856:          pVal = sqlite3_column_value(pIter->pSelect, i);
vendor/sqlite3.c:173857:          if( pIter->abTblPk[i] || c!='.' ){
vendor/sqlite3.c:173862:         && (pIter->eType==RBU_PK_VTAB || pIter->eType==RBU_PK_NONE) 
vendor/sqlite3.c:173865:          assertColumnName(pIter->pSelect, pIter->nCol+1, "rbu_rowid");
vendor/sqlite3.c:173866:          pVal = sqlite3_column_value(pIter->pSelect, pIter->nCol+1);
vendor/sqlite3.c:173867:          p->rc = sqlite3_bind_value(pUpdate, pIter->nCol+1, pVal);
vendor/sqlite3.c:174062:        while( p->rc==SQLITE_OK && pIter->zTbl ){
vendor/sqlite3.c:174064:          if( pIter->bCleanup ){
vendor/sqlite3.c:174068:            if( rbuIsVacuum(p)==0 && pIter->abIndexed ){
vendor/sqlite3.c:174070:                  "DELETE FROM %s.'rbu_tmp_%q'", p->zStateDb, pIter->zDataTbl
vendor/sqlite3.c:174078:              int rc = sqlite3_step(pIter->pSelect);
vendor/sqlite3.c:174084:              p->rc = sqlite3_reset(pIter->pSelect);
vendor/sqlite3.c:174093:          assert( pIter->zTbl==0 );
vendor/sqlite3.c:174141:            ** However, if the sector-size is larger than the page-size, and the
vendor/sqlite3.c:174199:    while( rc==SQLITE_OK && pIter->zTbl && (pIter->bCleanup 
vendor/sqlite3.c:174200:       || rbuStrCompare(pIter->zIdx, pState->zIdx)
vendor/sqlite3.c:174201:       || rbuStrCompare(pIter->zTbl, pState->zTbl) 
vendor/sqlite3.c:174206:    if( rc==SQLITE_OK && !pIter->zTbl ){
vendor/sqlite3.c:174269:** This user-defined SQL function is invoked with a single argument - the
vendor/sqlite3.c:175151:** Return the sector-size in bytes for an rbuVfs-file.
vendor/sqlite3.c:175946:    pCsr->base.pVtab = pVTab;
vendor/sqlite3.c:175947:    pCsr->iDb = pTab->iDb;
vendor/sqlite3.c:175969:  sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:175970:  for(i=0; i<ArraySize(pCsr->aPage); i++){
vendor/sqlite3.c:175971:    statClearPage(&pCsr->aPage[i]);
vendor/sqlite3.c:175973:  pCsr->iPage = 0;
vendor/sqlite3.c:175974:  sqlite3_free(pCsr->zPath);
vendor/sqlite3.c:175975:  pCsr->zPath = 0;
vendor/sqlite3.c:175976:  pCsr->isEof = 0;
vendor/sqlite3.c:175985:  sqlite3_finalize(pCsr->pStmt);
vendor/sqlite3.c:176105:** Populate the pCsr->iOffset and pCsr->szPage member variables. Based on
vendor/sqlite3.c:176106:** the current value of pCsr->iPageno.
vendor/sqlite3.c:176116:  pCsr->szPage = sqlite3BtreeGetPageSize(pBt);
vendor/sqlite3.c:176117:  pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);
vendor/sqlite3.c:176123:  x[0] = pCsr->iPageno;
vendor/sqlite3.c:176125:    pCsr->iOffset = x[0];
vendor/sqlite3.c:176126:    pCsr->szPage = (int)x[1];
vendor/sqlite3.c:176138:  StatTable *pTab = (StatTable *)pCursor->pVtab;
vendor/sqlite3.c:176139:  Btree *pBt = pTab->db->aDb[pCsr->iDb].pBt;
vendor/sqlite3.c:176142:  sqlite3_free(pCsr->zPath);
vendor/sqlite3.c:176143:  pCsr->zPath = 0;
vendor/sqlite3.c:176146:  if( pCsr->aPage[0].pPg==0 ){
vendor/sqlite3.c:176147:    rc = sqlite3_step(pCsr->pStmt);
vendor/sqlite3.c:176150:      u32 iRoot = (u32)sqlite3_column_int64(pCsr->pStmt, 1);
vendor/sqlite3.c:176153:        pCsr->isEof = 1;
vendor/sqlite3.c:176154:        return sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:176156:      rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg, 0);
vendor/sqlite3.c:176157:      pCsr->aPage[0].iPgno = iRoot;
vendor/sqlite3.c:176158:      pCsr->aPage[0].iCell = 0;
vendor/sqlite3.c:176159:      pCsr->aPage[0].zPath = z = sqlite3_mprintf("/");
vendor/sqlite3.c:176160:      pCsr->iPage = 0;
vendor/sqlite3.c:176163:      pCsr->isEof = 1;
vendor/sqlite3.c:176164:      return sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:176169:    StatPage *p = &pCsr->aPage[pCsr->iPage];
vendor/sqlite3.c:176179:        pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);
vendor/sqlite3.c:176180:        pCsr->iPageno = pCell->aOvfl[pCell->iOvfl];
vendor/sqlite3.c:176181:        pCsr->zPagetype = "overflow";
vendor/sqlite3.c:176182:        pCsr->nCell = 0;
vendor/sqlite3.c:176183:        pCsr->nMxPayload = 0;
vendor/sqlite3.c:176184:        pCsr->zPath = z = sqlite3_mprintf(
vendor/sqlite3.c:176188:          pCsr->nUnused = 0;
vendor/sqlite3.c:176189:          pCsr->nPayload = nUsable - 4;
vendor/sqlite3.c:176191:          pCsr->nPayload = pCell->nLastOvfl;
vendor/sqlite3.c:176192:          pCsr->nUnused = nUsable - 4 - pCsr->nPayload;
vendor/sqlite3.c:176204:      if( pCsr->iPage==0 ) return statNext(pCursor);
vendor/sqlite3.c:176205:      pCsr->iPage--;
vendor/sqlite3.c:176208:    pCsr->iPage++;
vendor/sqlite3.c:176209:    assert( p==&pCsr->aPage[pCsr->iPage-1] );
vendor/sqlite3.c:176229:    StatPage *p = &pCsr->aPage[pCsr->iPage];
vendor/sqlite3.c:176230:    pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);
vendor/sqlite3.c:176231:    pCsr->iPageno = p->iPgno;
vendor/sqlite3.c:176240:          pCsr->zPagetype = "internal";
vendor/sqlite3.c:176244:          pCsr->zPagetype = "leaf";
vendor/sqlite3.c:176247:          pCsr->zPagetype = "corrupted";
vendor/sqlite3.c:176250:      pCsr->nCell = p->nCell;
vendor/sqlite3.c:176251:      pCsr->nUnused = p->nUnused;
vendor/sqlite3.c:176252:      pCsr->nMxPayload = p->nMxPayload;
vendor/sqlite3.c:176253:      pCsr->zPath = z = sqlite3_mprintf("%s", p->zPath);
vendor/sqlite3.c:176259:      pCsr->nPayload = nPayload;
vendor/sqlite3.c:176268:  return pCsr->isEof;
vendor/sqlite3.c:176277:  StatTable *pTab = (StatTable*)(pCursor->pVtab);
vendor/sqlite3.c:176284:    pCsr->iDb = sqlite3FindDbName(pTab->db, zDbase);
vendor/sqlite3.c:176285:    if( pCsr->iDb<0 ){
vendor/sqlite3.c:176286:      sqlite3_free(pCursor->pVtab->zErrMsg);
vendor/sqlite3.c:176287:      pCursor->pVtab->zErrMsg = sqlite3_mprintf("no such schema: %s", zDbase);
vendor/sqlite3.c:176288:      return pCursor->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM_BKPT;
vendor/sqlite3.c:176291:    pCsr->iDb = pTab->iDb;
vendor/sqlite3.c:176294:  sqlite3_finalize(pCsr->pStmt);
vendor/sqlite3.c:176295:  pCsr->pStmt = 0;
vendor/sqlite3.c:176296:  zMaster = pCsr->iDb==1 ? "sqlite_temp_master" : "sqlite_master";
vendor/sqlite3.c:176302:      "  ORDER BY name", pTab->db->aDb[pCsr->iDb].zDbSName, zMaster);
vendor/sqlite3.c:176306:    rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pStmt, 0);
vendor/sqlite3.c:176324:      sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_TRANSIENT);
vendor/sqlite3.c:176327:      sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);
vendor/sqlite3.c:176330:      sqlite3_result_int64(ctx, pCsr->iPageno);
vendor/sqlite3.c:176333:      sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);
vendor/sqlite3.c:176336:      sqlite3_result_int(ctx, pCsr->nCell);
vendor/sqlite3.c:176339:      sqlite3_result_int(ctx, pCsr->nPayload);
vendor/sqlite3.c:176342:      sqlite3_result_int(ctx, pCsr->nUnused);
vendor/sqlite3.c:176345:      sqlite3_result_int(ctx, pCsr->nMxPayload);
vendor/sqlite3.c:176348:      sqlite3_result_int64(ctx, pCsr->iOffset);
vendor/sqlite3.c:176351:      sqlite3_result_int(ctx, pCsr->szPage);
vendor/sqlite3.c:176355:      int iDb = pCsr->iDb;
vendor/sqlite3.c:176365:  *pRowid = pCsr->iPageno;
vendor/sqlite3.c:179217:  /* If the iterator is in the error-state, return immediately. */
vendor/sqlite3.c:179331:  *pOp = pIter->op;
vendor/sqlite3.c:179332:  *pnCol = pIter->nCol;
vendor/sqlite3.c:179333:  *pzTab = pIter->zTab;
vendor/sqlite3.c:179334:  if( pbIndirect ) *pbIndirect = pIter->bIndirect;
vendor/sqlite3.c:179349:  *pabPK = pIter->abPK;
vendor/sqlite3.c:179350:  if( pnCol ) *pnCol = pIter->nCol;
vendor/sqlite3.c:179372:  if( pIter->op!=SQLITE_UPDATE && pIter->op!=SQLITE_DELETE ){
vendor/sqlite3.c:179375:  if( iVal<0 || iVal>=pIter->nCol ){
vendor/sqlite3.c:179378:  *ppValue = pIter->apValue[iVal];
vendor/sqlite3.c:179400:  if( pIter->op!=SQLITE_UPDATE && pIter->op!=SQLITE_INSERT ){
vendor/sqlite3.c:179403:  if( iVal<0 || iVal>=pIter->nCol ){
vendor/sqlite3.c:179406:  *ppValue = pIter->apValue[pIter->nCol+iVal];
vendor/sqlite3.c:179434:  if( !pIter->pConflict ){
vendor/sqlite3.c:179437:  if( iVal<0 || iVal>=pIter->nCol ){
vendor/sqlite3.c:179440:  *ppValue = sqlite3_column_value(pIter->pConflict, iVal);
vendor/sqlite3.c:179456:  if( pIter->pConflict || pIter->apValue ){
vendor/sqlite3.c:179459:  *pnOut = pIter->nCol;
vendor/sqlite3.c:180092:    pIter->pConflict = p->pSelect;
vendor/sqlite3.c:180094:    pIter->pConflict = 0;
vendor/sqlite3.c:180100:      u8 *aBlob = &pIter->in.aData[pIter->in.iCurrent];
vendor/sqlite3.c:180101:      int nBlob = pIter->in.iNext - pIter->in.iCurrent;
vendor/sqlite3.c:180190:    u8 *abPK = (pIter->bPatchset ? p->abPK : 0);
vendor/sqlite3.c:180226:      sqlite3_bind_int(p->pUpdate, nCol*3+1, pbRetry==0 || pIter->bPatchset);
vendor/sqlite3.c:180300:    assert( pIter->op==SQLITE_UPDATE || pIter->op==SQLITE_DELETE );
vendor/sqlite3.c:180310:    assert( pIter->op==SQLITE_INSERT );
vendor/sqlite3.c:180412:  pIter->in.bNoDiscard = 1;
vendor/sqlite3.c:180430:          db, pIter->bPatchset, zTab, &sApply, xConflict, pCtx
vendor/sqlite3.c:180509:  bPatchset = pIter->bPatchset;
vendor/sqlite3.c:180767:      pGrp->bPatch = pIter->bPatchset;
vendor/sqlite3.c:180768:    }else if( pIter->bPatchset!=pGrp->bPatch ){
vendor/sqlite3.c:180810:    if( sessionGrowHash(pIter->bPatchset, pTab) ){
vendor/sqlite3.c:180815:        pTab, (pIter->bPatchset && op==SQLITE_DELETE), aRec, pTab->nChange
vendor/sqlite3.c:180824:      if( pIter->bPatchset ){
vendor/sqlite3.c:180837:        pIter->bPatchset, pExist, op, bIndirect, aRec, nRec, &pChange
vendor/sqlite3.c:180847:  if( rc==SQLITE_OK ) rc = pIter->rc;
vendor/sqlite3.c:182858:    if( pStr->zBuf==0 ){
vendor/sqlite3.c:182863:      pStr->pCtx = ctx;
vendor/sqlite3.c:182872:    pStr->pCtx = ctx;
vendor/sqlite3.c:182874:    if( pStr->bErr ){
vendor/sqlite3.c:182875:      if( pStr->bErr==1 ) sqlite3_result_error_nomem(ctx);
vendor/sqlite3.c:182876:      assert( pStr->bStatic );
vendor/sqlite3.c:182878:      sqlite3_result_text(ctx, pStr->zBuf, pStr->nUsed,
vendor/sqlite3.c:182879:                          pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);
vendor/sqlite3.c:182880:      pStr->bStatic = 1;
vendor/sqlite3.c:182904:    if( pStr->zBuf==0 ){
vendor/sqlite3.c:182909:      pStr->pCtx = ctx;
vendor/sqlite3.c:182923:    if( pStr->bErr ){
vendor/sqlite3.c:182924:      if( pStr->bErr==1 ) sqlite3_result_error_nomem(ctx);
vendor/sqlite3.c:182925:      assert( pStr->bStatic );
vendor/sqlite3.c:182927:      sqlite3_result_text(ctx, pStr->zBuf, pStr->nUsed,
vendor/sqlite3.c:182928:                          pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);
vendor/sqlite3.c:182929:      pStr->bStatic = 1;
vendor/sqlite3.c:183008:  *ppCursor = &pCur->base;
vendor/sqlite3.c:183017:    pCur->bRecursive = 1;
vendor/sqlite3.c:183291:      sqlite3_free(cur->pVtab->zErrMsg);
vendor/sqlite3.c:183292:      cur->pVtab->zErrMsg = sqlite3_mprintf("malformed JSON");
vendor/sqlite3.c:183293:      if( cur->pVtab->zErrMsg ) rc = SQLITE_ERROR;
vendor/sqlite3.c:183316:        sqlite3_free(cur->pVtab->zErrMsg);
vendor/sqlite3.c:183317:        cur->pVtab->zErrMsg = jsonPathSyntaxError(zErr);
vendor/sqlite3.c:183319:        return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;
vendor/sqlite3.c:184908:** at each "%%" line.  Also, any "P-a-r-s-e" identifer prefix (without the
vendor/sqlite3.c:185023:#define sqlite3Fts5ParserARG_FETCH Fts5Parse *pParse = fts5yypParser->pParse
vendor/sqlite3.c:185024:#define sqlite3Fts5ParserARG_STORE fts5yypParser->pParse = pParse
vendor/sqlite3.c:185196:  fts5YYMINORTYPE minor;     /* The user-supplied minor token value.  This
vendor/sqlite3.c:185351:  pParser->fts5yyhwm = 0;
vendor/sqlite3.c:185354:  pParser->fts5yytos = NULL;
vendor/sqlite3.c:185355:  pParser->fts5yystack = NULL;
vendor/sqlite3.c:185356:  pParser->fts5yystksz = 0;
vendor/sqlite3.c:185358:    pParser->fts5yystack = &pParser->fts5yystk0;
vendor/sqlite3.c:185359:    pParser->fts5yystksz = 1;
vendor/sqlite3.c:185363:  pParser->fts5yyerrcnt = -1;
vendor/sqlite3.c:185365:  pParser->fts5yytos = pParser->fts5yystack;
vendor/sqlite3.c:185366:  pParser->fts5yystack[0].stateno = 0;
vendor/sqlite3.c:185367:  pParser->fts5yystack[0].major = 0;
vendor/sqlite3.c:185369:  pParser->fts5yystackEnd = &pParser->fts5yystack[fts5YYSTACKDEPTH-1];
vendor/sqlite3.c:185429: sqlite3Fts5ParseNodeFree((fts5yypminor->fts5yy24)); 
vendor/sqlite3.c:185435: sqlite3_free((fts5yypminor->fts5yy11)); 
vendor/sqlite3.c:185441: sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy46)); 
vendor/sqlite3.c:185446: sqlite3Fts5ParsePhraseFree((fts5yypminor->fts5yy53)); 
vendor/sqlite3.c:185462:  assert( pParser->fts5yytos!=0 );
vendor/sqlite3.c:185463:  assert( pParser->fts5yytos > pParser->fts5yystack );
vendor/sqlite3.c:185464:  fts5yytos = pParser->fts5yytos--;
vendor/sqlite3.c:185480:  while( pParser->fts5yytos>pParser->fts5yystack ) fts5yy_pop_parser_stack(pParser);
vendor/sqlite3.c:185482:  if( pParser->fts5yystack!=&pParser->fts5yystk0 ) free(pParser->fts5yystack);
vendor/sqlite3.c:185513:  return pParser->fts5yyhwm;
vendor/sqlite3.c:185526:  int stateno = pParser->fts5yytos->stateno;
vendor/sqlite3.c:185621:   while( fts5yypParser->fts5yytos>fts5yypParser->fts5yystack ) fts5yy_pop_parser_stack(fts5yypParser);
vendor/sqlite3.c:185639:         fts5yyTracePrompt,fts5yyTokenName[fts5yypParser->fts5yytos->major],
vendor/sqlite3.c:185643:         fts5yyTracePrompt,fts5yyTokenName[fts5yypParser->fts5yytos->major]);
vendor/sqlite3.c:185661:  fts5yypParser->fts5yytos++;
vendor/sqlite3.c:185663:  if( (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm ){
vendor/sqlite3.c:185664:    fts5yypParser->fts5yyhwm++;
vendor/sqlite3.c:185665:    assert( fts5yypParser->fts5yyhwm == (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack) );
vendor/sqlite3.c:185669:  if( fts5yypParser->fts5yytos>fts5yypParser->fts5yystackEnd ){
vendor/sqlite3.c:185670:    fts5yypParser->fts5yytos--;
vendor/sqlite3.c:185675:  if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz] ){
vendor/sqlite3.c:185677:      fts5yypParser->fts5yytos--;
vendor/sqlite3.c:185686:  fts5yytos = fts5yypParser->fts5yytos;
vendor/sqlite3.c:185744:  fts5yymsp = fts5yypParser->fts5yytos;
vendor/sqlite3.c:185758:    if( (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm ){
vendor/sqlite3.c:185759:      fts5yypParser->fts5yyhwm++;
vendor/sqlite3.c:185760:      assert( fts5yypParser->fts5yyhwm == (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack));
vendor/sqlite3.c:185764:    if( fts5yypParser->fts5yytos>=fts5yypParser->fts5yystackEnd ){
vendor/sqlite3.c:185769:    if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz-1] ){
vendor/sqlite3.c:185774:      fts5yymsp = fts5yypParser->fts5yytos;
vendor/sqlite3.c:185941:    fts5yypParser->fts5yytos += fts5yysize;
vendor/sqlite3.c:185945:    fts5yypParser->fts5yytos = fts5yymsp;
vendor/sqlite3.c:185965:  while( fts5yypParser->fts5yytos>fts5yypParser->fts5yystack ) fts5yy_pop_parser_stack(fts5yypParser);
vendor/sqlite3.c:186007:  fts5yypParser->fts5yyerrcnt = -1;
vendor/sqlite3.c:186009:  assert( fts5yypParser->fts5yytos==fts5yypParser->fts5yystack );
vendor/sqlite3.c:186030:** <li> An option argument of a grammar-specified type.
vendor/sqlite3.c:186053:  assert( fts5yypParser->fts5yytos!=0 );
vendor/sqlite3.c:186070:      fts5yypParser->fts5yyerrcnt--;
vendor/sqlite3.c:186106:      if( fts5yypParser->fts5yyerrcnt<0 ){
vendor/sqlite3.c:186109:      fts5yymx = fts5yypParser->fts5yytos->major;
vendor/sqlite3.c:186120:        while( fts5yypParser->fts5yytos >= fts5yypParser->fts5yystack
vendor/sqlite3.c:186123:                        fts5yypParser->fts5yytos->stateno,
vendor/sqlite3.c:186128:        if( fts5yypParser->fts5yytos < fts5yypParser->fts5yystack || fts5yymajor==0 ){
vendor/sqlite3.c:186132:          fts5yypParser->fts5yyerrcnt = -1;
vendor/sqlite3.c:186139:      fts5yypParser->fts5yyerrcnt = 3;
vendor/sqlite3.c:186163:      if( fts5yypParser->fts5yyerrcnt<=0 ){
vendor/sqlite3.c:186166:      fts5yypParser->fts5yyerrcnt = 3;
vendor/sqlite3.c:186171:        fts5yypParser->fts5yyerrcnt = -1;
vendor/sqlite3.c:186177:  }while( fts5yymajor!=fts5YYNOCODE && fts5yypParser->fts5yytos>fts5yypParser->fts5yystack );
vendor/sqlite3.c:186183:    for(i=&fts5yypParser->fts5yystack[1]; i<=fts5yypParser->fts5yytos; i++){
vendor/sqlite3.c:186248:  pIter->iStart = -1;
vendor/sqlite3.c:186249:  pIter->iEnd = -1;
vendor/sqlite3.c:186251:  while( rc==SQLITE_OK && pIter->iInst<pIter->nInst ){
vendor/sqlite3.c:186253:    rc = pIter->pApi->xInst(pIter->pFts, pIter->iInst, &ip, &ic, &io);
vendor/sqlite3.c:186255:      if( ic==pIter->iCol ){
vendor/sqlite3.c:186256:        int iEnd = io - 1 + pIter->pApi->xPhraseSize(pIter->pFts, ip);
vendor/sqlite3.c:186257:        if( pIter->iStart<0 ){
vendor/sqlite3.c:186258:          pIter->iStart = io;
vendor/sqlite3.c:186259:          pIter->iEnd = iEnd;
vendor/sqlite3.c:186260:        }else if( io<=pIter->iEnd ){
vendor/sqlite3.c:186261:          if( iEnd>pIter->iEnd ) pIter->iEnd = iEnd;
vendor/sqlite3.c:186266:      pIter->iInst++;
vendor/sqlite3.c:186286:  pIter->pApi = pApi;
vendor/sqlite3.c:186287:  pIter->pFts = pFts;
vendor/sqlite3.c:186288:  pIter->iCol = iCol;
vendor/sqlite3.c:186289:  rc = pApi->xInstCount(pFts, &pIter->nInst);
vendor/sqlite3.c:186873:    void *pUserData;              /* User-data pointer */
vendor/sqlite3.c:187095:  if( sqlite3Fts5PoslistNext64(pIter->a, pIter->n, &pIter->i, &pIter->iPos) ){
vendor/sqlite3.c:187096:    pIter->bEof = 1;
vendor/sqlite3.c:187098:  return pIter->bEof;
vendor/sqlite3.c:187106:  pIter->a = a;
vendor/sqlite3.c:187107:  pIter->n = n;
vendor/sqlite3.c:187109:  return pIter->bEof;
vendor/sqlite3.c:187140:  sqlite3Fts5PoslistSafeAppend(pBuf, &pWriter->iPrev, iPos);
vendor/sqlite3.c:188576:      i64 iRowid = p->pIter->iRowid;
vendor/sqlite3.c:188607:    if( sqlite3Fts5IterEof(pIter)==0 && pIter->iRowid==iRowid ){
vendor/sqlite3.c:188608:      if( pIter->nData==0 ) continue;
vendor/sqlite3.c:188621:      sqlite3Fts5PoslistReaderInit(pIter->pData, pIter->nData, &aIter[nIter]);
vendor/sqlite3.c:188711:      a = (u8*)pTerm->pIter->pData;
vendor/sqlite3.c:188712:      n = pTerm->pIter->nData;
vendor/sqlite3.c:188793:** The near-set object passed as the first argument contains more than
vendor/sqlite3.c:188812:  Fts5ExprPhrase **apPhrase = pNear->apPhrase;
vendor/sqlite3.c:188818:  assert( pNear->nPhrase>1 );
vendor/sqlite3.c:188822:  if( pNear->nPhrase>ArraySize(aStatic) ){
vendor/sqlite3.c:188823:    int nByte = sizeof(Fts5NearTrimmer) * pNear->nPhrase;
vendor/sqlite3.c:188841:  for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:188858:      for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:188860:        iMin = iMax - pNear->apPhrase[i]->nTerm - pNear->nNear;
vendor/sqlite3.c:188872:    for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:188875:      if( a[i].pOut->n==0 || iPos!=pWriter->iPrev ){
vendor/sqlite3.c:188882:    for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:188918:  iRowid = pIter->iRowid;
vendor/sqlite3.c:188926:    iRowid = pIter->iRowid;
vendor/sqlite3.c:188947:      i64 iRowid = p->pIter->iRowid;
vendor/sqlite3.c:188972:  if( pExpr->pConfig->eDetail!=FTS5_DETAIL_FULL ){
vendor/sqlite3.c:188974:    Fts5ExprPhrase *pPhrase = pNear->apPhrase[0];
vendor/sqlite3.c:188979:        if( pIter->iRowid==pNode->iRowid && pIter->nData>0 ){
vendor/sqlite3.c:188991:    for(i=0; rc==SQLITE_OK && i<pNear->nPhrase; i++){
vendor/sqlite3.c:188992:      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
vendor/sqlite3.c:188993:      if( pPhrase->nTerm>1 || pPhrase->aTerm[0].pSynonym || pNear->pColset ){
vendor/sqlite3.c:188999:        fts5BufferSet(&rc, &pPhrase->poslist, pIter->nData, pIter->pData);
vendor/sqlite3.c:189004:    if( i==pNear->nPhrase && (i==1 || fts5ExprNearIsMatch(pRc, pNear)) ){
vendor/sqlite3.c:189029:  for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:189030:    Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
vendor/sqlite3.c:189048:              pExpr->pIndex, p->zTerm, (int)strlen(p->zTerm),
vendor/sqlite3.c:189050:              (pExpr->bDesc ? FTS5INDEX_QUERY_DESC : 0),
vendor/sqlite3.c:189051:              pNear->pColset,
vendor/sqlite3.c:189088:  assert( pExpr->bDesc==0 || pExpr->bDesc==1 );
vendor/sqlite3.c:189089:  if( pExpr->bDesc==0 ){
vendor/sqlite3.c:189111:    for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:189112:      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
vendor/sqlite3.c:189163:  Fts5ExprPhrase *pLeft = pNear->apPhrase[0];
vendor/sqlite3.c:189168:  const int bDesc = pExpr->bDesc;
vendor/sqlite3.c:189171:  assert( pNear->nPhrase>1 
vendor/sqlite3.c:189172:       || pNear->apPhrase[0]->nTerm>1 
vendor/sqlite3.c:189173:       || pNear->apPhrase[0]->aTerm[0].pSynonym
vendor/sqlite3.c:189183:    iLast = pLeft->aTerm[0].pIter->iRowid;
vendor/sqlite3.c:189188:    for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:189189:      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
vendor/sqlite3.c:189203:          if( pIter->iRowid==iLast || pIter->bEof ) continue;
vendor/sqlite3.c:189233:  Fts5ExprTerm *pTerm = &pNode->pNear->apPhrase[0]->aTerm[0];
vendor/sqlite3.c:189242:    i64 iRowid = fts5ExprSynonymRowid(pTerm, pExpr->bDesc, 0);
vendor/sqlite3.c:189248:        i64 ii = p->pIter->iRowid;
vendor/sqlite3.c:189250:         || (bFromValid && ii!=iFrom && (ii>iFrom)==pExpr->bDesc) 
vendor/sqlite3.c:189301:  Fts5ExprPhrase *pPhrase = pNode->pNear->apPhrase[0];
vendor/sqlite3.c:189305:  assert( pNode->pNear->nPhrase==1 && pPhrase->nTerm==1 );
vendor/sqlite3.c:189308:  pPhrase->poslist.n = pIter->nData;
vendor/sqlite3.c:189309:  if( pExpr->pConfig->eDetail==FTS5_DETAIL_FULL ){
vendor/sqlite3.c:189310:    pPhrase->poslist.p = (u8*)pIter->pData;
vendor/sqlite3.c:189312:  pNode->iRowid = pIter->iRowid;
vendor/sqlite3.c:189327:  Fts5IndexIter *pIter = pNode->pNear->apPhrase[0]->aTerm[0].pIter;
vendor/sqlite3.c:189440:  if( pAnd->bNomatch && pAnd!=pExpr->pRoot ){
vendor/sqlite3.c:189726:    }else if( (pNear->nPhrase % SZALLOC)==0 ){
vendor/sqlite3.c:189727:      int nNew = pNear->nPhrase + SZALLOC;
vendor/sqlite3.c:189848:    for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:189849:      fts5ExprPhraseFree(pNear->apPhrase[i]);
vendor/sqlite3.c:189851:    sqlite3_free(pNear->pColset);
vendor/sqlite3.c:189937:  pOrig = pExpr->apExprPhrase[iPhrase];
vendor/sqlite3.c:189952:    Fts5Colset *pColsetOrig = pOrig->pNode->pNear->pColset;
vendor/sqlite3.c:189959:      pNew->pRoot->pNear->pColset = pColset;
vendor/sqlite3.c:189986:    pNew->pIndex = pExpr->pIndex;
vendor/sqlite3.c:189987:    pNew->pConfig = pExpr->pConfig;
vendor/sqlite3.c:189990:    pNew->pRoot->pNear->apPhrase[0] = sCtx.pPhrase;
vendor/sqlite3.c:189991:    pNew->pRoot->pNear->nPhrase = 1;
vendor/sqlite3.c:190047:    pNear->nNear = nNear;
vendor/sqlite3.c:190220:      if( pNear->pColset ){
vendor/sqlite3.c:190221:        fts5MergeColset(pNear->pColset, pColset);
vendor/sqlite3.c:190222:        if( pNear->pColset->nCol==0 ){
vendor/sqlite3.c:190227:        pNear->pColset = pColset;
vendor/sqlite3.c:190230:        pNear->pColset = fts5CloneColset(&pParse->rc, pColset);
vendor/sqlite3.c:190266:      if( pNear->nPhrase==1 && pNear->apPhrase[0]->nTerm==1 
vendor/sqlite3.c:190267:       && pNear->apPhrase[0]->aTerm[0].pSynonym==0
vendor/sqlite3.c:190346:        for(iPhrase=0; iPhrase<pNear->nPhrase; iPhrase++){
vendor/sqlite3.c:190347:          pNear->apPhrase[iPhrase]->pNode = pRet;
vendor/sqlite3.c:190348:          if( pNear->apPhrase[iPhrase]->nTerm==0 ){
vendor/sqlite3.c:190355:         && (pNear->nPhrase!=1 || pNear->apPhrase[0]->nTerm>1)
vendor/sqlite3.c:190362:              pNear->nPhrase==1 ? "phrase": "NEAR"
vendor/sqlite3.c:190418:      assert( pParse->apPhrase[pParse->nPhrase-1]==pRight->pNear->apPhrase[0] );
vendor/sqlite3.c:190433:      ap = &pParse->apPhrase[pParse->nPhrase-1-pRight->pNear->nPhrase];
vendor/sqlite3.c:190434:      assert( ap[0]==pPrev->pNear->apPhrase[0] );
vendor/sqlite3.c:190435:      memmove(ap, &ap[1], sizeof(Fts5ExprPhrase*)*pRight->pNear->nPhrase);
vendor/sqlite3.c:190507:  if( pExpr->eType==FTS5_STRING || pExpr->eType==FTS5_TERM ){
vendor/sqlite3.c:190508:    Fts5ExprNearset *pNear = pExpr->pNear;
vendor/sqlite3.c:190514:    if( pNear->pColset ){
vendor/sqlite3.c:190515:      int *aiCol = pNear->pColset->aiCol;
vendor/sqlite3.c:190516:      int nCol = pNear->pColset->nCol;
vendor/sqlite3.c:190521:        for(i=1; i<pNear->pColset->nCol; i++){
vendor/sqlite3.c:190529:    if( pNear->nPhrase>1 ){
vendor/sqlite3.c:190530:      zRet = fts5PrintfAppend(zRet, "-near %d ", pNear->nNear);
vendor/sqlite3.c:190537:    for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:190538:      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
vendor/sqlite3.c:190556:    switch( pExpr->eType ){
vendor/sqlite3.c:190560:        assert( pExpr->eType==FTS5_OR );
vendor/sqlite3.c:190566:    for(i=0; zRet && i<pExpr->nChild; i++){
vendor/sqlite3.c:190567:      char *z = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->apChild[i]);
vendor/sqlite3.c:190582:  if( pExpr->eType==0 ){
vendor/sqlite3.c:190585:  if( pExpr->eType==FTS5_STRING || pExpr->eType==FTS5_TERM ){
vendor/sqlite3.c:190586:    Fts5ExprNearset *pNear = pExpr->pNear;
vendor/sqlite3.c:190590:    if( pNear->pColset ){
vendor/sqlite3.c:190591:      int iCol = pNear->pColset->aiCol[0];
vendor/sqlite3.c:190596:    if( pNear->nPhrase>1 ){
vendor/sqlite3.c:190601:    for(i=0; i<pNear->nPhrase; i++){
vendor/sqlite3.c:190602:      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
vendor/sqlite3.c:190620:    if( pNear->nPhrase>1 ){
vendor/sqlite3.c:190621:      zRet = fts5PrintfAppend(zRet, ", %d)", pNear->nNear);
vendor/sqlite3.c:190629:    switch( pExpr->eType ){
vendor/sqlite3.c:190633:        assert( pExpr->eType==FTS5_OR );
vendor/sqlite3.c:190638:    for(i=0; i<pExpr->nChild; i++){
vendor/sqlite3.c:190639:      char *z = fts5ExprPrint(pConfig, pExpr->apChild[i]);
vendor/sqlite3.c:190644:        int e = pExpr->apChild[i]->eType;
vendor/sqlite3.c:190659:** The implementation of user-defined scalar functions fts5_expr() (bTcl==0)
vendor/sqlite3.c:190717:    if( pExpr->pRoot->xNext==0 ){
vendor/sqlite3.c:190720:      zText = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->pRoot);
vendor/sqlite3.c:190722:      zText = fts5ExprPrint(pConfig, pExpr->pRoot);
vendor/sqlite3.c:190761:** The implementation of an SQLite user-defined-function that accepts a
vendor/sqlite3.c:190834:  return (pExpr ? pExpr->nPhrase : 0);
vendor/sqlite3.c:190841:  if( iPhrase<0 || iPhrase>=pExpr->nPhrase ) return 0;
vendor/sqlite3.c:190842:  return pExpr->apExprPhrase[iPhrase]->nTerm;
vendor/sqlite3.c:190851:  Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];
vendor/sqlite3.c:190853:  if( pNode->bEof==0 && pNode->iRowid==pExpr->pRoot->iRowid ){
vendor/sqlite3.c:190871:  pRet = sqlite3_malloc(sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);
vendor/sqlite3.c:190874:    memset(pRet, 0, sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);
vendor/sqlite3.c:190875:    for(i=0; i<pExpr->nPhrase; i++){
vendor/sqlite3.c:190876:      Fts5Buffer *pBuf = &pExpr->apExprPhrase[i]->poslist;
vendor/sqlite3.c:190877:      Fts5ExprNode *pNode = pExpr->apExprPhrase[i]->pNode;
vendor/sqlite3.c:190878:      assert( pExpr->apExprPhrase[i]->nTerm==1 );
vendor/sqlite3.c:190880:          (pBuf->n==0 || pNode->iRowid!=pExpr->pRoot->iRowid || pNode->bEof)
vendor/sqlite3.c:190925:  for(i=0; i<pExpr->nPhrase; i++){
vendor/sqlite3.c:190928:    for(pTerm=&pExpr->apExprPhrase[i]->aTerm[0]; pTerm; pTerm=pTerm->pSynonym){
vendor/sqlite3.c:190934:            &pExpr->apExprPhrase[i]->poslist, &p->aPopulator[i].writer, p->iOff
vendor/sqlite3.c:190957:  for(i=0; i<pExpr->nPhrase; i++){
vendor/sqlite3.c:190958:    Fts5ExprNode *pNode = pExpr->apExprPhrase[i]->pNode;
vendor/sqlite3.c:190959:    Fts5Colset *pColset = pNode->pNear->pColset;
vendor/sqlite3.c:190976:    pNode->pNear->apPhrase[0]->poslist.n = 0;
vendor/sqlite3.c:190991:      return (pNode->pNear->apPhrase[0]->poslist.n>0);
vendor/sqlite3.c:191030:  fts5ExprCheckPoslists(pExpr->pRoot, iRowid);
vendor/sqlite3.c:191042:  Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];
vendor/sqlite3.c:191046:  assert( iPhrase>=0 && iPhrase<pExpr->nPhrase );
vendor/sqlite3.c:191047:  assert( pExpr->pConfig->eDetail==FTS5_DETAIL_COLUMNS );
vendor/sqlite3.c:191050:   && pNode->iRowid==pExpr->pRoot->iRowid 
vendor/sqlite3.c:191060:      *ppCollist = pPhrase->aTerm[0].pIter->pData;
vendor/sqlite3.c:191061:      *pnCollist = pPhrase->aTerm[0].pIter->nData;
vendor/sqlite3.c:191518:    for(pIter=pHash->aSlot[iSlot]; pIter; pIter=pIter->pHashNext){
vendor/sqlite3.c:191720:**         zero-or-more {
vendor/sqlite3.c:191731:**         zero-or-more {
vendor/sqlite3.c:191741:**         zero-or-more {
vendor/sqlite3.c:191750:**         zero-or-more {
vendor/sqlite3.c:191909:  sqlite3_blob *pReader;          /* RO incr-blob open on %_data table */
vendor/sqlite3.c:191943:  int nMerge;                     /* Number of segments in incr-merge */
vendor/sqlite3.c:192451:** are over-allocated by one slot. This allows the structure contents
vendor/sqlite3.c:192635:** are over-allocated as described for function fts5StructureDecode() 
vendor/sqlite3.c:192915:  Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];
vendor/sqlite3.c:192917:  assert( iLvl<pIter->nLvl );
vendor/sqlite3.c:192919:    if( (iLvl+1) < pIter->nLvl ){
vendor/sqlite3.c:192925:            FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)
vendor/sqlite3.c:192932:  return pIter->aLvl[0].bEof;
vendor/sqlite3.c:192946:** When this function is called pIter->iLeafPgno is the page number the
vendor/sqlite3.c:192951:  for(i=0; i<pIter->nLvl; i++){
vendor/sqlite3.c:192952:    fts5DlidxLvlNext(&pIter->aLvl[i]);
vendor/sqlite3.c:192954:  return pIter->aLvl[0].bEof;
vendor/sqlite3.c:192959:  return p->rc!=SQLITE_OK || pIter->aLvl[0].bEof;
vendor/sqlite3.c:192966:  for(i=pIter->nLvl-1; p->rc==SQLITE_OK && i>=0; i--){
vendor/sqlite3.c:192967:    Fts5DlidxLvl *pLvl = &pIter->aLvl[i];
vendor/sqlite3.c:192976:          FTS5_DLIDX_ROWID(pIter->iSegid, i-1, pLvl->iLeafPgno)
vendor/sqlite3.c:193035:  Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];
vendor/sqlite3.c:193037:  assert( iLvl<pIter->nLvl );
vendor/sqlite3.c:193039:    if( (iLvl+1) < pIter->nLvl ){
vendor/sqlite3.c:193045:            FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)
vendor/sqlite3.c:193055:  return pIter->aLvl[0].bEof;
vendor/sqlite3.c:193067:    for(i=0; i<pIter->nLvl; i++){
vendor/sqlite3.c:193068:      fts5DataRelease(pIter->aLvl[i].pData);
vendor/sqlite3.c:193100:      pIter->nLvl = i+1;
vendor/sqlite3.c:193105:    pIter->iSegid = iSegid;
vendor/sqlite3.c:193122:  return pIter->aLvl[0].iRowid;
vendor/sqlite3.c:193125:  return pIter->aLvl[0].iLeafPgno;
vendor/sqlite3.c:193136:  Fts5StructureSegment *pSeg = pIter->pSeg;
vendor/sqlite3.c:193137:  fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:193138:  pIter->iLeafPgno++;
vendor/sqlite3.c:193139:  if( pIter->pNextLeaf ){
vendor/sqlite3.c:193140:    pIter->pLeaf = pIter->pNextLeaf;
vendor/sqlite3.c:193141:    pIter->pNextLeaf = 0;
vendor/sqlite3.c:193142:  }else if( pIter->iLeafPgno<=pSeg->pgnoLast ){
vendor/sqlite3.c:193143:    pIter->pLeaf = fts5LeafRead(p, 
vendor/sqlite3.c:193144:        FTS5_SEGMENT_ROWID(pSeg->iSegid, pIter->iLeafPgno)
vendor/sqlite3.c:193147:    pIter->pLeaf = 0;
vendor/sqlite3.c:193149:  pLeaf = pIter->pLeaf;
vendor/sqlite3.c:193152:    pIter->iPgidxOff = pLeaf->szLeaf;
vendor/sqlite3.c:193154:      pIter->iEndofDoclist = pLeaf->nn+1;
vendor/sqlite3.c:193156:      pIter->iPgidxOff += fts5GetVarint32(&pLeaf->p[pIter->iPgidxOff],
vendor/sqlite3.c:193157:          pIter->iEndofDoclist
vendor/sqlite3.c:193192:    int iOff = pIter->iLeafOffset;  /* Offset to read at */
vendor/sqlite3.c:193193:    ASSERT_SZLEAF_OK(pIter->pLeaf);
vendor/sqlite3.c:193195:      int iEod = MIN(pIter->iEndofDoclist, pIter->pLeaf->szLeaf);
vendor/sqlite3.c:193196:      pIter->bDel = 0;
vendor/sqlite3.c:193197:      pIter->nPos = 1;
vendor/sqlite3.c:193198:      if( iOff<iEod && pIter->pLeaf->p[iOff]==0 ){
vendor/sqlite3.c:193199:        pIter->bDel = 1;
vendor/sqlite3.c:193201:        if( iOff<iEod && pIter->pLeaf->p[iOff]==0 ){
vendor/sqlite3.c:193202:          pIter->nPos = 1;
vendor/sqlite3.c:193205:          pIter->nPos = 0;
vendor/sqlite3.c:193210:      fts5FastGetVarint32(pIter->pLeaf->p, iOff, nSz);
vendor/sqlite3.c:193211:      pIter->bDel = (nSz & 0x0001);
vendor/sqlite3.c:193212:      pIter->nPos = nSz>>1;
vendor/sqlite3.c:193213:      assert_nc( pIter->nPos>=0 );
vendor/sqlite3.c:193215:    pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193220:  u8 *a = pIter->pLeaf->p;        /* Buffer to read data from */
vendor/sqlite3.c:193221:  int iOff = pIter->iLeafOffset;
vendor/sqlite3.c:193223:  ASSERT_SZLEAF_OK(pIter->pLeaf);
vendor/sqlite3.c:193224:  if( iOff>=pIter->pLeaf->szLeaf ){
vendor/sqlite3.c:193226:    if( pIter->pLeaf==0 ){
vendor/sqlite3.c:193231:    a = pIter->pLeaf->p;
vendor/sqlite3.c:193233:  iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
vendor/sqlite3.c:193234:  pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193253:  u8 *a = pIter->pLeaf->p;        /* Buffer to read data from */
vendor/sqlite3.c:193254:  int iOff = pIter->iLeafOffset;  /* Offset to read at */
vendor/sqlite3.c:193258:  if( iOff+nNew>pIter->pLeaf->nn ){
vendor/sqlite3.c:193262:  pIter->term.n = nKeep;
vendor/sqlite3.c:193263:  fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);
vendor/sqlite3.c:193265:  pIter->iTermLeafOffset = iOff;
vendor/sqlite3.c:193266:  pIter->iTermLeafPgno = pIter->iLeafPgno;
vendor/sqlite3.c:193267:  pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193269:  if( pIter->iPgidxOff>=pIter->pLeaf->nn ){
vendor/sqlite3.c:193270:    pIter->iEndofDoclist = pIter->pLeaf->nn+1;
vendor/sqlite3.c:193273:    pIter->iPgidxOff += fts5GetVarint32(&a[pIter->iPgidxOff], nExtra);
vendor/sqlite3.c:193274:    pIter->iEndofDoclist += nExtra;
vendor/sqlite3.c:193285:  if( pIter->flags & FTS5_SEGITER_REVERSE ){
vendor/sqlite3.c:193286:    pIter->xNext = fts5SegIterNext_Reverse;
vendor/sqlite3.c:193288:    pIter->xNext = fts5SegIterNext_None;
vendor/sqlite3.c:193290:    pIter->xNext = fts5SegIterNext;
vendor/sqlite3.c:193311:    ** The caller will see the (pIter->pLeaf==0) and assume the iterator is
vendor/sqlite3.c:193313:    assert( pIter->pLeaf==0 );
vendor/sqlite3.c:193320:    pIter->pSeg = pSeg;
vendor/sqlite3.c:193321:    pIter->iLeafPgno = pSeg->pgnoFirst-1;
vendor/sqlite3.c:193326:    pIter->iLeafOffset = 4;
vendor/sqlite3.c:193327:    assert_nc( pIter->pLeaf->nn>4 );
vendor/sqlite3.c:193328:    assert( fts5LeafFirstTermOff(pIter->pLeaf)==4 );
vendor/sqlite3.c:193329:    pIter->iPgidxOff = pIter->pLeaf->szLeaf+1;
vendor/sqlite3.c:193352:  int n = pIter->pLeaf->szLeaf;
vendor/sqlite3.c:193353:  int i = pIter->iLeafOffset;
vendor/sqlite3.c:193354:  u8 *a = pIter->pLeaf->p;
vendor/sqlite3.c:193357:  if( n>pIter->iEndofDoclist ){
vendor/sqlite3.c:193358:    n = pIter->iEndofDoclist;
vendor/sqlite3.c:193361:  ASSERT_SZLEAF_OK(pIter->pLeaf);
vendor/sqlite3.c:193379:    pIter->iRowid += iDelta;
vendor/sqlite3.c:193381:    /* If necessary, grow the pIter->aRowidOffset[] array. */
vendor/sqlite3.c:193382:    if( iRowidOffset>=pIter->nRowidOffset ){
vendor/sqlite3.c:193383:      int nNew = pIter->nRowidOffset + 8;
vendor/sqlite3.c:193384:      int *aNew = (int*)sqlite3_realloc(pIter->aRowidOffset, nNew*sizeof(int));
vendor/sqlite3.c:193389:      pIter->aRowidOffset = aNew;
vendor/sqlite3.c:193390:      pIter->nRowidOffset = nNew;
vendor/sqlite3.c:193393:    pIter->aRowidOffset[iRowidOffset++] = pIter->iLeafOffset;
vendor/sqlite3.c:193394:    pIter->iLeafOffset = i;
vendor/sqlite3.c:193396:  pIter->iRowidOffset = iRowidOffset;
vendor/sqlite3.c:193404:  assert( pIter->flags & FTS5_SEGITER_REVERSE );
vendor/sqlite3.c:193405:  assert( pIter->flags & FTS5_SEGITER_ONETERM );
vendor/sqlite3.c:193407:  fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:193408:  pIter->pLeaf = 0;
vendor/sqlite3.c:193409:  while( p->rc==SQLITE_OK && pIter->iLeafPgno>pIter->iTermLeafPgno ){
vendor/sqlite3.c:193411:    pIter->iLeafPgno--;
vendor/sqlite3.c:193413:          pIter->pSeg->iSegid, pIter->iLeafPgno
vendor/sqlite3.c:193418:      ** In this case leave pIter->pLeaf==0, this iterator is at EOF. */
vendor/sqlite3.c:193419:      if( pIter->iLeafPgno==pIter->iTermLeafPgno ){
vendor/sqlite3.c:193420:        assert( pIter->pLeaf==0 );
vendor/sqlite3.c:193421:        if( pIter->iTermLeafOffset<pNew->szLeaf ){
vendor/sqlite3.c:193422:          pIter->pLeaf = pNew;
vendor/sqlite3.c:193423:          pIter->iLeafOffset = pIter->iTermLeafOffset;
vendor/sqlite3.c:193429:          pIter->pLeaf = pNew;
vendor/sqlite3.c:193430:          pIter->iLeafOffset = iRowidOff;
vendor/sqlite3.c:193434:      if( pIter->pLeaf ){
vendor/sqlite3.c:193435:        u8 *a = &pIter->pLeaf->p[pIter->iLeafOffset];
vendor/sqlite3.c:193436:        pIter->iLeafOffset += fts5GetVarint(a, (u64*)&pIter->iRowid);
vendor/sqlite3.c:193444:  if( pIter->pLeaf ){
vendor/sqlite3.c:193445:    pIter->iEndofDoclist = pIter->pLeaf->nn+1;
vendor/sqlite3.c:193456:  Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];
vendor/sqlite3.c:193470:  assert( pIter->flags & FTS5_SEGITER_REVERSE );
vendor/sqlite3.c:193471:  assert( pIter->pNextLeaf==0 );
vendor/sqlite3.c:193474:  if( pIter->iRowidOffset>0 ){
vendor/sqlite3.c:193475:    u8 *a = pIter->pLeaf->p;
vendor/sqlite3.c:193479:    pIter->iRowidOffset--;
vendor/sqlite3.c:193480:    pIter->iLeafOffset = pIter->aRowidOffset[pIter->iRowidOffset];
vendor/sqlite3.c:193482:    iOff = pIter->iLeafOffset;
vendor/sqlite3.c:193484:      iOff += pIter->nPos;
vendor/sqlite3.c:193487:    pIter->iRowid -= iDelta;
vendor/sqlite3.c:193507:  assert( (pIter->flags & FTS5_SEGITER_REVERSE)==0 );
vendor/sqlite3.c:193510:  ASSERT_SZLEAF_OK(pIter->pLeaf);
vendor/sqlite3.c:193511:  iOff = pIter->iLeafOffset;
vendor/sqlite3.c:193514:  if( pIter->pSeg && iOff>=pIter->pLeaf->szLeaf ){
vendor/sqlite3.c:193516:    if( p->rc || pIter->pLeaf==0 ) return;
vendor/sqlite3.c:193517:    pIter->iRowid = 0;
vendor/sqlite3.c:193521:  if( iOff<pIter->iEndofDoclist ){
vendor/sqlite3.c:193524:    iOff += sqlite3Fts5GetVarint(&pIter->pLeaf->p[iOff], (u64*)&iDelta);
vendor/sqlite3.c:193525:    pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193526:    pIter->iRowid += iDelta;
vendor/sqlite3.c:193527:  }else if( (pIter->flags & FTS5_SEGITER_ONETERM)==0 ){
vendor/sqlite3.c:193528:    if( pIter->pSeg ){
vendor/sqlite3.c:193530:      if( iOff!=fts5LeafFirstTermOff(pIter->pLeaf) ){
vendor/sqlite3.c:193531:        iOff += fts5GetVarint32(&pIter->pLeaf->p[iOff], nKeep);
vendor/sqlite3.c:193533:      pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193542:      pIter->pLeaf->p = (u8*)pList;
vendor/sqlite3.c:193543:      pIter->pLeaf->nn = nList;
vendor/sqlite3.c:193544:      pIter->pLeaf->szLeaf = nList;
vendor/sqlite3.c:193545:      pIter->iEndofDoclist = nList;
vendor/sqlite3.c:193546:      sqlite3Fts5BufferSet(&p->rc,&pIter->term, (int)strlen(zTerm), (u8*)zTerm);
vendor/sqlite3.c:193547:      pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);
vendor/sqlite3.c:193559:  fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:193560:  pIter->pLeaf = 0;
vendor/sqlite3.c:193576:  Fts5Data *pLeaf = pIter->pLeaf;
vendor/sqlite3.c:193591:  iOff = pIter->iLeafOffset + pIter->nPos;
vendor/sqlite3.c:193595:    assert_nc( iOff<=pIter->iEndofDoclist );
vendor/sqlite3.c:193596:    if( iOff>=pIter->iEndofDoclist ){
vendor/sqlite3.c:193604:      pIter->iRowid += iDelta;
vendor/sqlite3.c:193607:    pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193609:  }else if( pIter->pSeg==0 ){
vendor/sqlite3.c:193613:    assert( (pIter->flags & FTS5_SEGITER_ONETERM) || pbNewTerm );
vendor/sqlite3.c:193614:    if( 0==(pIter->flags & FTS5_SEGITER_ONETERM) ){
vendor/sqlite3.c:193619:      fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:193620:      pIter->pLeaf = 0;
vendor/sqlite3.c:193622:      pIter->pLeaf->p = (u8*)pList;
vendor/sqlite3.c:193623:      pIter->pLeaf->nn = nList;
vendor/sqlite3.c:193624:      pIter->pLeaf->szLeaf = nList;
vendor/sqlite3.c:193625:      pIter->iEndofDoclist = nList+1;
vendor/sqlite3.c:193626:      sqlite3Fts5BufferSet(&p->rc, &pIter->term, (int)strlen(zTerm),
vendor/sqlite3.c:193628:      pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);
vendor/sqlite3.c:193636:      pLeaf = pIter->pLeaf;
vendor/sqlite3.c:193640:        iOff += sqlite3Fts5GetVarint(&pLeaf->p[iOff], (u64*)&pIter->iRowid);
vendor/sqlite3.c:193641:        pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193644:          pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(
vendor/sqlite3.c:193645:              &pLeaf->p[pLeaf->szLeaf], pIter->iEndofDoclist
vendor/sqlite3.c:193650:        pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(
vendor/sqlite3.c:193653:        pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193654:        pIter->iEndofDoclist = iOff;
vendor/sqlite3.c:193666:  if( pIter->pLeaf ){
vendor/sqlite3.c:193668:      if( pIter->flags & FTS5_SEGITER_ONETERM ){
vendor/sqlite3.c:193669:        fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:193670:        pIter->pLeaf = 0;
vendor/sqlite3.c:193686:      assert( pIter->iLeafOffset<=pIter->pLeaf->nn );
vendor/sqlite3.c:193687:      fts5FastGetVarint32(pIter->pLeaf->p, pIter->iLeafOffset, nSz);
vendor/sqlite3.c:193688:      pIter->bDel = (nSz & 0x0001);
vendor/sqlite3.c:193689:      pIter->nPos = nSz>>1;
vendor/sqlite3.c:193690:      assert_nc( pIter->nPos>=0 );
vendor/sqlite3.c:193708:  Fts5DlidxIter *pDlidx = pIter->pDlidx;
vendor/sqlite3.c:193713:    int iSegid = pIter->pSeg->iSegid;
vendor/sqlite3.c:193717:    Fts5Data *pLeaf = pIter->pLeaf;         /* Current leaf data */
vendor/sqlite3.c:193723:    if( pIter->iTermLeafPgno==pIter->iLeafPgno ){
vendor/sqlite3.c:193724:      iPoslist = pIter->iTermLeafOffset;
vendor/sqlite3.c:193729:    pIter->iLeafOffset = iPoslist;
vendor/sqlite3.c:193734:    if( pIter->iEndofDoclist>=pLeaf->szLeaf ){
vendor/sqlite3.c:193736:      Fts5StructureSegment *pSeg = pIter->pSeg;
vendor/sqlite3.c:193740:      for(pgno=pIter->iLeafPgno+1; !p->rc && pgno<=pSeg->pgnoLast; pgno++){
vendor/sqlite3.c:193760:  ** pIter->iLeafOffset is already set to point to the position-list size
vendor/sqlite3.c:193769:    fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:193770:    pIter->pLeaf = pLast;
vendor/sqlite3.c:193771:    pIter->iLeafPgno = pgnoLast;
vendor/sqlite3.c:193773:    iOff += fts5GetVarint(&pLast->p[iOff], (u64*)&pIter->iRowid);
vendor/sqlite3.c:193774:    pIter->iLeafOffset = iOff;
vendor/sqlite3.c:193777:      pIter->iEndofDoclist = pLast->nn+1;
vendor/sqlite3.c:193779:      pIter->iEndofDoclist = fts5LeafFirstTermOff(pLast);
vendor/sqlite3.c:193791:** doclist-index from disk and initialize an iterator at (pIter->pDlidx).
vendor/sqlite3.c:193794:  int iSeg = pIter->pSeg->iSegid;
vendor/sqlite3.c:193795:  int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);
vendor/sqlite3.c:193796:  Fts5Data *pLeaf = pIter->pLeaf; /* Current leaf data */
vendor/sqlite3.c:193798:  assert( pIter->flags & FTS5_SEGITER_ONETERM );
vendor/sqlite3.c:193799:  assert( pIter->pDlidx==0 );
vendor/sqlite3.c:193804:  if( pIter->iTermLeafPgno==pIter->iLeafPgno 
vendor/sqlite3.c:193805:   && pIter->iEndofDoclist<pLeaf->szLeaf 
vendor/sqlite3.c:193810:  pIter->pDlidx = fts5DlidxIterInit(p, bRev, iSeg, pIter->iTermLeafPgno);
vendor/sqlite3.c:193834:  const u8 *a = pIter->pLeaf->p;
vendor/sqlite3.c:193835:  int szLeaf = pIter->pLeaf->szLeaf;
vendor/sqlite3.c:193836:  int n = pIter->pLeaf->nn;
vendor/sqlite3.c:193904:    fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:193905:    pIter->pLeaf = 0;
vendor/sqlite3.c:193910:      if( pIter->pLeaf==0 ) return;
vendor/sqlite3.c:193911:      a = pIter->pLeaf->p;
vendor/sqlite3.c:193912:      if( fts5LeafIsTermless(pIter->pLeaf)==0 ){
vendor/sqlite3.c:193913:        iPgidx = pIter->pLeaf->szLeaf;
vendor/sqlite3.c:193914:        iPgidx += fts5GetVarint32(&pIter->pLeaf->p[iPgidx], iOff);
vendor/sqlite3.c:193915:        if( iOff<4 || iOff>=pIter->pLeaf->szLeaf ){
vendor/sqlite3.c:193920:          n = pIter->pLeaf->nn;
vendor/sqlite3.c:193930:  pIter->iLeafOffset = iOff + nNew;
vendor/sqlite3.c:193931:  pIter->iTermLeafOffset = pIter->iLeafOffset;
vendor/sqlite3.c:193932:  pIter->iTermLeafPgno = pIter->iLeafPgno;
vendor/sqlite3.c:193934:  fts5BufferSet(&p->rc, &pIter->term, nKeep, pTerm);
vendor/sqlite3.c:193935:  fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);
vendor/sqlite3.c:193938:    pIter->iEndofDoclist = pIter->pLeaf->nn+1;
vendor/sqlite3.c:193942:    pIter->iEndofDoclist = iTermOff + nExtra;
vendor/sqlite3.c:193944:  pIter->iPgidxOff = iPgidx;
vendor/sqlite3.c:193984:  pIter->pSeg = pSeg;
vendor/sqlite3.c:194004:  pIter->iLeafPgno = iPg - 1;
vendor/sqlite3.c:194007:  if( pIter->pLeaf ){
vendor/sqlite3.c:194012:    pIter->flags |= FTS5_SEGITER_ONETERM;
vendor/sqlite3.c:194013:    if( pIter->pLeaf ){
vendor/sqlite3.c:194015:        pIter->flags |= FTS5_SEGITER_REVERSE;
vendor/sqlite3.c:194037:   || pIter->pLeaf==0                                               /* 2 */
vendor/sqlite3.c:194038:   || fts5BufferCompareBlob(&pIter->term, pTerm, nTerm)==0          /* 3 */
vendor/sqlite3.c:194039:   || (bGe && fts5BufferCompareBlob(&pIter->term, pTerm, nTerm)>0)  /* 4 */
vendor/sqlite3.c:194070:    pIter->flags |= FTS5_SEGITER_ONETERM;
vendor/sqlite3.c:194078:    sqlite3Fts5BufferSet(&p->rc, &pIter->term, n, z);
vendor/sqlite3.c:194083:    pIter->pLeaf = pLeaf;
vendor/sqlite3.c:194084:    pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (u64*)&pIter->iRowid);
vendor/sqlite3.c:194085:    pIter->iEndofDoclist = pLeaf->nn;
vendor/sqlite3.c:194088:      pIter->flags |= FTS5_SEGITER_REVERSE;
vendor/sqlite3.c:194102:  fts5BufferFree(&pIter->term);
vendor/sqlite3.c:194103:  fts5DataRelease(pIter->pLeaf);
vendor/sqlite3.c:194104:  fts5DataRelease(pIter->pNextLeaf);
vendor/sqlite3.c:194105:  fts5DlidxIterFree(pIter->pDlidx);
vendor/sqlite3.c:194106:  sqlite3_free(pIter->aRowidOffset);
vendor/sqlite3.c:194124:  int i1 = p1 - pIter->aSeg;
vendor/sqlite3.c:194125:  int i2 = p2 - pIter->aSeg;
vendor/sqlite3.c:194140:        res = ((p1->iRowid > p2->iRowid)==pIter->bRev) ? -1 : 1;
vendor/sqlite3.c:194157:** statement used to verify that the contents of the pIter->aFirst[] array
vendor/sqlite3.c:194162:    Fts5SegIter *pFirst = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
vendor/sqlite3.c:194165:    assert( (pFirst->pLeaf==0)==pIter->base.bEof );
vendor/sqlite3.c:194167:    /* Check that pIter->iSwitchRowid is set correctly. */
vendor/sqlite3.c:194168:    for(i=0; i<pIter->nSeg; i++){
vendor/sqlite3.c:194169:      Fts5SegIter *p1 = &pIter->aSeg[i];
vendor/sqlite3.c:194173:           || p1->iRowid==pIter->iSwitchRowid
vendor/sqlite3.c:194174:           || (p1->iRowid<pIter->iSwitchRowid)==pIter->bRev
vendor/sqlite3.c:194178:    for(i=0; i<pIter->nSeg; i+=2){
vendor/sqlite3.c:194179:      Fts5SegIter *p1 = &pIter->aSeg[i];
vendor/sqlite3.c:194180:      Fts5SegIter *p2 = &pIter->aSeg[i+1];
vendor/sqlite3.c:194181:      Fts5CResult *pRes = &pIter->aFirst[(pIter->nSeg + i) / 2];
vendor/sqlite3.c:194185:    for(i=1; i<(pIter->nSeg / 2); i+=2){
vendor/sqlite3.c:194186:      Fts5SegIter *p1 = &pIter->aSeg[ pIter->aFirst[i*2].iFirst ];
vendor/sqlite3.c:194187:      Fts5SegIter *p2 = &pIter->aSeg[ pIter->aFirst[i*2+1].iFirst ];
vendor/sqlite3.c:194188:      Fts5CResult *pRes = &pIter->aFirst[i];
vendor/sqlite3.c:194198:** Do the comparison necessary to populate pIter->aFirst[iOut].
vendor/sqlite3.c:194201:** in the pIter->aSeg[] array that is (a) not at EOF, and (b) pointing
vendor/sqlite3.c:194211:  Fts5CResult *pRes = &pIter->aFirst[iOut];
vendor/sqlite3.c:194213:  assert( iOut<pIter->nSeg && iOut>0 );
vendor/sqlite3.c:194214:  assert( pIter->bRev==0 || pIter->bRev==1 );
vendor/sqlite3.c:194216:  if( iOut>=(pIter->nSeg/2) ){
vendor/sqlite3.c:194217:    i1 = (iOut - pIter->nSeg/2) * 2;
vendor/sqlite3.c:194220:    i1 = pIter->aFirst[iOut*2].iFirst;
vendor/sqlite3.c:194221:    i2 = pIter->aFirst[iOut*2+1].iFirst;
vendor/sqlite3.c:194223:  p1 = &pIter->aSeg[i1];
vendor/sqlite3.c:194224:  p2 = &pIter->aSeg[i2];
vendor/sqlite3.c:194241:      res = ((p1->iRowid > p2->iRowid)==pIter->bRev) ? -1 : +1;
vendor/sqlite3.c:194264:  assert( iLeafPgno>pIter->iLeafPgno );
vendor/sqlite3.c:194266:  if( iLeafPgno>pIter->pSeg->pgnoLast ){
vendor/sqlite3.c:194269:    fts5DataRelease(pIter->pNextLeaf);
vendor/sqlite3.c:194270:    pIter->pNextLeaf = 0;
vendor/sqlite3.c:194271:    pIter->iLeafPgno = iLeafPgno-1;
vendor/sqlite3.c:194273:    assert( p->rc!=SQLITE_OK || pIter->iLeafPgno==iLeafPgno );
vendor/sqlite3.c:194277:      u8 *a = pIter->pLeaf->p;
vendor/sqlite3.c:194278:      int n = pIter->pLeaf->szLeaf;
vendor/sqlite3.c:194280:      iOff = fts5LeafFirstRowidOff(pIter->pLeaf);
vendor/sqlite3.c:194284:        iOff += fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
vendor/sqlite3.c:194285:        pIter->iLeafOffset = iOff;
vendor/sqlite3.c:194302:  int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);
vendor/sqlite3.c:194303:  Fts5DlidxIter *pDlidx = pIter->pDlidx;
vendor/sqlite3.c:194304:  int iLeafPgno = pIter->iLeafPgno;
vendor/sqlite3.c:194307:  assert( pIter->flags & FTS5_SEGITER_ONETERM );
vendor/sqlite3.c:194308:  assert( pIter->pDlidx );
vendor/sqlite3.c:194309:  assert( pIter->pLeaf );
vendor/sqlite3.c:194316:    assert_nc( iLeafPgno>=pIter->iLeafPgno || p->rc );
vendor/sqlite3.c:194317:    if( iLeafPgno>pIter->iLeafPgno ){
vendor/sqlite3.c:194322:    assert( pIter->pNextLeaf==0 );
vendor/sqlite3.c:194323:    assert( iMatch<pIter->iRowid );
vendor/sqlite3.c:194329:    assert( fts5DlidxIterEof(p, pDlidx) || iLeafPgno<=pIter->iLeafPgno );
vendor/sqlite3.c:194331:    if( iLeafPgno<pIter->iLeafPgno ){
vendor/sqlite3.c:194332:      pIter->iLeafPgno = iLeafPgno+1;
vendor/sqlite3.c:194339:    if( bMove && p->rc==SQLITE_OK ) pIter->xNext(p, pIter, 0);
vendor/sqlite3.c:194340:    if( pIter->pLeaf==0 ) break;
vendor/sqlite3.c:194341:    if( bRev==0 && pIter->iRowid>=iMatch ) break;
vendor/sqlite3.c:194342:    if( bRev!=0 && pIter->iRowid<=iMatch ) break;
vendor/sqlite3.c:194354:    for(i=0; i<pIter->nSeg; i++){
vendor/sqlite3.c:194355:      fts5SegIterClear(&pIter->aSeg[i]);
vendor/sqlite3.c:194357:    fts5StructureRelease(pIter->pStruct);
vendor/sqlite3.c:194358:    fts5BufferFree(&pIter->poslist);
vendor/sqlite3.c:194370:  for(i=(pIter->nSeg+iChanged)/2; i>=iMinset && p->rc==SQLITE_OK; i=i/2){
vendor/sqlite3.c:194373:      Fts5SegIter *pSeg = &pIter->aSeg[iEq];
vendor/sqlite3.c:194376:      i = pIter->nSeg + iEq;
vendor/sqlite3.c:194384:** attempts to update the contents of the pIter->aFirst[] accordingly.
vendor/sqlite3.c:194396:  Fts5SegIter *pNew = &pIter->aSeg[iChanged];
vendor/sqlite3.c:194398:  if( pNew->iRowid==pIter->iSwitchRowid
vendor/sqlite3.c:194399:   || (pNew->iRowid<pIter->iSwitchRowid)==pIter->bRev
vendor/sqlite3.c:194402:    Fts5SegIter *pOther = &pIter->aSeg[iChanged ^ 0x0001];
vendor/sqlite3.c:194403:    pIter->iSwitchRowid = pIter->bRev ? SMALLEST_INT64 : LARGEST_INT64;
vendor/sqlite3.c:194404:    for(i=(pIter->nSeg+iChanged)/2; 1; i=i/2){
vendor/sqlite3.c:194405:      Fts5CResult *pRes = &pIter->aFirst[i];
vendor/sqlite3.c:194408:      assert( pRes->bTermEq==0 || pOther->pLeaf );
vendor/sqlite3.c:194411:        if( pNew->iRowid==pOther->iRowid ){
vendor/sqlite3.c:194413:        }else if( (pOther->iRowid>pNew->iRowid)==pIter->bRev ){
vendor/sqlite3.c:194414:          pIter->iSwitchRowid = pOther->iRowid;
vendor/sqlite3.c:194416:        }else if( (pOther->iRowid>pIter->iSwitchRowid)==pIter->bRev ){
vendor/sqlite3.c:194417:          pIter->iSwitchRowid = pOther->iRowid;
vendor/sqlite3.c:194420:      pRes->iFirst = (u16)(pNew - pIter->aSeg);
vendor/sqlite3.c:194423:      pOther = &pIter->aSeg[ pIter->aFirst[i ^ 0x0001].iFirst ];
vendor/sqlite3.c:194432:** Set the pIter->bEof variable based on the state of the sub-iterators.
vendor/sqlite3.c:194435:  Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
vendor/sqlite3.c:194436:  pIter->base.bEof = pSeg->pLeaf==0;
vendor/sqlite3.c:194437:  pIter->iSwitchRowid = pSeg->iRowid;
vendor/sqlite3.c:194454:  assert( pIter->base.bEof==0 );
vendor/sqlite3.c:194456:    int iFirst = pIter->aFirst[1].iFirst;
vendor/sqlite3.c:194458:    Fts5SegIter *pSeg = &pIter->aSeg[iFirst];
vendor/sqlite3.c:194471:      pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];
vendor/sqlite3.c:194476:    assert( pSeg==&pIter->aSeg[pIter->aFirst[1].iFirst] && pSeg->pLeaf );
vendor/sqlite3.c:194477:    if( pIter->bSkipEmpty==0 || pSeg->nPos ){
vendor/sqlite3.c:194478:      pIter->xSetOutputs(pIter, pSeg);
vendor/sqlite3.c:194490:  assert( pIter->bSkipEmpty );
vendor/sqlite3.c:194494:      int iFirst = pIter->aFirst[1].iFirst;
vendor/sqlite3.c:194495:      Fts5SegIter *pSeg = &pIter->aSeg[iFirst];
vendor/sqlite3.c:194794:  assert( pIter->pIndex->pConfig->eDetail==FTS5_DETAIL_NONE );
vendor/sqlite3.c:194795:  pIter->base.iRowid = pSeg->iRowid;
vendor/sqlite3.c:194796:  pIter->base.nData = pSeg->nPos;
vendor/sqlite3.c:194804:  pIter->base.iRowid = pSeg->iRowid;
vendor/sqlite3.c:194805:  pIter->base.nData = pSeg->nPos;
vendor/sqlite3.c:194807:  assert( pIter->pIndex->pConfig->eDetail!=FTS5_DETAIL_NONE );
vendor/sqlite3.c:194808:  assert( pIter->pColset==0 );
vendor/sqlite3.c:194813:    pIter->base.pData = &pSeg->pLeaf->p[pSeg->iLeafOffset];
vendor/sqlite3.c:194818:    fts5BufferZero(&pIter->poslist);
vendor/sqlite3.c:194819:    fts5SegiterPoslist(pIter->pIndex, pSeg, 0, &pIter->poslist);
vendor/sqlite3.c:194820:    pIter->base.pData = pIter->poslist.p;
vendor/sqlite3.c:194830:  pIter->base.nData = 0;
vendor/sqlite3.c:194839:  fts5BufferZero(&pIter->poslist);
vendor/sqlite3.c:194840:  fts5SegiterPoslist(pIter->pIndex, pSeg, pIter->pColset, &pIter->poslist);
vendor/sqlite3.c:194841:  pIter->base.iRowid = pSeg->iRowid;
vendor/sqlite3.c:194842:  pIter->base.pData = pIter->poslist.p;
vendor/sqlite3.c:194843:  pIter->base.nData = pIter->poslist.n;
vendor/sqlite3.c:194858:  assert( pIter->pIndex->pConfig->eDetail==FTS5_DETAIL_COLUMNS );
vendor/sqlite3.c:194859:  assert( pIter->pColset );
vendor/sqlite3.c:194867:    int *aiCol = pIter->pColset->aiCol;
vendor/sqlite3.c:194868:    int *aiColEnd = &aiCol[pIter->pColset->nCol];
vendor/sqlite3.c:194870:    u8 *aOut = pIter->poslist.p;
vendor/sqlite3.c:194873:    pIter->base.iRowid = pSeg->iRowid;
vendor/sqlite3.c:194888:    pIter->base.pData = pIter->poslist.p;
vendor/sqlite3.c:194889:    pIter->base.nData = aOut - pIter->poslist.p;
vendor/sqlite3.c:194897:  Fts5Colset *pColset = pIter->pColset;
vendor/sqlite3.c:194898:  pIter->base.iRowid = pSeg->iRowid;
vendor/sqlite3.c:194900:  assert( pIter->pIndex->pConfig->eDetail==FTS5_DETAIL_FULL );
vendor/sqlite3.c:194908:      pIter->base.nData = fts5IndexExtractCol(&a, pSeg->nPos,pColset->aiCol[0]);
vendor/sqlite3.c:194909:      pIter->base.pData = a;
vendor/sqlite3.c:194911:      int *pRc = &pIter->pIndex->rc;
vendor/sqlite3.c:194912:      fts5BufferZero(&pIter->poslist);
vendor/sqlite3.c:194913:      fts5IndexExtractColset(pRc, pColset, a, pSeg->nPos, &pIter->poslist);
vendor/sqlite3.c:194914:      pIter->base.pData = pIter->poslist.p;
vendor/sqlite3.c:194915:      pIter->base.nData = pIter->poslist.n;
vendor/sqlite3.c:194921:    fts5BufferZero(&pIter->poslist);
vendor/sqlite3.c:194922:    fts5SegiterPoslist(pIter->pIndex, pSeg, pColset, &pIter->poslist);
vendor/sqlite3.c:194923:    pIter->base.pData = pIter->poslist.p;
vendor/sqlite3.c:194924:    pIter->base.nData = pIter->poslist.n;
vendor/sqlite3.c:194930:    Fts5Config *pConfig = pIter->pIndex->pConfig;
vendor/sqlite3.c:194932:      pIter->xSetOutputs = fts5IterSetOutputs_None;
vendor/sqlite3.c:194935:    else if( pIter->pColset==0 ){
vendor/sqlite3.c:194936:      pIter->xSetOutputs = fts5IterSetOutputs_Nocolset;
vendor/sqlite3.c:194939:    else if( pIter->pColset->nCol==0 ){
vendor/sqlite3.c:194940:      pIter->xSetOutputs = fts5IterSetOutputs_ZeroColset;
vendor/sqlite3.c:194944:      pIter->xSetOutputs = fts5IterSetOutputs_Full;
vendor/sqlite3.c:194950:        pIter->xSetOutputs = fts5IterSetOutputs_Col100;
vendor/sqlite3.c:194951:        sqlite3Fts5BufferSize(pRc, &pIter->poslist, pConfig->nCol);
vendor/sqlite3.c:194953:        pIter->xSetOutputs = fts5IterSetOutputs_Col;
vendor/sqlite3.c:195044:    for(iIter=pNew->nSeg-1; iIter>0; iIter--){
vendor/sqlite3.c:195083:    pIter->flags = FTS5_SEGITER_ONETERM;
vendor/sqlite3.c:195085:      pIter->pLeaf = pData;
vendor/sqlite3.c:195086:      pIter->iLeafOffset = fts5GetVarint(pData->p, (u64*)&pIter->iRowid);
vendor/sqlite3.c:195087:      pIter->iEndofDoclist = pData->nn;
vendor/sqlite3.c:195091:        pIter->flags |= FTS5_SEGITER_REVERSE;
vendor/sqlite3.c:195114:      || (pIter->aSeg[ pIter->aFirst[1].iFirst ].pLeaf==0)==pIter->base.bEof 
vendor/sqlite3.c:195116:  return (p->rc || pIter->base.bEof);
vendor/sqlite3.c:195125:  assert( pIter->aSeg[ pIter->aFirst[1].iFirst ].pLeaf );
vendor/sqlite3.c:195126:  return pIter->aSeg[ pIter->aFirst[1].iFirst ].iRowid;
vendor/sqlite3.c:195142:    if( pIter->bRev==0 && iRowid>=iMatch ) break;
vendor/sqlite3.c:195143:    if( pIter->bRev!=0 && iRowid<=iMatch ) break;
vendor/sqlite3.c:195152:  Fts5SegIter *p = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
vendor/sqlite3.c:195251:  assert( bFlush==0 || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n>0) );
vendor/sqlite3.c:195252:  for(i=0; i<pWriter->nDlidx; i++){
vendor/sqlite3.c:195253:    Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];
vendor/sqlite3.c:195258:          FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),
vendor/sqlite3.c:195268:** Grow the pWriter->aDlidx[] array to at least nLvl elements in size.
vendor/sqlite3.c:195276:  if( p->rc==SQLITE_OK && nLvl>=pWriter->nDlidx ){
vendor/sqlite3.c:195278:        pWriter->aDlidx, sizeof(Fts5DlidxWriter) * nLvl
vendor/sqlite3.c:195283:      int nByte = sizeof(Fts5DlidxWriter) * (nLvl - pWriter->nDlidx);
vendor/sqlite3.c:195284:      memset(&aDlidx[pWriter->nDlidx], 0, nByte);
vendor/sqlite3.c:195285:      pWriter->aDlidx = aDlidx;
vendor/sqlite3.c:195286:      pWriter->nDlidx = nLvl;
vendor/sqlite3.c:195293:** If the current doclist-index accumulating in pWriter->aDlidx[] is large
vendor/sqlite3.c:195302:  if( pWriter->aDlidx[0].buf.n>0 && pWriter->nEmpty>=FTS5_MIN_DLIDX_SIZE ){
vendor/sqlite3.c:195306:  pWriter->nEmpty = 0;
vendor/sqlite3.c:195312:** last term on leaf page (pWriter->iBtPage) is completed. 
vendor/sqlite3.c:195324:  assert( pWriter->iBtPage || pWriter->nEmpty==0 );
vendor/sqlite3.c:195325:  if( pWriter->iBtPage==0 ) return;
vendor/sqlite3.c:195329:    const char *z = (pWriter->btterm.n>0?(const char*)pWriter->btterm.p:"");
vendor/sqlite3.c:195331:    /* sqlite3_bind_int(p->pIdxWriter, 1, pWriter->iSegid); */
vendor/sqlite3.c:195332:    sqlite3_bind_blob(p->pIdxWriter, 2, z, pWriter->btterm.n, SQLITE_STATIC);
vendor/sqlite3.c:195333:    sqlite3_bind_int64(p->pIdxWriter, 3, bFlag + ((i64)pWriter->iBtPage<<1));
vendor/sqlite3.c:195337:  pWriter->iBtPage = 0;
vendor/sqlite3.c:195355:  fts5BufferSet(&p->rc, &pWriter->btterm, nTerm, pTerm);
vendor/sqlite3.c:195356:  pWriter->iBtPage = pWriter->writer.pgno;
vendor/sqlite3.c:195369:  if( pWriter->bFirstRowidInPage && pWriter->aDlidx[0].buf.n>0 ){
vendor/sqlite3.c:195370:    Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[0];
vendor/sqlite3.c:195376:  pWriter->nEmpty++;
vendor/sqlite3.c:195403:    Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];
vendor/sqlite3.c:195413:          FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),
vendor/sqlite3.c:195417:      pDlidx = &pWriter->aDlidx[i];
vendor/sqlite3.c:195440:      i64 iPgno = (i==0 ? pWriter->writer.pgno : pDlidx[-1].pgno);
vendor/sqlite3.c:195455:  Fts5PageWriter *pPage = &pWriter->writer;
vendor/sqlite3.c:195458:  assert( (pPage->pgidx.n==0)==(pWriter->bFirstTermInPage) );
vendor/sqlite3.c:195464:  if( pWriter->bFirstTermInPage ){
vendor/sqlite3.c:195474:  iRowid = FTS5_SEGMENT_ROWID(pWriter->iSegid, pPage->pgno);
vendor/sqlite3.c:195485:  pWriter->nLeafWritten++;
vendor/sqlite3.c:195488:  pWriter->bFirstTermInPage = 1;
vendor/sqlite3.c:195489:  pWriter->bFirstRowidInPage = 1;
vendor/sqlite3.c:195505:  Fts5PageWriter *pPage = &pWriter->writer;
vendor/sqlite3.c:195506:  Fts5Buffer *pPgidx = &pWriter->writer.pgidx;
vendor/sqlite3.c:195510:  assert( pPage->buf.n>4 || pWriter->bFirstTermInPage );
vendor/sqlite3.c:195530:  if( pWriter->bFirstTermInPage ){
vendor/sqlite3.c:195551:      pPage = &pWriter->writer;
vendor/sqlite3.c:195565:  pWriter->bFirstTermInPage = 0;
vendor/sqlite3.c:195567:  pWriter->bFirstRowidInPage = 0;
vendor/sqlite3.c:195568:  pWriter->bFirstRowidInDoclist = 1;
vendor/sqlite3.c:195570:  assert( p->rc || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n==0) );
vendor/sqlite3.c:195571:  pWriter->aDlidx[0].pgno = pPage->pgno;
vendor/sqlite3.c:195583:    Fts5PageWriter *pPage = &pWriter->writer;
vendor/sqlite3.c:195592:    if( pWriter->bFirstRowidInPage ){
vendor/sqlite3.c:195598:    if( pWriter->bFirstRowidInDoclist || pWriter->bFirstRowidInPage ){
vendor/sqlite3.c:195601:      assert( p->rc || iRowid>pWriter->iPrevRowid );
vendor/sqlite3.c:195602:      fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid - pWriter->iPrevRowid);
vendor/sqlite3.c:195604:    pWriter->iPrevRowid = iRowid;
vendor/sqlite3.c:195605:    pWriter->bFirstRowidInDoclist = 0;
vendor/sqlite3.c:195606:    pWriter->bFirstRowidInPage = 0;
vendor/sqlite3.c:195616:  Fts5PageWriter *pPage = &pWriter->writer;
vendor/sqlite3.c:195650:  Fts5PageWriter *pLeaf = &pWriter->writer;
vendor/sqlite3.c:195664:  fts5BufferFree(&pWriter->btterm);
vendor/sqlite3.c:195666:  for(i=0; i<pWriter->nDlidx; i++){
vendor/sqlite3.c:195667:    sqlite3Fts5BufferFree(&pWriter->aDlidx[i].buf);
vendor/sqlite3.c:195669:  sqlite3_free(pWriter->aDlidx);
vendor/sqlite3.c:195680:  pWriter->iSegid = iSegid;
vendor/sqlite3.c:195683:  pWriter->writer.pgno = 1;
vendor/sqlite3.c:195684:  pWriter->bFirstTermInPage = 1;
vendor/sqlite3.c:195685:  pWriter->iBtPage = 1;
vendor/sqlite3.c:195687:  assert( pWriter->writer.buf.n==0 );
vendor/sqlite3.c:195688:  assert( pWriter->writer.pgidx.n==0 );
vendor/sqlite3.c:195691:  sqlite3Fts5BufferSize(&p->rc, &pWriter->writer.pgidx, nBuffer);
vendor/sqlite3.c:195692:  sqlite3Fts5BufferSize(&p->rc, &pWriter->writer.buf, nBuffer);
vendor/sqlite3.c:195704:    memset(pWriter->writer.buf.p, 0, 4);
vendor/sqlite3.c:195705:    pWriter->writer.buf.n = 4;
vendor/sqlite3.c:195710:    sqlite3_bind_int(p->pIdxWriter, 1, pWriter->iSegid);
vendor/sqlite3.c:195723:  for(i=0; i<pIter->nSeg; i++){
vendor/sqlite3.c:195724:    Fts5SegIter *pSeg = &pIter->aSeg[i];
vendor/sqlite3.c:195855:    Fts5SegIter *pSegIter = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
vendor/sqlite3.c:195870:    if( pSegIter->nPos==0 && (bOldest || pSegIter->bDel==0) ) continue;
vendor/sqlite3.c:195883:      if( pSegIter->bDel ){
vendor/sqlite3.c:195885:        if( pSegIter->nPos>0 ){
vendor/sqlite3.c:195891:      nPos = pSegIter->nPos*2 + pSegIter->bDel;
vendor/sqlite3.c:196379:  u8 *p = pIter->aPoslist + pIter->nSize + pIter->nPoslist;
vendor/sqlite3.c:196381:  assert( pIter->aPoslist );
vendor/sqlite3.c:196382:  if( p>=pIter->aEof ){
vendor/sqlite3.c:196383:    pIter->aPoslist = 0;
vendor/sqlite3.c:196388:    pIter->iRowid += iDelta;
vendor/sqlite3.c:196393:      pIter->nSize = fts5GetVarint32(p, nPos);
vendor/sqlite3.c:196394:      pIter->nPoslist = (nPos>>1);
vendor/sqlite3.c:196396:      pIter->nPoslist = ((int)(p[0])) >> 1;
vendor/sqlite3.c:196397:      pIter->nSize = 1;
vendor/sqlite3.c:196400:    pIter->aPoslist = p;
vendor/sqlite3.c:196409:  pIter->aPoslist = pBuf->p;
vendor/sqlite3.c:196410:  pIter->aEof = &pBuf->p[pBuf->n];
vendor/sqlite3.c:197014:  assert( pIter->pIndex->rc==SQLITE_OK );
vendor/sqlite3.c:197015:  fts5MultiIterNext(pIter->pIndex, pIter, 0, 0);
vendor/sqlite3.c:197016:  return fts5IndexReturn(pIter->pIndex);
vendor/sqlite3.c:197024:  Fts5Index *p = pIter->pIndex;
vendor/sqlite3.c:197026:  assert( pIter->pIndex->rc==SQLITE_OK );
vendor/sqlite3.c:197030:    Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
vendor/sqlite3.c:197034:      pIter->base.bEof = 1;
vendor/sqlite3.c:197038:  return fts5IndexReturn(pIter->pIndex);
vendor/sqlite3.c:197048:  fts5MultiIterNextFrom(pIter->pIndex, pIter, iMatch);
vendor/sqlite3.c:197049:  return fts5IndexReturn(pIter->pIndex);
vendor/sqlite3.c:197068:    Fts5Index *pIndex = pIter->pIndex;
vendor/sqlite3.c:197238:    i64 rowid = pIter->iRowid;
vendor/sqlite3.c:197244:      for(sqlite3Fts5PoslistReaderInit(pIter->pData, pIter->nData, &sReader);
vendor/sqlite3.c:197618:      fts5SegiterPoslist(p, &pIter->aSeg[pIter->aFirst[1].iFirst], 0, &poslist);
vendor/sqlite3.c:197848:** The implementation of user-defined scalar function fts5_decode().
vendor/sqlite3.c:198035:** The implementation of user-defined scalar function fts5_rowid().
vendor/sqlite3.c:198070:** connection db. It registers several user-defined scalar functions useful
vendor/sqlite3.c:198198:  void *pUserData;                /* User-data pointer */
vendor/sqlite3.c:198717:  for(pCsr=pTab->pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){
vendor/sqlite3.c:198718:    if( pCsr->base.pVtab==(sqlite3_vtab*)pTab ) return SQLITE_OK;
vendor/sqlite3.c:198740:      pCsr->aColumnSize = (int*)&pCsr[1];
vendor/sqlite3.c:198741:      pCsr->pNext = pGlobal->pCsr;
vendor/sqlite3.c:198743:      pCsr->iCsrId = ++pGlobal->iNextId;
vendor/sqlite3.c:198753:  if( pCsr->ePlan==FTS5_PLAN_SCAN ){
vendor/sqlite3.c:198754:    return (pCsr->bDesc) ? FTS5_STMT_SCAN_DESC : FTS5_STMT_SCAN_ASC;
vendor/sqlite3.c:198774:  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:198778:  sqlite3_free(pCsr->aInstIter);
vendor/sqlite3.c:198779:  sqlite3_free(pCsr->aInst);
vendor/sqlite3.c:198780:  if( pCsr->pStmt ){
vendor/sqlite3.c:198782:    sqlite3Fts5StorageStmtRelease(pTab->pStorage, eStmt, pCsr->pStmt);
vendor/sqlite3.c:198784:  if( pCsr->pSorter ){
vendor/sqlite3.c:198785:    Fts5Sorter *pSorter = pCsr->pSorter;
vendor/sqlite3.c:198786:    sqlite3_finalize(pSorter->pStmt);
vendor/sqlite3.c:198790:  if( pCsr->ePlan!=FTS5_PLAN_SOURCE ){
vendor/sqlite3.c:198791:    sqlite3Fts5ExprFree(pCsr->pExpr);
vendor/sqlite3.c:198794:  for(pData=pCsr->pAuxdata; pData; pData=pNext){
vendor/sqlite3.c:198800:  sqlite3_finalize(pCsr->pRankArgStmt);
vendor/sqlite3.c:198801:  sqlite3_free(pCsr->apRankArg);
vendor/sqlite3.c:198804:    sqlite3_free(pCsr->zRank);
vendor/sqlite3.c:198805:    sqlite3_free(pCsr->zRankArgs);
vendor/sqlite3.c:198808:  memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan - (u8*)pCsr));
vendor/sqlite3.c:198818:    Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
vendor/sqlite3.c:198825:    *pp = pCsr->pNext;
vendor/sqlite3.c:198833:  Fts5Sorter *pSorter = pCsr->pSorter;
vendor/sqlite3.c:198836:  rc = sqlite3_step(pSorter->pStmt);
vendor/sqlite3.c:198848:    pSorter->iRowid = sqlite3_column_int64(pSorter->pStmt, 0);
vendor/sqlite3.c:198849:    nBlob = sqlite3_column_bytes(pSorter->pStmt, 1);
vendor/sqlite3.c:198850:    aBlob = a = sqlite3_column_blob(pSorter->pStmt, 1);
vendor/sqlite3.c:198854:      for(i=0; i<(pSorter->nIdx-1); i++){
vendor/sqlite3.c:198858:        pSorter->aIdx[i] = iOff;
vendor/sqlite3.c:198860:      pSorter->aIdx[i] = &aBlob[nBlob] - a;
vendor/sqlite3.c:198861:      pSorter->aPoslist = a;
vendor/sqlite3.c:198877:  for(pCsr=pTab->pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){
vendor/sqlite3.c:198878:    if( pCsr->ePlan==FTS5_PLAN_MATCH
vendor/sqlite3.c:198879:     && pCsr->base.pVtab==(sqlite3_vtab*)pTab 
vendor/sqlite3.c:198902:    Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:198903:    int bDesc = pCsr->bDesc;
vendor/sqlite3.c:198904:    i64 iRowid = sqlite3Fts5ExprRowid(pCsr->pExpr);
vendor/sqlite3.c:198906:    rc = sqlite3Fts5ExprFirst(pCsr->pExpr, pTab->pIndex, iRowid, bDesc);
vendor/sqlite3.c:198907:    if( rc==SQLITE_OK &&  iRowid!=sqlite3Fts5ExprRowid(pCsr->pExpr) ){
vendor/sqlite3.c:198913:    if( sqlite3Fts5ExprEof(pCsr->pExpr) ){
vendor/sqlite3.c:198934:  assert( (pCsr->ePlan<3)==
vendor/sqlite3.c:198935:          (pCsr->ePlan==FTS5_PLAN_MATCH || pCsr->ePlan==FTS5_PLAN_SOURCE) 
vendor/sqlite3.c:198939:  if( pCsr->ePlan<3 ){
vendor/sqlite3.c:198942:    rc = sqlite3Fts5ExprNext(pCsr->pExpr, pCsr->iLastRowid);
vendor/sqlite3.c:198943:    CsrFlagSet(pCsr, sqlite3Fts5ExprEof(pCsr->pExpr));
vendor/sqlite3.c:198946:    switch( pCsr->ePlan ){
vendor/sqlite3.c:198959:        rc = sqlite3_step(pCsr->pStmt);
vendor/sqlite3.c:198962:          rc = sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:199009:  const char *zRank = pCsr->zRank;
vendor/sqlite3.c:199010:  const char *zRankArgs = pCsr->zRankArgs;
vendor/sqlite3.c:199012:  nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
vendor/sqlite3.c:199017:  pSorter->nIdx = nPhrase;
vendor/sqlite3.c:199026:  rc = fts5PrepareStatement(&pSorter->pStmt, pConfig,
vendor/sqlite3.c:199034:  pCsr->pSorter = pSorter;
vendor/sqlite3.c:199043:    sqlite3_finalize(pSorter->pStmt);
vendor/sqlite3.c:199045:    pCsr->pSorter = 0;
vendor/sqlite3.c:199053:  Fts5Expr *pExpr = pCsr->pExpr;
vendor/sqlite3.c:199054:  rc = sqlite3Fts5ExprFirst(pExpr, pTab->pIndex, pCsr->iFirstRowid, bDesc);
vendor/sqlite3.c:199081:  pCsr->ePlan = FTS5_PLAN_SPECIAL;
vendor/sqlite3.c:199084:    pCsr->iSpecial = sqlite3Fts5IndexReads(pTab->pIndex);
vendor/sqlite3.c:199087:    pCsr->iSpecial = pCsr->iCsrId;
vendor/sqlite3.c:199116:  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:199120:  const char *zRank = pCsr->zRank;
vendor/sqlite3.c:199121:  const char *zRankArgs = pCsr->zRankArgs;
vendor/sqlite3.c:199130:      assert( rc==SQLITE_OK || pCsr->pRankArgStmt==0 );
vendor/sqlite3.c:199134:          pCsr->nRankArg = sqlite3_column_count(pStmt);
vendor/sqlite3.c:199135:          nByte = sizeof(sqlite3_value*)*pCsr->nRankArg;
vendor/sqlite3.c:199136:          pCsr->apRankArg = (sqlite3_value**)sqlite3Fts5MallocZero(&rc, nByte);
vendor/sqlite3.c:199139:            for(i=0; i<pCsr->nRankArg; i++){
vendor/sqlite3.c:199140:              pCsr->apRankArg[i] = sqlite3_column_value(pStmt, i);
vendor/sqlite3.c:199143:          pCsr->pRankArgStmt = pStmt;
vendor/sqlite3.c:199161:  pCsr->pRank = pAux;
vendor/sqlite3.c:199183:      pCsr->zRank = zRank;
vendor/sqlite3.c:199184:      pCsr->zRankArgs = zRankArgs;
vendor/sqlite3.c:199187:      pCsr->base.pVtab->zErrMsg = sqlite3_mprintf(
vendor/sqlite3.c:199193:      pCsr->zRank = (char*)pConfig->zRank;
vendor/sqlite3.c:199194:      pCsr->zRankArgs = (char*)pConfig->zRankArgs;
vendor/sqlite3.c:199196:      pCsr->zRank = (char*)FTS5_DEFAULT_RANK;
vendor/sqlite3.c:199197:      pCsr->zRankArgs = 0;
vendor/sqlite3.c:199231:  Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
vendor/sqlite3.c:199249:  if( pCsr->ePlan ){
vendor/sqlite3.c:199251:    memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan-(u8*)pCsr));
vendor/sqlite3.c:199254:  assert( pCsr->pStmt==0 );
vendor/sqlite3.c:199255:  assert( pCsr->pExpr==0 );
vendor/sqlite3.c:199256:  assert( pCsr->csrflags==0 );
vendor/sqlite3.c:199257:  assert( pCsr->pRank==0 );
vendor/sqlite3.c:199258:  assert( pCsr->zRank==0 );
vendor/sqlite3.c:199259:  assert( pCsr->zRankArgs==0 );
vendor/sqlite3.c:199278:  pCsr->bDesc = bDesc = ((idxNum & FTS5_BI_ORDER_DESC) ? 1 : 0);
vendor/sqlite3.c:199288:    pCsr->iFirstRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);
vendor/sqlite3.c:199289:    pCsr->iLastRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);
vendor/sqlite3.c:199291:    pCsr->iLastRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);
vendor/sqlite3.c:199292:    pCsr->iFirstRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);
vendor/sqlite3.c:199304:    assert( pCsr->iLastRowid==LARGEST_INT64 );
vendor/sqlite3.c:199305:    assert( pCsr->iFirstRowid==SMALLEST_INT64 );
vendor/sqlite3.c:199306:    pCsr->ePlan = FTS5_PLAN_SOURCE;
vendor/sqlite3.c:199307:    pCsr->pExpr = pTab->pSortCsr->pExpr;
vendor/sqlite3.c:199322:        rc = sqlite3Fts5ExprNew(pConfig, iCol, zExpr, &pCsr->pExpr, pzErr);
vendor/sqlite3.c:199325:            pCsr->ePlan = FTS5_PLAN_SORTED_MATCH;
vendor/sqlite3.c:199328:            pCsr->ePlan = FTS5_PLAN_MATCH;
vendor/sqlite3.c:199342:    pCsr->ePlan = (pRowidEq ? FTS5_PLAN_ROWID : FTS5_PLAN_SCAN);
vendor/sqlite3.c:199344:        pTab->pStorage, fts5StmtType(pCsr), &pCsr->pStmt, &pTab->base.zErrMsg
vendor/sqlite3.c:199347:      if( pCsr->ePlan==FTS5_PLAN_ROWID ){
vendor/sqlite3.c:199348:        sqlite3_bind_value(pCsr->pStmt, 1, apVal[0]);
vendor/sqlite3.c:199350:        sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iFirstRowid);
vendor/sqlite3.c:199351:        sqlite3_bind_int64(pCsr->pStmt, 2, pCsr->iLastRowid);
vendor/sqlite3.c:199374:  assert( pCsr->ePlan==FTS5_PLAN_MATCH 
vendor/sqlite3.c:199375:       || pCsr->ePlan==FTS5_PLAN_SORTED_MATCH 
vendor/sqlite3.c:199376:       || pCsr->ePlan==FTS5_PLAN_SOURCE 
vendor/sqlite3.c:199378:  if( pCsr->pSorter ){
vendor/sqlite3.c:199379:    return pCsr->pSorter->iRowid;
vendor/sqlite3.c:199381:    return sqlite3Fts5ExprRowid(pCsr->pExpr);
vendor/sqlite3.c:199393:  int ePlan = pCsr->ePlan;
vendor/sqlite3.c:199408:      *pRowid = sqlite3_column_int64(pCsr->pStmt, 0);
vendor/sqlite3.c:199426:  if( pCsr->pStmt==0 ){
vendor/sqlite3.c:199427:    Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:199430:        pTab->pStorage, eStmt, &pCsr->pStmt, (bErrormsg?&pTab->base.zErrMsg:0)
vendor/sqlite3.c:199437:    assert( pCsr->pExpr );
vendor/sqlite3.c:199438:    sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:199439:    sqlite3_bind_int64(pCsr->pStmt, 1, fts5CursorRowid(pCsr));
vendor/sqlite3.c:199440:    rc = sqlite3_step(pCsr->pStmt);
vendor/sqlite3.c:199445:      rc = sqlite3_reset(pCsr->pStmt);
vendor/sqlite3.c:199743:  return pCsr->pAux->pUserData;
vendor/sqlite3.c:199748:  return ((Fts5Table*)(pCsr->base.pVtab))->pConfig->nCol;
vendor/sqlite3.c:199757:  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:199763:  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:199774:  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:199782:  return sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
vendor/sqlite3.c:199787:  return sqlite3Fts5ExprPhraseSize(pCsr->pExpr, iPhrase);
vendor/sqlite3.c:199798:  if( fts5IsContentless((Fts5Table*)(pCsr->base.pVtab)) ){
vendor/sqlite3.c:199804:      *pz = (const char*)sqlite3_column_text(pCsr->pStmt, iCol+1);
vendor/sqlite3.c:199805:      *pn = sqlite3_column_bytes(pCsr->pStmt, iCol+1);
vendor/sqlite3.c:199817:  Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;
vendor/sqlite3.c:199819:  int bLive = (pCsr->pSorter==0);
vendor/sqlite3.c:199826:      aPopulator = sqlite3Fts5ExprClearPoslists(pCsr->pExpr, bLive);
vendor/sqlite3.c:199833:              pConfig, pCsr->pExpr, aPopulator, i, z, n
vendor/sqlite3.c:199839:      if( pCsr->pSorter ){
vendor/sqlite3.c:199840:        sqlite3Fts5ExprCheckPoslists(pCsr->pExpr, pCsr->pSorter->iRowid);
vendor/sqlite3.c:199846:  if( pCsr->pSorter && pConfig->eDetail==FTS5_DETAIL_FULL ){
vendor/sqlite3.c:199847:    Fts5Sorter *pSorter = pCsr->pSorter;
vendor/sqlite3.c:199848:    int i1 = (iPhrase==0 ? 0 : pSorter->aIdx[iPhrase-1]);
vendor/sqlite3.c:199849:    *pn = pSorter->aIdx[iPhrase] - i1;
vendor/sqlite3.c:199850:    *pa = &pSorter->aPoslist[i1];
vendor/sqlite3.c:199852:    *pn = sqlite3Fts5ExprPoslist(pCsr->pExpr, iPhrase, pa);
vendor/sqlite3.c:199868:  nIter = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
vendor/sqlite3.c:199869:  if( pCsr->aInstIter==0 ){
vendor/sqlite3.c:199871:    pCsr->aInstIter = (Fts5PoslistReader*)sqlite3Fts5MallocZero(&rc, nByte);
vendor/sqlite3.c:199873:  aIter = pCsr->aInstIter;
vendor/sqlite3.c:199903:        if( nInst>=pCsr->nInstAlloc ){
vendor/sqlite3.c:199904:          pCsr->nInstAlloc = pCsr->nInstAlloc ? pCsr->nInstAlloc*2 : 32;
vendor/sqlite3.c:199906:              pCsr->aInst, pCsr->nInstAlloc*sizeof(int)*3
vendor/sqlite3.c:199909:            pCsr->aInst = aInst;
vendor/sqlite3.c:199916:        aInst = &pCsr->aInst[3 * (nInst-1)];
vendor/sqlite3.c:199924:    pCsr->nInstCount = nInst;
vendor/sqlite3.c:199935:    *pnInst = pCsr->nInstCount;
vendor/sqlite3.c:199952:    if( iIdx<0 || iIdx>=pCsr->nInstCount ){
vendor/sqlite3.c:199955:    }else if( fts5IsOffsetless((Fts5Table*)pCsr->base.pVtab) ){
vendor/sqlite3.c:199956:      *piPhrase = pCsr->aInst[iIdx*3];
vendor/sqlite3.c:199957:      *piCol = pCsr->aInst[iIdx*3 + 2];
vendor/sqlite3.c:199961:      *piPhrase = pCsr->aInst[iIdx*3];
vendor/sqlite3.c:199962:      *piCol = pCsr->aInst[iIdx*3 + 1];
vendor/sqlite3.c:199963:      *piOff = pCsr->aInst[iIdx*3 + 2];
vendor/sqlite3.c:199992:  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:199999:      rc = sqlite3Fts5StorageDocsize(pTab->pStorage, iRowid, pCsr->aColumnSize);
vendor/sqlite3.c:200004:          pCsr->aColumnSize[i] = -1;
vendor/sqlite3.c:200012:          void *p = (void*)(&pCsr->aColumnSize[i]);
vendor/sqlite3.c:200013:          pCsr->aColumnSize[i] = 0;
vendor/sqlite3.c:200029:      *pnToken += pCsr->aColumnSize[i];
vendor/sqlite3.c:200032:    *pnToken = pCsr->aColumnSize[iCol];
vendor/sqlite3.c:200053:  for(pData=pCsr->pAuxdata; pData; pData=pData->pNext){
vendor/sqlite3.c:200054:    if( pData->pAux==pCsr->pAux ) break;
vendor/sqlite3.c:200068:    pData->pAux = pCsr->pAux;
vendor/sqlite3.c:200069:    pData->pNext = pCsr->pAuxdata;
vendor/sqlite3.c:200070:    pCsr->pAuxdata = pData;
vendor/sqlite3.c:200083:  for(pData=pCsr->pAuxdata; pData; pData=pData->pNext){
vendor/sqlite3.c:200084:    if( pData->pAux==pCsr->pAux ) break;
vendor/sqlite3.c:200104:  if( pIter->a>=pIter->b ){
vendor/sqlite3.c:200109:    pIter->a += fts5GetVarint32(pIter->a, iVal);
vendor/sqlite3.c:200111:      pIter->a += fts5GetVarint32(pIter->a, iVal);
vendor/sqlite3.c:200114:      pIter->a += fts5GetVarint32(pIter->a, iVal);
vendor/sqlite3.c:200128:  int rc = fts5CsrPoslist(pCsr, iPhrase, &pIter->a, &n);
vendor/sqlite3.c:200130:    pIter->b = &pIter->a[n];
vendor/sqlite3.c:200144:  Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;
vendor/sqlite3.c:200147:    if( pIter->a>=pIter->b ){
vendor/sqlite3.c:200151:      pIter->a += fts5GetVarint32(&pIter->a[0], iIncr);
vendor/sqlite3.c:200152:      *piCol += (iIncr-2);
vendor/sqlite3.c:200157:      if( pIter->a>=pIter->b ){
vendor/sqlite3.c:200161:      if( pIter->a[0]==0x01 ) break;
vendor/sqlite3.c:200162:      pIter->a += fts5GetVarint32(pIter->a, dummy);
vendor/sqlite3.c:200164:    pIter->a += 1 + fts5GetVarint32(&pIter->a[1], *piCol);
vendor/sqlite3.c:200176:  Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;
vendor/sqlite3.c:200179:    Fts5Sorter *pSorter = pCsr->pSorter;
vendor/sqlite3.c:200182:      int i1 = (iPhrase==0 ? 0 : pSorter->aIdx[iPhrase-1]);
vendor/sqlite3.c:200183:      n = pSorter->aIdx[iPhrase] - i1;
vendor/sqlite3.c:200184:      pIter->a = &pSorter->aPoslist[i1];
vendor/sqlite3.c:200186:      rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, iPhrase, &pIter->a, &n);
vendor/sqlite3.c:200189:      pIter->b = &pIter->a[n];
vendor/sqlite3.c:200195:    rc = fts5CsrPoslist(pCsr, iPhrase, &pIter->a, &n);
vendor/sqlite3.c:200197:      pIter->b = &pIter->a[n];
vendor/sqlite3.c:200200:      }else if( pIter->a[0]==0x01 ){
vendor/sqlite3.c:200201:        pIter->a += 1 + fts5GetVarint32(&pIter->a[1], *piCol);
vendor/sqlite3.c:200249:  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
vendor/sqlite3.c:200253:  rc = fts5OpenMethod(pCsr->base.pVtab, (sqlite3_vtab_cursor**)&pNew);
vendor/sqlite3.c:200259:    rc = sqlite3Fts5ExprClonePhrase(pCsr->pExpr, iPhrase, &pNew->pExpr);
vendor/sqlite3.c:200286:  assert( pCsr->pAux==0 );
vendor/sqlite3.c:200287:  pCsr->pAux = pAux;
vendor/sqlite3.c:200289:  pCsr->pAux = 0;
vendor/sqlite3.c:200294:  for(pCsr=pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){
vendor/sqlite3.c:200295:    if( pCsr->iCsrId==iCsrId ) break;
vendor/sqlite3.c:200341:  pTab = (Fts5Table*)pCsr->base.pVtab;
vendor/sqlite3.c:200365:  int nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
vendor/sqlite3.c:200369:  switch( ((Fts5Table*)(pCsr->base.pVtab))->pConfig->eDetail ){
vendor/sqlite3.c:200375:        int nByte = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &dummy);
vendor/sqlite3.c:200383:        nPoslist = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &pPoslist);
vendor/sqlite3.c:200394:        rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, i, &dummy, &nByte);
vendor/sqlite3.c:200402:        rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, i, &pPoslist, &nPoslist);
vendor/sqlite3.c:200424:  Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
vendor/sqlite3.c:200431:  if( pCsr->ePlan==FTS5_PLAN_SPECIAL ){
vendor/sqlite3.c:200433:      sqlite3_result_int64(pCtx, pCsr->iSpecial);
vendor/sqlite3.c:200442:    sqlite3_result_int64(pCtx, pCsr->iCsrId);
vendor/sqlite3.c:200446:    if( pCsr->ePlan==FTS5_PLAN_SOURCE ){
vendor/sqlite3.c:200449:        pCsr->ePlan==FTS5_PLAN_MATCH
vendor/sqlite3.c:200450:     || pCsr->ePlan==FTS5_PLAN_SORTED_MATCH
vendor/sqlite3.c:200452:      if( pCsr->pRank || SQLITE_OK==(rc = fts5FindRankFunction(pCsr)) ){
vendor/sqlite3.c:200453:        fts5ApiInvoke(pCsr->pRank, pCsr, pCtx, pCsr->nRankArg, pCsr->apRankArg);
vendor/sqlite3.c:200459:      sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol+1));
vendor/sqlite3.c:204192:** are interpreted. Less-than and less-than-or-equal are treated 
vendor/sqlite3.c:204193:** identically, as are greater-than and greater-than-or-equal.
vendor/sqlite3.c:204302:    pCsr->pIndex = pIndex;
vendor/sqlite3.c:204303:    pCsr->pStmt = pStmt;
vendor/sqlite3.c:204304:    pCsr->pConfig = pConfig;
vendor/sqlite3.c:204305:    pCsr->aCnt = (i64*)&pCsr[1];
vendor/sqlite3.c:204306:    pCsr->aDoc = &pCsr->aCnt[pConfig->nCol];
vendor/sqlite3.c:204316:  pCsr->rowid = 0;
vendor/sqlite3.c:204317:  sqlite3Fts5IterClose(pCsr->pIter);
vendor/sqlite3.c:204318:  pCsr->pIter = 0;
vendor/sqlite3.c:204319:  sqlite3_free(pCsr->zLeTerm);
vendor/sqlite3.c:204320:  pCsr->nLeTerm = -1;
vendor/sqlite3.c:204321:  pCsr->zLeTerm = 0;
vendor/sqlite3.c:204331:  sqlite3Fts5BufferFree(&pCsr->term);
vendor/sqlite3.c:204332:  sqlite3_finalize(pCsr->pStmt);
vendor/sqlite3.c:204340:  if( sqlite3Fts5IterEof(pCsr->pIter) ){
vendor/sqlite3.c:204341:    pCsr->bEof = 1;
vendor/sqlite3.c:204345:    zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);
vendor/sqlite3.c:204346:    if( pCsr->nLeTerm>=0 ){
vendor/sqlite3.c:204347:      int nCmp = MIN(nTerm, pCsr->nLeTerm);
vendor/sqlite3.c:204348:      int bCmp = memcmp(pCsr->zLeTerm, zTerm, nCmp);
vendor/sqlite3.c:204349:      if( bCmp<0 || (bCmp==0 && pCsr->nLeTerm<nTerm) ){
vendor/sqlite3.c:204350:        pCsr->bEof = 1;
vendor/sqlite3.c:204354:    sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);
vendor/sqlite3.c:204360:  int eDetail = pCsr->pConfig->eDetail;
vendor/sqlite3.c:204362:  Fts5IndexIter *pIter = pCsr->pIter;
vendor/sqlite3.c:204363:  i64 *pp = &pCsr->iInstPos;
vendor/sqlite3.c:204364:  int *po = &pCsr->iInstOff;
vendor/sqlite3.c:204367:      || sqlite3Fts5PoslistNext64(pIter->pData, pIter->nData, po, pp) 
vendor/sqlite3.c:204369:    pCsr->iInstPos = 0;
vendor/sqlite3.c:204370:    pCsr->iInstOff = 0;
vendor/sqlite3.c:204372:    rc = sqlite3Fts5IterNextScan(pCsr->pIter);
vendor/sqlite3.c:204378:      pCsr->bEof = 1;
vendor/sqlite3.c:204391:  Fts5VocabTable *pTab = (Fts5VocabTable*)pCursor->pVtab;
vendor/sqlite3.c:204393:  int nCol = pCsr->pConfig->nCol;
vendor/sqlite3.c:204395:  pCsr->rowid++;
vendor/sqlite3.c:204402:    for(pCsr->iCol++; pCsr->iCol<nCol; pCsr->iCol++){
vendor/sqlite3.c:204403:      if( pCsr->aDoc[pCsr->iCol] ) break;
vendor/sqlite3.c:204407:  if( pTab->eType!=FTS5_VOCAB_COL || pCsr->iCol>=nCol ){
vendor/sqlite3.c:204408:    if( sqlite3Fts5IterEof(pCsr->pIter) ){
vendor/sqlite3.c:204409:      pCsr->bEof = 1;
vendor/sqlite3.c:204414:      zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);
vendor/sqlite3.c:204415:      if( pCsr->nLeTerm>=0 ){
vendor/sqlite3.c:204416:        int nCmp = MIN(nTerm, pCsr->nLeTerm);
vendor/sqlite3.c:204417:        int bCmp = memcmp(pCsr->zLeTerm, zTerm, nCmp);
vendor/sqlite3.c:204418:        if( bCmp<0 || (bCmp==0 && pCsr->nLeTerm<nTerm) ){
vendor/sqlite3.c:204419:          pCsr->bEof = 1;
vendor/sqlite3.c:204424:      sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);
vendor/sqlite3.c:204425:      memset(pCsr->aCnt, 0, nCol * sizeof(i64));
vendor/sqlite3.c:204426:      memset(pCsr->aDoc, 0, nCol * sizeof(i64));
vendor/sqlite3.c:204427:      pCsr->iCol = 0;
vendor/sqlite3.c:204431:        int eDetail = pCsr->pConfig->eDetail;
vendor/sqlite3.c:204436:        pPos = pCsr->pIter->pData;
vendor/sqlite3.c:204437:        nPos = pCsr->pIter->nData;
vendor/sqlite3.c:204443:                pCsr->aCnt[0]++;
vendor/sqlite3.c:204446:            pCsr->aDoc[0]++;
vendor/sqlite3.c:204454:                pCsr->aCnt[ii]++;
vendor/sqlite3.c:204460:                  pCsr->aDoc[ii]++;
vendor/sqlite3.c:204471:                pCsr->aDoc[iPos]++;
vendor/sqlite3.c:204475:              pCsr->aDoc[0]++;
vendor/sqlite3.c:204485:          rc = sqlite3Fts5IterNextScan(pCsr->pIter);
vendor/sqlite3.c:204490:          zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);
vendor/sqlite3.c:204491:          if( nTerm!=pCsr->term.n || memcmp(zTerm, pCsr->term.p, nTerm) ){
vendor/sqlite3.c:204494:          if( sqlite3Fts5IterEof(pCsr->pIter) ) break;
vendor/sqlite3.c:204500:  if( rc==SQLITE_OK && pCsr->bEof==0 && pTab->eType==FTS5_VOCAB_COL ){
vendor/sqlite3.c:204501:    while( pCsr->aDoc[pCsr->iCol]==0 ) pCsr->iCol++;
vendor/sqlite3.c:204502:    assert( pCsr->iCol<pCsr->pConfig->nCol );
vendor/sqlite3.c:204517:  Fts5VocabTable *pTab = (Fts5VocabTable*)pCursor->pVtab;
vendor/sqlite3.c:204549:      pCsr->nLeTerm = sqlite3_value_bytes(pLe);
vendor/sqlite3.c:204550:      pCsr->zLeTerm = sqlite3_malloc(pCsr->nLeTerm+1);
vendor/sqlite3.c:204551:      if( pCsr->zLeTerm==0 ){
vendor/sqlite3.c:204554:        memcpy(pCsr->zLeTerm, zCopy, pCsr->nLeTerm+1);
vendor/sqlite3.c:204560:    rc = sqlite3Fts5IndexQuery(pCsr->pIndex, zTerm, nTerm, f, 0, &pCsr->pIter);
vendor/sqlite3.c:204566:   && !pCsr->bEof 
vendor/sqlite3.c:204567:   && (eType!=FTS5_VOCAB_INSTANCE || pCsr->pConfig->eDetail!=FTS5_DETAIL_NONE)
vendor/sqlite3.c:204581:  return pCsr->bEof;
vendor/sqlite3.c:204590:  int eDetail = pCsr->pConfig->eDetail;
vendor/sqlite3.c:204591:  int eType = ((Fts5VocabTable*)(pCursor->pVtab))->eType;
vendor/sqlite3.c:204596:        pCtx, (const char*)pCsr->term.p, pCsr->term.n, SQLITE_TRANSIENT
vendor/sqlite3.c:204602:        const char *z = pCsr->pConfig->azCol[pCsr->iCol];
vendor/sqlite3.c:204606:      iVal = pCsr->aDoc[pCsr->iCol];
vendor/sqlite3.c:204608:      iVal = pCsr->aCnt[pCsr->iCol];
vendor/sqlite3.c:204613:      iVal = pCsr->aDoc[0];
vendor/sqlite3.c:204615:      iVal = pCsr->aCnt[0];
vendor/sqlite3.c:204621:        sqlite3_result_int64(pCtx, pCsr->pIter->iRowid);
vendor/sqlite3.c:204626:          ii = FTS5_POS2COLUMN(pCsr->iInstPos);
vendor/sqlite3.c:204628:          ii = (int)pCsr->iInstPos;
vendor/sqlite3.c:204630:        if( ii>=0 && ii<pCsr->pConfig->nCol ){
vendor/sqlite3.c:204631:          const char *z = pCsr->pConfig->azCol[ii];
vendor/sqlite3.c:204639:          int ii = FTS5_POS2OFFSET(pCsr->iInstPos);
vendor/sqlite3.c:204661:  *pRowid = pCsr->rowid;
vendor/sqlite3.c:204823:  pCur->db = ((stmt_vtab*)p)->db;
vendor/sqlite3.c:204824:  *ppCursor = &pCur->base;
vendor/sqlite3.c:204842:  pCur->iRowid++;
vendor/sqlite3.c:204843:  pCur->pStmt = sqlite3_next_stmt(pCur->db, pCur->pStmt);
vendor/sqlite3.c:204859:      sqlite3_result_text(ctx, sqlite3_sql(pCur->pStmt), -1, SQLITE_TRANSIENT);
vendor/sqlite3.c:204863:      sqlite3_result_int(ctx, sqlite3_column_count(pCur->pStmt));
vendor/sqlite3.c:204867:      sqlite3_result_int(ctx, sqlite3_stmt_readonly(pCur->pStmt));
vendor/sqlite3.c:204871:      sqlite3_result_int(ctx, sqlite3_stmt_busy(pCur->pStmt));
vendor/sqlite3.c:204885:      sqlite3_result_int(ctx, sqlite3_stmt_status(pCur->pStmt,
vendor/sqlite3.c:204899:  *pRowid = pCur->iRowid;
vendor/sqlite3.c:204909:  return pCur->pStmt==0;
vendor/sqlite3.c:204924:  pCur->pStmt = 0;
vendor/sqlite3.c:204925:  pCur->iRowid = 0;
